[{"title":"Unit Testing","date":"2016-12-21T09:58:16.000Z","path":"2016/12/21/unit-testing/","text":"12341.Testing Framework Review2.High-level Overview3.Time to Testing4.What’s new?(Asynchronous Testing, Performance Testing) 12345Xcode’s testing frameworks Xcode5: OCUnit -&gt; XCTestXcode5.1: OCUnit Xcode6: new XCTest API 12test class name end with Tests.(e:ViewModelTests)test case methods must start with the word test so that the test runner can find them.(e:testInitialization) 12345XCTestCaseThe default XCTestCase class contains a setup() and a tearDown() method.For every test function, the test runner calls setup() and tearDown()Override these methods to perform any necessary configuration of your object before the test runs, and any cleanup after. 1234567891011121314151617181920AssertionsXCTFail(format…) 生成一个失败的测试； XCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过； XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；XCTAssert(expression, format...)当expression求值为TRUE时通过； XCTAssertTrue(expression, format...)当expression求值为TRUE时通过； XCTAssertFalse(expression, format...)当expression求值为False时通过； XCTAssertEqualObjects(a1, a2, format...)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；XCTAssertNotEqualObjects(a1, a2, format...)判断不等，[a1 isEqual:a2]值为False时通过；XCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）； XCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试； XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试； XCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过； XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过 123456Asynchronous TestingPerformance TestingmeasureBlock: which takes a block of code and measures the execution time of the entire block.measureMetrics: is a more intimate version of measureBlock that offers fine grained control of what to measure,and when to measure it. 12345678910How Xcode decides to mark a performance test as success or failure, here’s the logicFor convenience AVE means average,STDDEV means standard deviation:1. If the test has no baseline, the result is neither a success nor a failure.2. If the current run’s STDDEV minus the baseline STDDEV took less than 0.1 second, ignore it.3. If the current run&apos;s STDDEV minus the baseline STDDEV took more than 0.1 second and the difference is more than 10%, it’s a failure.4. If the current run’s AVE minus the baseline AVE took less than 0.1 second, ignore it.5. If the current run’s AVE minus the baseline AVE took more than 0.1 second and the difference is more than 10%, it’s a failure.6. Everything else is considered a success.","tags":[]},{"title":"产品 产品","date":"2016-12-20T09:52:09.000Z","path":"2016/12/20/产品-产品/","text":"产品的迭代需要有计划，有策略的进行。就像下象棋一样，承前启后，打出组合拳。才能达到目标。","tags":[{"name":"迭代","slug":"迭代","permalink":"http://yoursite.com/tags/迭代/"}]},{"title":"Swift-Objective-C到底哪家强","date":"2016-08-22T07:44:42.000Z","path":"2016/08/22/Swift-Objective-C到底哪家强/","text":"swift出世后，人们茶余饭后就会讨论Swift和OC到底哪家强？Swift好用吗？下面主要从用法和性能方面来讨论。 语法 毫无疑问，从第一眼看到Swift。就看到了它的简洁，语法更清楚，更容易被理解。这要归结于Swift的设计，它借鉴了很多语言（C、JavaScript、Python、Java）的优点，特别是动态语言。让你写起来更简单有趣。同时，Swift也提供了面向对象编程。 性能 测试平台：MacMini 2.6 GHz Intel Core i5， Xcode8.2，Swift3.0 循环循环一百万次，里面什么事也不做 swift 12345678910111213let oneMillion = 1000000let startTimes = NSDate().timeIntervalSince1970 * 1000func loop() &#123; for _ in 1...oneMillion &#123; &#125;&#125;loop()let endTimes = NSDate().timeIntervalSince1970 * 1000let usedTimes = endTimes - startTimesprint(\"loop a million times used \\(usedTimes) ms\") OC 12345678910int oneMillion = 1000000;NSTimeInterval startTimes = [[NSDate date] timeIntervalSince1970] * 1000;for (NSUInteger i = 0; i &lt; oneMillion; i++)&#123;&#125;NSTimeInterval endTimes = [[NSDate date] timeIntervalSince1970] * 1000;NSTimeInterval usedTimes = endTimes - startTimes;printf(\"used times %f ms\", usedTimes); 用时（运行十次取平均值）Swift： 3.62075195ms（3.333984375, 3.486083984375, 5.197998046875, 3.31982421875, 3.321044921875,3.31982421875, 3.338134765625, 4.220947265625, 3.32177734375, 3.347900390625,）Objective-C：2.4488037ms (2.345947, 2.363037, 2.292725, 2.596924, 2.352051,2.587158, 2.348145, 2.649902, 2.412109, 2.540039,) 快速排序 快速排序就取10k个数，分为三种情况（正常，倒序，均值） 正常swift 123456789101112131415161718192021222324252627let count = 10000let arr = Array(1...count)let startTimes = NSDate().timeIntervalSince1970 * 1000// *** Simple but inefficient version of quicksort ***func quicksort&lt;T: Comparable&gt;(_ a: [T]) -&gt; [T] &#123; guard a.count &gt; 1 else &#123; return a &#125; let pivot = a[a.count/2] let less = a.filter &#123; $0 &lt; pivot &#125; let equal = a.filter &#123; $0 == pivot &#125; let greater = a.filter &#123; $0 &gt; pivot &#125; // Uncomment this following line to see in detail what the // pivot is in each step and how the subarrays are partitioned. //print(pivot, less, equal, greater) return quicksort(less) + equal + quicksort(greater) return quicksort(less) + equal + quicksort(greater)&#125;quicksort(arr)let endTimes = NSDate().timeIntervalSince1970 * 1000let usedTimes = endTimes - startTimesprint(\"times used \\(usedTimes) ms\") OC 12345678910111213141516NSUInteger cap = 10000;NSMutableArray *arr = [NSMutableArray arrayWithCapacity:cap];for (NSUInteger i = 0; i &lt; cap; i++) &#123; NSNumber *num = [NSNumber numberWithInteger:i]; arr[i] =num;&#125;NSTimeInterval startTimes = [[NSDate date] timeIntervalSince1970] * 1000;[self QuickSorkOC:arr Count:[arr count]];NSTimeInterval endTimes = [[NSDate date] timeIntervalSince1970] * 1000;NSTimeInterval usedTimes = endTimes - startTimes;printf(\"used times %f ms\", usedTimes); 用时（运行十次取平均值）Swift： 201.352221ms（226.079833984375, 180.364990234375, 182.054931640625, 195.965087890625, 197.198974609375,193.84375, 268.726806640625, 191.621826171875, 188.782958984375, 188.883056640625,）Objective-C：1551.05075ms (1497.709961, 1507.664062, 1505.760254, 1498.334961, 1578.202148,1499.712158, 1531.479736, 1492.811035, 1684.247070, 1714.586182) 倒序考虑最坏的情况，数据是从大到小的。只需要把数组倒序过来 swift 12var arr = Array(1...count)arr.sort(by: &gt;) OC 1arr = (NSMutableArray *)[[arr reverseObjectEnumerator] allObjects]; 用时（运行十次取平均值）Swift： 193.266601ms（184.419189453125, 255.409912109375, 189.22509765625, 198.416259765625, 190.2978515625,181.308837890625, 187.583984375, 184.344970703125, 183.385009765625, 178.27490234375,）Objective-C：1644.0257ms(1911.626709, 1546.142090, 1542.587158, 1929.552979, 1553.895020,1576.763672, 1586.454102, 1558.053955, 1548.708252, 1686.473145,) 均值swift 12let count = 10000var arr = Array(repeating: 0, count: count) OC 1234for (NSUInteger i = 0; i &lt; cap; i++) &#123; NSNumber *num = [NSNumber numberWithInteger:0]; arr[i] = num;&#125; 用时（运行十次取平均值）Swift： 16.3355224ms（13.64892578125, 21.63916015625, 15.175048828125, 21.05322265625, 17.60595703125,13.64111328125, 17.98193359375, 13.454833984375, 14.905029296875, 14.25, ）Objective-C： 10.8430176ms (18.000977, 10.387207, 10.093994, 10.768066, 9.725098,10.739014, 10.843018, 12.367188, 16.007812, 10.340820, ) 内存管理 Swift也是采用了自动引用计数（ARC）来管理内存，这样可以是程序员专注于核心的应用逻辑以及新的功能特性上。把内存管理交给编译器去做。但值得注意的是，要避免循环引用造成的内存泄漏。 安全 用OC的时候，比较经常遇到的崩溃是空指针（nil、null）和数组越界。在OC中你对nil发送消息，是被允许的，它什么事情都不会发生。而这就是得看起来并不会崩溃，但其实它隐藏着一个巨大的bug。这种bug是随机的，并且很能复现。这就造成在修复的时候必须发大力气来寻找问题所在。 在Swift中提供了可选类型使得一个nil可选值的可能性变得非常的明确，这样你就很明白了。如果你不小心写了不明确的代码时编译器会报错。问题就在编写的时候就修复好了，这就大大节省了修复OC指针逻辑的bug时间。 维护 历史遗留下来的问题，使得OC不得不用两个文件。如果C没有改进的话，OC也就没办法跟着改变。在OC中，优化构建的时间以及创建App的效率就比不上Swift了。OC的两份文件系统就多了额外的工作，特别是在维护的时候，不得不来回的切换，幸好有快捷键，但也会觉得繁琐。 BTW：良好的编程规范是很重要的 好不好用？用了才知道，语言它只是个表现手法，编程思想才是最重要的。适合团队的开发工具，能够高效的工作才是首选！","tags":[{"name":"swift,","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"App-store转让App","date":"2015-08-22T07:44:42.000Z","path":"2015/08/22/App-store转让App/","text":"有时候需要转让App到别的账号下，需要注意的是只有符合条件的App才能转让。由于App store里面应用名字的唯一性，当你新建了应用还没来得急上传，想把它过度到另外账号下只能等第一个版本审核通过后才能操作。 符合条件的才行 填写账号 Team ID在这 同意就行 登录另一个账号 填写信息，接收就可以了。应用马上就过来了，但App store上的信息还要等apple 服务器同步才行。","tags":[{"name":"iTunesconnect,","slug":"itunesconnect","permalink":"http://yoursite.com/tags/itunesconnect/"}]},{"title":"Cornerstone ignore UserInterfaceState.xcuserstate","date":"2014-11-21T09:18:44.000Z","path":"2014/11/21/Cornerstone-ignore-UserInterfaceState.xcuserstate/","text":"在控制台 cd 到项目目录下svn -v status 查看文件的状态(M): M 33769 33757 xxx XXX.xcworkspace/xcuserdata/XXX.xcuserdatad/UserInterfaceState.xcuserstate svn delete --keep-local --force xcuserdata/user.xcuserdatad/UserInterfaceState.xcuserstate 此时，Cornerstone会显示它的状态为”？”,右键Ignore。解决了，世界清静了:] PS:added .xcuserstate to the Global Ignores (Cornerstone -&gt; Preferences -&gt; Subversion -&gt; turn off Use default global ignores -&gt; add “\\.xcuserstate”)","tags":[{"name":"xcode","slug":"xcode","permalink":"http://yoursite.com/tags/xcode/"},{"name":"svn","slug":"svn","permalink":"http://yoursite.com/tags/svn/"},{"name":"tutorial","slug":"tutorial","permalink":"http://yoursite.com/tags/tutorial/"}]},{"title":"Swift笔记","date":"2014-08-22T07:44:42.000Z","path":"2014/08/22/swift笔记/","text":"swift出世时，断断续续看了一些。在PlayGround耍了耍还是挺好玩的:]有OC作为基础，上手swift还是挺快的。但是有一些语法还是要留意下。这个就作为学习笔记吧，记录学习过程中的注意点。swift官网The Swift Programming Language if nil在OC中我们在判断一个值是不是nil时，一般就是123NSString *values = @\"\";if(values) &#123;&#125; 但在swift中，是会报错的12345var apple = \"apple\"if apple &#123; print(apple)&#125;//'String' is not convertible to 'Bool' Apple 在GuidedTour中写道：In an if statement, the conditional must be a Boolean expression—this means that code such as if score { … } is an error, not an implicit comparison to zero. You can use if and let together to work with values that might be missing. These values are represented as optionals. An optional value either contains a value or contains nil to indicate that a value is missing. Write a question mark (?) after the type of a value to mark the value as optional. 正确的写法12345678var optionalString: String? = nilprint(optionalString == nil)if let str = optionalString &#123; print(str)&#125; else &#123; print(\"optionalString is nil\")&#125; 这样写也可以123456789var optionalString: String? = \"janes\"print(optionalString == nil)let isBool = (optionalString == nil)if isBool &#123; print(\"optionalString is nil \\(isBool)\")&#125; else &#123; print(\"optionalString is not nil\")&#125; ###12let sortedNumbers = numbers.sort &#123; $0 &gt; $1 &#125;print(sortedNumbers)","tags":[{"name":"swift,","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"iOS Crash Log处理","date":"2014-06-24T06:02:36.000Z","path":"2014/06/24/ios-crash-log处理/","text":"iOS crash log 处理 什么是崩溃日志，从哪里能得它? iOS设备上的应用闪退时，操作系统会生成一个崩溃报告，也叫崩溃日志，保存在设备上。 1234Device LogsCrashReporter ~/Library/Logs/CrashReporter/MobileDevice/iTunes Connect -&gt; Crash Reports用户 什么情况下会产生崩溃日志? 两种主要情况会产生崩溃日志: 1. 应用违反操作系统规则。 2. 应用中有Bug。 Array.map12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Incident Identifier: CE5E9C4A-A13D-4734-8483-97D55825AB57CrashReporter Key: d3adfba37a68e78e6885adfe06034f2798cf0762Hardware Model: iPhone6,1Process: XiaoYu [447]Path: /var/mobile/Applications/20FA34C5-0EC1-4692-A89E-1DC7C818C013/XiaoYu.app/XiaoYuIdentifier: com.rt.FISH4iPhoneVersion: 3.0.0 (3.0.0)Code Type: ARM (Native)Parent Process: launchd [1]Date/Time: 2014-06-20 18:32:00.417 +0800OS Version: iOS 7.1.1 (11D201)Report Version: 104Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Triggered by Thread: 0Last Exception Backtrace:(0x2fa3ef0b 0x3a1d1ce7 0x2fa3ee4d 0x54af09 0x3a7e971b 0x3a7ee7b7 0x3a736ff9 0x3a7add25 0x3a1d83a9 0x322a6857 0x3a1e0b6b 0x2f96f185 0x31ee933d 0x31eee7c7 0x3a1e0b6b 0x2f96f185 0x31ef0e11 0x3a6bad3f 0x3a6bd6c3 0x2fa09681 0x2fa07f4d 0x2f972769 0x2f97254b 0x348cf6d3 0x322d1891 0x233c79 0x3a6cfab7)Thread 0 Crashed:Last Exception Backtrace:(0x2fa3ef0b 0x3a1d1ce7 0x2fa3ee4d 0x54af09 0x3a7e971b 0x3a7ee7b7 0x3a736ff9 0x3a7add25 0x3a1d83a9 0x322a6857 0x3a1e0b6b 0x2f96f185 0x31ee933d 0x31eee7c7 0x3a1e0b6b 0x2f96f185 0x31ef0e11 0x3a6bad3f 0x3a6bd6c3 0x2fa09681 0x2fa07f4d 0x2f972769 0x2f97254b 0x348cf6d3 0x322d1891 0x233c79 0x3a6cfab7)Thread 0 Crashed:0 libsystem_kernel.dylib 0x3a7861f0 0x3a773000 + 783201 libsystem_pthread.dylib 0x3a7ee7b3 0x3a7eb000 + 142592 libsystem_c.dylib 0x3a736ff5 0x3a6ed000 + 3030933 libc++abi.dylib 0x39b8598b 0x39b85000 + 24434 libc++abi.dylib 0x39b9c1f5 0x39b85000 + 947095 libc++abi.dylib 0x39b9ba05 0x39b85000 + 926776 libobjc.A.dylib 0x3a1d1db7 0x3a1ce000 + 157997 CoreFoundation 0x2fa3ee49 0x2f96a000 + 8720098 XiaoYu 0x0054af05 0x10000 + 54842939 libsystem_platform.dylib 0x3a7e9719 0x3a7e6000 + 1410510 libsystem_pthread.dylib 0x3a7ee7b3 0x3a7eb000 + 1425911 libsystem_c.dylib 0x3a736ff5 0x3a6ed000 + 30309312 libsystem_malloc.dylib 0x3a7add21 0x3a7ab000 + 1155313 libobjc.A.dylib 0x3a1d83a5 0x3a1ce000 + 4189314 UIKit 0x322a6853 0x32263000 + 27656315 libobjc.A.dylib 0x3a1e0b67 0x3a1ce000 + 7664716 CoreFoundation 0x2f96f181 0x2f96a000 + 2086517 QuartzCore 0x31ee9339 0x31ede000 + 4588118 QuartzCore 0x31eee7c3 0x31ede000 + 6752319 libobjc.A.dylib 0x3a1e0b67 0x3a1ce000 + 7664720 CoreFoundation 0x2f96f181 0x2f96a000 + 2086521 QuartzCore 0x31ef0e0d 0x31ede000 + 7732522 libdispatch.dylib 0x3a6bad3d 0x3a6ba000 + 338923 libdispatch.dylib 0x3a6bd6bf 0x3a6ba000 + 1401524 CoreFoundation 0x2fa0967d 0x2f96a000 + 65292525 CoreFoundation 0x2fa07f49 0x2f96a000 + 64698526 CoreFoundation 0x2f972765 0x2f96a000 + 3466127 CoreFoundation 0x2f972547 0x2f96a000 + 3411928 GraphicsServices 0x348cf6cf 0x348c6000 + 3860729 UIKit 0x322d188d 0x32263000 + 45274930 XiaoYu 0x00233c75 0x10000 + 224370131 libdyld.dylib 0x3a6cfab5 0x3a6ce000 + 6837Thread 1:Thread 0 crashed with ARM Thread State (32-bit): r0: 0x00000000 r1: 0x00000000 r2: 0x00000000 r3: 0x00002060 r4: 0x00000006 r5: 0x3c42818c r6: 0x186e33b0 r7: 0x27df21b0 r8: 0x186e33b0 r9: 0x00000001 r10: 0x00000006 r11: 0x00000005 ip: 0x00000148 sp: 0x27df21a4 lr: 0x3a7ee7b7 pc: 0x3a7861f0 cpsr: 0x00000010Binary Images:","tags":[{"name":"iOS","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"iOS-MDM流程记录","date":"2014-01-08T01:56:00.000Z","path":"2014/01/08/iOS-MDM流程记录/","text":"MDM开发流程1.申请企业开发者账号，这一步比较麻烦的是申请邓白氏码，因为要通过华夏邓白氏那边的审核。拖了比较久。2.有开发者账号就可以做MDM证书了， 主要参考:mbaikesofthinker 这里要注意的是12//Change to your alias 是你证书的名字！String alias = \"MbaikeMDMCSR\"; mdm证书制作1.用apple钥匙串访问工具生成CertificateSigningRequest.certSigningRequest2.利用生成的公私钥中的私钥导出为vendor.p122.登陆299企业帐号创建并下载mdm.cer4.下载AppleWWDRCA 证书5.下载AppleIncRootCertificate 苹果根证书6.利用以下命令将cer证书转成证pem书123openssl x509 -inform der -in mdm.cer -out mdm.pemopenssl x509 -inform der -in AppleWWDRCA.cer -out intermediate.pemopenssl x509 -inform der -in AppleIncRootCertificate.cer -out root.pem 7.生成客户端证书123openssl genrsa -des3 -out customerPrivateKey.pem 2048openssl req -new -key customerPrivateKey.pem -out customer.csropenssl req -inform pem -outform der -in customer.csr -out customer.der 8.利用MDMIOSGenerateEncodedPlist.java生成plist.xml和plist_encoded9.打开 https://identity.apple.com/pushcert/ 登陆任意appleid帐号，上传plist_encoded文件，申请通过后，下载apns-mdm.pem证书10.将apns-mdm.pem与customerPrivateKey.pem合并为apns-mdm.p121openssl pkcs12 -export -inkeycustomerPrivateKey.pem -in apns-mdm.pem -out apns-mdm.p12 此apns-mdm.p12就是mdm服务器和苹果anps服务器通讯用的p12也是mobileconf中绑定的p12(mobileconf最终安装在移动设备上) MDMplist 3.申请服务器所需证书 4.部署https(SSL)服务器环境 最好做下域名映射！ 5.配置描述文件mobileconfig的生成 下载iPhone配置实用工具，配置通用和移动设备管理注意：a：Topic must be com.apple.mgmt. b：通用的安全性为总是 c：移动设备管理中的使用开发APNS服务器不能勾选 主要参考：(http://www.mbaike.net/ios/1560.html) 导出（选“无”）后签名 1openssl smime -sign -in unsigned.mobileconfig -out signed.mobileconfig -signer mbaike.crt -inkey mbaike.key -certfile ca-bundle.pem -outform der -nodetach","tags":[{"name":"iOS MDM","slug":"ios-mdm","permalink":"http://yoursite.com/tags/ios-mdm/"}]},{"title":"Lua内存管理","date":"2011-07-04T07:55:00.000Z","path":"2011/07/04/Lua内存管理/","text":"本文主要介绍某项目脚本(lua)部分内存泄漏的查证与处理过程，希望对大家有点帮助。需要说明的是，lua本身并不存在真正的内存泄漏，只是因为使用上面的原因导致无法gc，从而导致逻辑上的泄漏:)。 参考GCObject的声明可以发现，lua中的复杂数据类型变量的传递都是基于引用的。当lua从根开始gc扫描的时候，只要还有一个地方有对此变量的引用，那么这个变量就不会被collect。这种情况造成的危害取决于多大程度上依赖于引用，如果有适当的间接层/弱引用来隔离这个问题，可能问题会有所缓解。 以下是一些常见的错误引用情景: 1.本应该local 的变量进入global空间或者module空间了(忘记写local)，如果这是一个table/function/udata等类型的变量的话，非常不幸的，这个变量将不会被正确gc了 —-除非你再显式的释放。这是非常容易犯的错误，一直在想为什么lua变量不是默认local呢？ 当然这个话题会引发另外一场争论。 1234local function test_user(id) userobj = get_user_by_id(id) --这里总是会有一个玩家对象泄漏 print(\"only test\", userobj:get_name())end 2.c/c++部分调用的lua_ref是否有正常lua_unref释放？ 通过debug.getregistry()可以查到这些ref. 3.其他各种各样的实际bug造成的泄漏。 当怀疑系统有泄漏以后，我们可以怎么查到这些泄漏呢？我强烈建议大家建立一个weak table, 把你所有创建过的能够称之为资源的，包含但不限于“战斗对象，玩家，npc，物品，场景，邮件”等等对象全部扔到这个table里面。当你知道玩家已经下线、战斗已经销毁了，但通过连续的强制full gc以后weak table里面还有这个变量，这就证明了这个变量的引用没有被完全释放，于是问题就被发现了，我们又有事情干了@_@。 知道有泄漏是比较容易的，能够完全揪出来就不是很容易了。是的，它究竟在哪儿呢? 一开始在此项目里面也是先发现比如某npc泄漏了，然后就去查代码，看看究竟哪个地方写得不对。这种方式效率极低，基本上查不到什么问题。在迟一点的时候才使用现在的方案：从_G深度遍历所有的table、metatable、funciton’supvalue、function’s env、registentry(lua_ref)。 目前所知的所有引用必定存在于这几个空间， 遍历完成以后一定可以找到那个“迷失了的引用”。 这种方式在脚本层就可以完成所有事情，甚至你可以在运营环境中在线查证，其遍历的速度是非常快的，但内存开销非常大(:，可以考虑一边遍历一边gc，当然还要记得避免重复搜索。 在应用此方案以后，此项目解决了脚本中所有的泄漏问题。 一点总结：1.如果系统性能还能够承受的话，建议不要直接引用对象，可以多做一层间接层。2.lua里面的弱引用是非常有用的。3.比较大的物理内存是必要的，这可以为大家查证问题争取足够多的时间:) 4.可以把查找泄漏的部分写入到关机逻辑里面，每次关机的时候自动查找泄漏，然后出具报告。","tags":[{"name":"Lua","slug":"lua","permalink":"http://yoursite.com/tags/lua/"}]}]