[{"title":"Objective-C id as Swift Any","date":"2017-02-09T06:29:00.000Z","path":"2017/02/09/objective-c-id-as-swift-any/","text":"Swift3 接口和Objective-C 的APIs比之前的版本更强大。例如，Swift 2将Objective-C中的id类型映射到Swift中的AnyObject类型，通常只能保存值类型。 Swift 2还为AnyObject提供了对一些桥接值类型（例如String，Array，Dictionary，Set和一些数字）的隐式转换，以便原生Swift类型可以很容易地使用Cocoa APIs，如NSString，NSArray或Foundation的其他容器类。这些转换与语言的其他部分不一致，使得很难理解什么可以用作AnyObject，结果是bugs。 在Swift 3中，Objective-C中的id类型现在映射到Swift中的Any类型，它描述了任何类型的值，无论是类，枚举，结构还是任何其他Swift类型。这种变化使得Swift中的Objective-C APIs更加灵活，因为Swift定义的值类型可以传递给Objective-C API，并作为Swift类型返回，从而无需手动“box”类型。这些优点也扩展到集合：Objective-C集合类型NSArray，NSDictionary和NSSet，以前只接受AnyObject的元素，现在可以保存Any类型的元素。对于散列容器，例如Dictionary和Set，有一个新类型AnyHashable可以容纳任何类型的值遵循Swift Hashable协议。总之，从Swift 2到Swift 3以下类型映射更改为： Objective-C Swift2 Swift3 id AnyObject Any NSArray * [AnyObject] [Any] NSDictionary * [NSObject: AnyObject] [AnyHashable: Any] NSSet * Set Set 在许多情况下，您的代码不必为响应此更改而显着地更改。 Swift 2中的代码依赖于隐式转换为AnyObject的值类型，它将继续按照Any的原样在Swift 3中工作。但是，有些地方需要更改声明的变量和方法类型，并获得Swift 3的最佳体验。另外，如果你的代码显式使用AnyObject或Cocoa类，如NSString，NSArray或NSDictionary，你将需要引入更多的显式转换使用as NSString或as String，因为在Swift 3中对象和值类型之间的隐式转换不再允许。Xcode中的自动迁移器将进行最小的更改，以保持您的代码从Swift 2到3编译，但结果可能不总是最优雅的。本文将介绍您可能需要做的一些更改，以及在更改代码以充分利用id为Any时需要注意的一些陷阱。 覆盖方法和遵循协议当子类化一个Objective-C类并覆盖它的方法，或者遵循一个Objective-C协议，当父方法在Objective-C中使用id时，需要更新方法的类型。一些常见的例子是NSObject类的isEqual：方法和NSCopying协议的copyWithZone：方法。在Swift 2中，你将写一个遵循NSCopying的NSObject子类，如下所示： 12345// Swift 2class Foo: NSObject, NSCopying &#123; override func isEqual(_ x: AnyObject?) -&gt; Bool &#123; ... &#125; func copyWithZone(_ zone: NSZone?) -&gt; AnyObject &#123; ... &#125;&#125; 在Swift 3中，除了将命名从copyWithZone（_ :)更改为copy（with :)之外，还需要将这些方法的签名更改为Any而不是AnyObject： 12345// Swift 3class Foo: NSObject, NSCopying &#123; override func isEqual(_ x: Any?) -&gt; Bool &#123; ... &#125; func copy(with zone: NSZone?) -&gt; Any &#123; ... &#125;&#125; 非类型集合属性列表，JSON和用户信息字典在Cocoa中很常见，Cocoa本地将这些表示为非类型化集合。在Swift 2中，为此需要构建Array，Dictionary或Set with AnyObject或NSObject元素，依靠隐式桥接转换来处理值类型： 12345678910111213141516171819202122// Swift 2struct State &#123; var name: String var abbreviation: String var population: Int var asPropertyList: [NSObject: AnyObject] &#123; var result: [NSObject: AnyObject] = [:] // Implicit conversions turn String into NSString here… result[\"name\"] = self.name result[\"abbreviation\"] = self.abbreviation // …and Int into NSNumber here. result[\"population\"] = self.population return result &#125;&#125;let california = State(name: \"California\", abbreviation: \"CA\", population: 39_000_000)NSNotification(name: \"foo\", object: nil, userInfo: california.asPropertyList) 或者，您可以使用Cocoa容器类，例如NSDictionary： 12345678910111213141516171819202122// Swift 2struct State &#123; var name: String var abbreviation: String var population: Int var asPropertyList: NSDictionary &#123; var result = NSMutableDictionary() // Implicit conversions turn String into NSString here… result[\"name\"] = self.name result[\"abbreviation\"] = self.abbreviation // …and Int into NSNumber here. result[\"population\"] = self.population return result.copy() &#125;&#125;let california = State(name: \"California\", abbreviation: \"CA\", population: 39_000_000)// NSDictionary then implicitly converts to [NSObject: AnyObject] here.NSNotification(name: \"foo\", object: nil, userInfo: california.asPropertyList) 在Swift 3中，隐式转换已经消失，因此上述两个片段都不会按原样工作。迁移者可能建议用as单独转换每个值，以保持此代码的工作，但有一个更好的解决方案。 Swift现在导入Cocoa API接受Any和/或AnyHashable的集合，所以我们可以更改集合类型为[AnyHashable：Any]替换[NSObject：AnyObject]或NSDictionary，而不更改任何其他代码： 1234567891011121314151617181920212223// Swift 3struct State &#123; var name: String var abbreviation: String var population: Int // Change the dictionary type to [AnyHashable: Any] here... var asPropertyList: [AnyHashable: Any] &#123; var result: [AnyHashable: Any] = [:] // No implicit conversions necessary, since String and Int are subtypes // of Any and AnyHashable result[\"name\"] = self.name result[\"abbreviation\"] = self.abbreviation result[\"population\"] = self.population return result &#125;&#125;let california = State(name: \"California\", abbreviation: \"CA\", population: 39_000_000)// ...and you can still use it with Cocoa API hereNotification(name: \"foo\", object: nil, userInfo: california.asPropertyList) AnyHashable类型Swift的Any类型可以保存任何类型，但是Dictionary和Set需要的键是Hashable，所以Any是太普通。从Swift 3开始，Swift标准库提供了一个新的类型AnyHashable。与Any类似，它充当所有Hashable类型的父类型，因此String，Int和其他hashable类型的值可以隐式地用AnyHashable值，AnyHashable中的类型可以使用is，as!或as?动态检查，动态转换运算符。当从Objective-C导入无类型的NSDictionary或NSSet对象时，使用AnyHashable，但是在纯Swift中也可用于构建异构集合或字典。 未链接上下文的显式转换在某些有限的情况下，Swift不能自动桥接C和Objective-C构造。例如，一些C和Cocoa API使用id * 指针作为“out”或“in-out”参数，并且由于Swift不能静态地确定指针的使用方式，因此它不能对内存中的值自动执行桥接转换。在这种情况下，指针仍将显示为UnsafePointer 。如果您需要使用这些非桥接API，您可以使用显式桥接转换，在代码中使用as Type或as AnyObject显式编写。 1234567// ObjC@interface Foo- (void)updateString:(NSString *)string;- (void)updateObject:(id *)obj;@end 123456789101112// Swiftfunc interactWith(foo: Foo) -&gt; (String, Any) &#123; var string = \"string\" as NSString // explicit conversion foo.updateString(&amp;string) // parameter imports as UnsafeMutablePointer&lt;NSString&gt; let finishedString = string as String var object = \"string\" as AnyObject foo.updateObject(&amp;object) // parameter imports as UnsafeMutablePointer&lt;AnyObject&gt; let finishedObject = object as Any return (finishedString, finishedObject)&#125; 另外，Objective-C协议在Swift中仍然是类约束，所以你不能让Swift结构或枚举直接遵循Objective-C协议或者使用轻量级通用类。您需要使用这些协议和API显式转换String as NSString，Array as NSArray等。 AnyObject成员查找Any没有与AnyObject相同的魔法方法查找行为。这可能会破坏一些Swift 2代码，查找属性或发送消息到一个无类型的Objective-C对象。例如，这个Swift 2的代码： 12345// Swift 2func foo(x: NSArray) &#123; // Invokes -description by magic AnyObject lookup print(x[0].description)&#125; 将抱怨description不是Swift 3中Any的成员。可以将x [0] as AnyObject以获取动态行为： 12345// Swift 3func foo(x: NSArray) &#123; // Result of subscript is now Any, needs to be coerced to get method lookup print((x[0] as AnyObject).description)&#125; 或者，将值强制转换为您期望的具体对象类型： 1234func foo(x: NSArray) &#123; // Cast to the concrete object type you expect print((x[0] as! NSObject).description)&#125; Swift中的值类型Any可以hold住任何结构，枚举，元组或你可以在语言中定义的其他Swift类型。 Swift 3中的Objective-C桥接器可以提供任何Swift值作为Objective-C的id兼容对象。这使得更容易在Cocoa容器，userInfo字典和其他对象中存储自定义Swift值类型。例如，在Swift 2中，您需要将数据类型更改为类，或者手动box它们，以将它们的值附加到NSNotification： 1234567891011121314151617// Swift 2struct CreditCard &#123; number: UInt64, expiration: NSDate &#125;let PaymentMade = \"PaymentMade\"// We can't attach CreditCard directly to the notification, since it// isn't a class, and doesn't bridge.// Wrap it in a Box class.class Box&lt;T&gt; &#123; let value: T init(value: T) &#123; self.value = value &#125;&#125;let paymentNotification = NSNotification(name: PaymentMade, object: Box(value: CreditCard(number: 1234_0000_0000_0000, expiration: NSDate()))) 使用Swift 3，我们可以取消box，并将对象直接附加到Notification： 12345678// Swift 3let PaymentMade = Notification.Name(\"PaymentMade\")// We can associate the CreditCard value directly with the Notificationlet paymentNotification = Notification(name: PaymentMade, object: CreditCard(number: 1234_0000_0000_0000, expiration: Date())) 在Objective-C中，CreditCard值将作为一个id兼容的，继承NSObject对象实现isEqual：，hash和description，如果它们存在原生的Swift类型的话，使用Swift的Equatable，Hashable和CustomStringConvertible。从Swift中，可以通过将其动态地转换回其原始类型来检索该值： 123// Swift 3let paymentCard = paymentNotification.object as! CreditCardprint(paymentCard.number) // 1234000000000000 请注意，在Swift 3.0中，一些常见的Swift和Objective-C结构类型将桥接为不透明对象，而不是惯用的Cocoa对象。例如，Int，UInt，Double和Bool桥接到NSNumber，其他大小的数字类型，例如Int8，UInt16等只桥接为不透明对象。可变结构如CGRect，CGPoint和CGSize也作为不透明对象桥接，即使大多数Cocoa API期望它们一起作为对象在NSValue实例中被box。如果你看到unrecognized selector sent to _SwiftValue错误，这表明Objective-C代码试图调用一个不透明的Swift值类型的方法，你可能需要手动box该类的实例中Objective-C代码期望的值。 要注意的一个特殊问题是Optionals。 Swift Any可以代表任何东西，包括一个Optional，所以可以在不首先检查它情况下将一个包装的Optional传递给Objective-C API，即使API被声明为一个nonnull id类型。这通常表现为包括_SwiftValue的运行时错误，而不是编译时错误。 Xcode 8.1 beta中包含的Swift 3.0.1通过实现这些建议来透明地处理数字类型，Objective-C结构和可选类型，以解决NSNumber，NSValue和Optional桥接中的上述限制： SE–0139: Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue SE–0140: Warn when Optional converts to Any, and bridge Optional As Its Payload Or NSNull 为了避免向前兼容性问题，你不应该依赖_SwiftValue类的不透明对象的实现细节，因为未来版本的Swift可能允许更多的Swift类型桥接到惯用的Objective-C类。 Linux可移植性在Linux上使用Swift Core 运行的Swift程序库使用了原生Swift中编写的一个Foundation版本，没有Objective-C运行时桥接。 id-as-Any允许Core Libraries直接使用原生Swift Any和标准库值类型，同时使用Objective-C Foundation实现保持与Apple平台上的代码兼容。由于Swift在Linux上不与Objective-C交互操作，因此不支持桥接转换，例如string as NSString或value as AnyObject。希望在Cocoa和Swift Core Libraries之间移植的Swift代码应该只使用值类型。 学习更多id-as-Any是Swift语言改进的一个很好的例子，受到用户对早期版本的Swift的反馈的启发，并通过来自开放的Swift Evolution过程的回顾完善。如果你想更多地了解id-as-Any背后的动机和设计决策，原始的Swift Evolution提议可以在GitHub的swift-evolution仓库中找到： SE-0072：完全消除来自Swift的隐式桥接转换 SE-0116：将Objective-C **id**导入为Swift**Any**类型 SE-0131：将AnyHashable添加到标准库 最终结果是，Swift是一种更加一致的语言，当使用Swift时，Cocoa API变得更强大。","tags":[]},{"title":"Unit Testing","date":"2016-12-21T09:58:16.000Z","path":"2016/12/21/unit-testing/","text":"12341.Testing Framework Review2.High-level Overview3.Time to Testing4.What’s new?(Asynchronous Testing, Performance Testing) 12345Xcode’s testing frameworks Xcode5: OCUnit -&gt; XCTestXcode5.1: OCUnit Xcode6: new XCTest API 12test class name end with Tests.(e:ViewModelTests)test case methods must start with the word test so that the test runner can find them.(e:testInitialization) 12345XCTestCaseThe default XCTestCase class contains a setup() and a tearDown() method.For every test function, the test runner calls setup() and tearDown()Override these methods to perform any necessary configuration of your object before the test runs, and any cleanup after. 1234567891011121314151617181920AssertionsXCTFail(format…) 生成一个失败的测试； XCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过； XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；XCTAssert(expression, format...)当expression求值为TRUE时通过； XCTAssertTrue(expression, format...)当expression求值为TRUE时通过； XCTAssertFalse(expression, format...)当expression求值为False时通过； XCTAssertEqualObjects(a1, a2, format...)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；XCTAssertNotEqualObjects(a1, a2, format...)判断不等，[a1 isEqual:a2]值为False时通过；XCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）； XCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试； XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试； XCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过； XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过 123456Asynchronous TestingPerformance TestingmeasureBlock: which takes a block of code and measures the execution time of the entire block.measureMetrics: is a more intimate version of measureBlock that offers fine grained control of what to measure,and when to measure it. 12345678910How Xcode decides to mark a performance test as success or failure, here’s the logicFor convenience AVE means average,STDDEV means standard deviation:1. If the test has no baseline, the result is neither a success nor a failure.2. If the current run’s STDDEV minus the baseline STDDEV took less than 0.1 second, ignore it.3. If the current run&apos;s STDDEV minus the baseline STDDEV took more than 0.1 second and the difference is more than 10%, it’s a failure.4. If the current run’s AVE minus the baseline AVE took less than 0.1 second, ignore it.5. If the current run’s AVE minus the baseline AVE took more than 0.1 second and the difference is more than 10%, it’s a failure.6. Everything else is considered a success.","tags":[]},{"title":"Markdown语法说明","date":"2016-12-20T09:52:09.000Z","path":"2016/12/20/Markdown语法说明/","text":"标题： #h1级标题 ##h2级标题 ###h3级标题 ####h4级标题 #####h5级标题 ######h6级标题 分割线：三个以上的短线 即可作出分割线 超链接：连接名称我是链接名 点我刷新 另一种超链接写法：[链接名][链接代号]here然后在别的地方定义 3 这个详细链接信息， 直接展示链接的写法：http://www.izhangbo.cn 键盘键Ctrl+[ and Ctrl+] code格式：反引号Use the printf() function. There is a literal backtick (`) here.针对在代码区段内插入反引号的情况 强调：斜体强调粗体强调 图片 使用 icon 图标文字 段落：以一个空行开始，以一个空行结束，中间的就是一个段落。 表格： Item Value Computer $1600 Phone $12 Pipe $1 无序列表：使用 - 加一个空格（） 无需列表1 无序列表2 无序列表3 有序列表：使用 数字 加一个英文句点 有序列表 有序列表 有序列表 有序列表 有序列表 换行缩进形成代码区块 这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。 块引用 给引用的文本开始位置都加一个 ‘&gt;’，便可组成一个块引用。在块引用中，可以结合其他markdown元素一块使用，比如列表。强调也可以只在第一行加大于号，其他位置不加。 块引用里使用列表，需要和上面的内容隔开一个空行 记得加空格哦。","tags":[]},{"title":"产品 产品","date":"2016-12-20T09:52:09.000Z","path":"2016/12/20/产品-产品/","text":"产品的迭代需要有计划，有策略的进行。就像下象棋一样，承前启后，打出组合拳。才能达到目标。","tags":[{"name":"迭代","slug":"迭代","permalink":"http://yoursite.com/tags/迭代/"}]},{"title":"playGroud","date":"2016-12-16T06:25:32.000Z","path":"2016/12/16/playgroud/","text":"( ⊙ o ⊙ )啊！ –引用块 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing –代码块1alert(&apos;Hello World!&apos;); 1[rectangle setX: 10 y: 10 width: 20 height: 20]; Array.map1array.map(callback[, thisArg]) _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 反引号代码块另一种形式的代码块，不同的是它使用三个反引号来包裹。 [language] [title] [url] [link text] code snippetPull Quote在文章中插入 Pull quote。 content jsFiddle在文章中嵌入 jsFiddle。 Gist在文章中嵌入 Gist。 iframe在文章中插入 iframe。 Image在文章中插入指定大小的图片。 source/images Link在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。 text url [external] [title] Include Code插入 source 文件夹内的代码文件。 Youtube在文章中插入 Youtube 视频。 Vimeo在文章中插入 Vimeo 视频。 引用文章引用其他文章的链接。 引用资源引用文章的资源。 Raw如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。 content","tags":[{"name":"tag1","slug":"tag1","permalink":"http://yoursite.com/tags/tag1/"}]},{"title":"Swift-Objective-C到底哪家强","date":"2016-08-22T07:44:42.000Z","path":"2016/08/22/Swift-Objective-C到底哪家强/","text":"swift出世后，人们茶余饭后就会讨论Swift和OC到底哪家强？Swift好用吗？下面主要从用法和性能方面来讨论。 语法 毫无疑问，从第一眼看到Swift。就看到了它的简洁，语法更清楚，更容易被理解。这要归结于Swift的设计，它借鉴了很多语言（C、JavaScript、Python、Java）的优点，特别是动态语言。让你写起来更简单有趣。同时，Swift也提供了面向对象编程。 性能 测试平台：MacMini 2.6 GHz Intel Core i5， Xcode8.2，Swift3.0 循环循环一百万次，里面什么事也不做 swift 12345678910111213let oneMillion = 1000000let startTimes = NSDate().timeIntervalSince1970 * 1000func loop() &#123; for _ in 1...oneMillion &#123; &#125;&#125;loop()let endTimes = NSDate().timeIntervalSince1970 * 1000let usedTimes = endTimes - startTimesprint(\"loop a million times used \\(usedTimes) ms\") OC 12345678910int oneMillion = 1000000;NSTimeInterval startTimes = [[NSDate date] timeIntervalSince1970] * 1000;for (NSUInteger i = 0; i &lt; oneMillion; i++)&#123;&#125;NSTimeInterval endTimes = [[NSDate date] timeIntervalSince1970] * 1000;NSTimeInterval usedTimes = endTimes - startTimes;printf(\"used times %f ms\", usedTimes); 用时（运行十次取平均值）Swift： 3.62075195ms（3.333984375, 3.486083984375, 5.197998046875, 3.31982421875, 3.321044921875,3.31982421875, 3.338134765625, 4.220947265625, 3.32177734375, 3.347900390625,）Objective-C：2.4488037ms (2.345947, 2.363037, 2.292725, 2.596924, 2.352051,2.587158, 2.348145, 2.649902, 2.412109, 2.540039,) 快速排序 快速排序就取10k个数，分为三种情况（正常，倒序，均值） 正常swift 123456789101112131415161718192021222324252627let count = 10000let arr = Array(1...count)let startTimes = NSDate().timeIntervalSince1970 * 1000// *** Simple but inefficient version of quicksort ***func quicksort&lt;T: Comparable&gt;(_ a: [T]) -&gt; [T] &#123; guard a.count &gt; 1 else &#123; return a &#125; let pivot = a[a.count/2] let less = a.filter &#123; $0 &lt; pivot &#125; let equal = a.filter &#123; $0 == pivot &#125; let greater = a.filter &#123; $0 &gt; pivot &#125; // Uncomment this following line to see in detail what the // pivot is in each step and how the subarrays are partitioned. //print(pivot, less, equal, greater) return quicksort(less) + equal + quicksort(greater) return quicksort(less) + equal + quicksort(greater)&#125;quicksort(arr)let endTimes = NSDate().timeIntervalSince1970 * 1000let usedTimes = endTimes - startTimesprint(\"times used \\(usedTimes) ms\") OC 12345678910111213141516NSUInteger cap = 10000;NSMutableArray *arr = [NSMutableArray arrayWithCapacity:cap];for (NSUInteger i = 0; i &lt; cap; i++) &#123; NSNumber *num = [NSNumber numberWithInteger:i]; arr[i] =num;&#125;NSTimeInterval startTimes = [[NSDate date] timeIntervalSince1970] * 1000;[self QuickSorkOC:arr Count:[arr count]];NSTimeInterval endTimes = [[NSDate date] timeIntervalSince1970] * 1000;NSTimeInterval usedTimes = endTimes - startTimes;printf(\"used times %f ms\", usedTimes); 用时（运行十次取平均值）Swift： 201.352221ms（226.079833984375, 180.364990234375, 182.054931640625, 195.965087890625, 197.198974609375,193.84375, 268.726806640625, 191.621826171875, 188.782958984375, 188.883056640625,）Objective-C：1551.05075ms (1497.709961, 1507.664062, 1505.760254, 1498.334961, 1578.202148,1499.712158, 1531.479736, 1492.811035, 1684.247070, 1714.586182) 倒序考虑最坏的情况，数据是从大到小的。只需要把数组倒序过来 swift 12var arr = Array(1...count)arr.sort(by: &gt;) OC 1arr = (NSMutableArray *)[[arr reverseObjectEnumerator] allObjects]; 用时（运行十次取平均值）Swift： 193.266601ms（184.419189453125, 255.409912109375, 189.22509765625, 198.416259765625, 190.2978515625,181.308837890625, 187.583984375, 184.344970703125, 183.385009765625, 178.27490234375,）Objective-C：1644.0257ms(1911.626709, 1546.142090, 1542.587158, 1929.552979, 1553.895020,1576.763672, 1586.454102, 1558.053955, 1548.708252, 1686.473145,) 均值swift 12let count = 10000var arr = Array(repeating: 0, count: count) OC 1234for (NSUInteger i = 0; i &lt; cap; i++) &#123; NSNumber *num = [NSNumber numberWithInteger:0]; arr[i] = num;&#125; 用时（运行十次取平均值）Swift： 16.3355224ms（13.64892578125, 21.63916015625, 15.175048828125, 21.05322265625, 17.60595703125,13.64111328125, 17.98193359375, 13.454833984375, 14.905029296875, 14.25, ）Objective-C： 10.8430176ms (18.000977, 10.387207, 10.093994, 10.768066, 9.725098,10.739014, 10.843018, 12.367188, 16.007812, 10.340820, ) 内存管理 Swift也是采用了自动引用计数（ARC）来管理内存，这样可以是程序员专注于核心的应用逻辑以及新的功能特性上。把内存管理交给编译器去做。但值得注意的是，要避免循环引用造成的内存泄漏。 安全 用OC的时候，比较经常遇到的崩溃是空指针（nil、null）和数组越界。在OC中你对nil发送消息，是被允许的，它什么事情都不会发生。而这就是得看起来并不会崩溃，但其实它隐藏着一个巨大的bug。这种bug是随机的，并且很能复现。这就造成在修复的时候必须发大力气来寻找问题所在。 在Swift中提供了可选类型使得一个nil可选值的可能性变得非常的明确，这样你就很明白了。如果你不小心写了不明确的代码时编译器会报错。问题就在编写的时候就修复好了，这就大大节省了修复OC指针逻辑的bug时间。 维护 历史遗留下来的问题，使得OC不得不用两个文件。如果C没有改进的话，OC也就没办法跟着改变。在OC中，优化构建的时间以及创建App的效率就比不上Swift了。OC的两份文件系统就多了额外的工作，特别是在维护的时候，不得不来回的切换，幸好有快捷键，但也会觉得繁琐。 BTW：良好的编程规范是很重要的 好不好用？用了才知道，语言它只是个表现手法，编程思想才是最重要的。适合团队的开发工具，能够高效的工作才是首选！","tags":[{"name":"swift,","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"App-store转让App","date":"2015-08-22T07:44:42.000Z","path":"2015/08/22/App-store转让App/","text":"有时候需要转让App到别的账号下，需要注意的是只有符合条件的App才能转让。由于App store里面应用名字的唯一性，当你新建了应用还没来得急上传，想把它过度到另外账号下只能等第一个版本审核通过后才能操作。 符合条件的才行 填写账号 Team ID在这 同意就行 登录另一个账号 填写信息，接收就可以了。应用马上就过来了，但App store上的信息还要等apple 服务器同步才行。","tags":[{"name":"iTunesconnect,","slug":"itunesconnect","permalink":"http://yoursite.com/tags/itunesconnect/"}]},{"title":"Cornerstone ignore UserInterfaceState.xcuserstate","date":"2014-11-21T09:18:44.000Z","path":"2014/11/21/Cornerstone-ignore-UserInterfaceState.xcuserstate/","text":"在控制台 cd 到项目目录下svn -v status 查看文件的状态(M): M 33769 33757 xxx XXX.xcworkspace/xcuserdata/XXX.xcuserdatad/UserInterfaceState.xcuserstate svn delete --keep-local --force xcuserdata/user.xcuserdatad/UserInterfaceState.xcuserstate 此时，Cornerstone会显示它的状态为”？”,右键Ignore。解决了，世界清静了:] PS:added .xcuserstate to the Global Ignores (Cornerstone -&gt; Preferences -&gt; Subversion -&gt; turn off Use default global ignores -&gt; add “\\.xcuserstate”)","tags":[{"name":"xcode","slug":"xcode","permalink":"http://yoursite.com/tags/xcode/"},{"name":"svn","slug":"svn","permalink":"http://yoursite.com/tags/svn/"},{"name":"tutorial","slug":"tutorial","permalink":"http://yoursite.com/tags/tutorial/"}]},{"title":"Swift笔记","date":"2014-08-22T07:44:42.000Z","path":"2014/08/22/swift笔记/","text":"swift出世时，断断续续看了一些。在PlayGround耍了耍还是挺好玩的:]有OC作为基础，上手swift还是挺快的。但是有一些语法还是要留意下。这个就作为学习笔记吧，记录学习过程中的注意点。swift官网The Swift Programming Language if nil在OC中我们在判断一个值是不是nil时，一般就是123NSString *values = @\"\";if(values) &#123;&#125; 但在swift中，是会报错的12345var apple = \"apple\"if apple &#123; print(apple)&#125;//'String' is not convertible to 'Bool' Apple 在GuidedTour中写道：In an if statement, the conditional must be a Boolean expression—this means that code such as if score { … } is an error, not an implicit comparison to zero. You can use if and let together to work with values that might be missing. These values are represented as optionals. An optional value either contains a value or contains nil to indicate that a value is missing. Write a question mark (?) after the type of a value to mark the value as optional. 正确的写法12345678var optionalString: String? = nilprint(optionalString == nil)if let str = optionalString &#123; print(str)&#125; else &#123; print(\"optionalString is nil\")&#125; 这样写也可以123456789var optionalString: String? = \"janes\"print(optionalString == nil)let isBool = (optionalString == nil)if isBool &#123; print(\"optionalString is nil \\(isBool)\")&#125; else &#123; print(\"optionalString is not nil\")&#125; ###12let sortedNumbers = numbers.sort &#123; $0 &gt; $1 &#125;print(sortedNumbers)","tags":[{"name":"swift,","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"iOS Crash Log处理","date":"2014-06-24T06:02:36.000Z","path":"2014/06/24/ios-crash-log处理/","text":"iOS crash log 处理 什么是崩溃日志，从哪里能得它? iOS设备上的应用闪退时，操作系统会生成一个崩溃报告，也叫崩溃日志，保存在设备上。 1234Device LogsCrashReporter ~/Library/Logs/CrashReporter/MobileDevice/iTunes Connect -&gt; Crash Reports用户 什么情况下会产生崩溃日志? 两种主要情况会产生崩溃日志: 1. 应用违反操作系统规则。 2. 应用中有Bug。 Array.map12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Incident Identifier: CE5E9C4A-A13D-4734-8483-97D55825AB57CrashReporter Key: d3adfba37a68e78e6885adfe06034f2798cf0762Hardware Model: iPhone6,1Process: XiaoYu [447]Path: /var/mobile/Applications/20FA34C5-0EC1-4692-A89E-1DC7C818C013/XiaoYu.app/XiaoYuIdentifier: com.rt.FISH4iPhoneVersion: 3.0.0 (3.0.0)Code Type: ARM (Native)Parent Process: launchd [1]Date/Time: 2014-06-20 18:32:00.417 +0800OS Version: iOS 7.1.1 (11D201)Report Version: 104Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Triggered by Thread: 0Last Exception Backtrace:(0x2fa3ef0b 0x3a1d1ce7 0x2fa3ee4d 0x54af09 0x3a7e971b 0x3a7ee7b7 0x3a736ff9 0x3a7add25 0x3a1d83a9 0x322a6857 0x3a1e0b6b 0x2f96f185 0x31ee933d 0x31eee7c7 0x3a1e0b6b 0x2f96f185 0x31ef0e11 0x3a6bad3f 0x3a6bd6c3 0x2fa09681 0x2fa07f4d 0x2f972769 0x2f97254b 0x348cf6d3 0x322d1891 0x233c79 0x3a6cfab7)Thread 0 Crashed:Last Exception Backtrace:(0x2fa3ef0b 0x3a1d1ce7 0x2fa3ee4d 0x54af09 0x3a7e971b 0x3a7ee7b7 0x3a736ff9 0x3a7add25 0x3a1d83a9 0x322a6857 0x3a1e0b6b 0x2f96f185 0x31ee933d 0x31eee7c7 0x3a1e0b6b 0x2f96f185 0x31ef0e11 0x3a6bad3f 0x3a6bd6c3 0x2fa09681 0x2fa07f4d 0x2f972769 0x2f97254b 0x348cf6d3 0x322d1891 0x233c79 0x3a6cfab7)Thread 0 Crashed:0 libsystem_kernel.dylib 0x3a7861f0 0x3a773000 + 783201 libsystem_pthread.dylib 0x3a7ee7b3 0x3a7eb000 + 142592 libsystem_c.dylib 0x3a736ff5 0x3a6ed000 + 3030933 libc++abi.dylib 0x39b8598b 0x39b85000 + 24434 libc++abi.dylib 0x39b9c1f5 0x39b85000 + 947095 libc++abi.dylib 0x39b9ba05 0x39b85000 + 926776 libobjc.A.dylib 0x3a1d1db7 0x3a1ce000 + 157997 CoreFoundation 0x2fa3ee49 0x2f96a000 + 8720098 XiaoYu 0x0054af05 0x10000 + 54842939 libsystem_platform.dylib 0x3a7e9719 0x3a7e6000 + 1410510 libsystem_pthread.dylib 0x3a7ee7b3 0x3a7eb000 + 1425911 libsystem_c.dylib 0x3a736ff5 0x3a6ed000 + 30309312 libsystem_malloc.dylib 0x3a7add21 0x3a7ab000 + 1155313 libobjc.A.dylib 0x3a1d83a5 0x3a1ce000 + 4189314 UIKit 0x322a6853 0x32263000 + 27656315 libobjc.A.dylib 0x3a1e0b67 0x3a1ce000 + 7664716 CoreFoundation 0x2f96f181 0x2f96a000 + 2086517 QuartzCore 0x31ee9339 0x31ede000 + 4588118 QuartzCore 0x31eee7c3 0x31ede000 + 6752319 libobjc.A.dylib 0x3a1e0b67 0x3a1ce000 + 7664720 CoreFoundation 0x2f96f181 0x2f96a000 + 2086521 QuartzCore 0x31ef0e0d 0x31ede000 + 7732522 libdispatch.dylib 0x3a6bad3d 0x3a6ba000 + 338923 libdispatch.dylib 0x3a6bd6bf 0x3a6ba000 + 1401524 CoreFoundation 0x2fa0967d 0x2f96a000 + 65292525 CoreFoundation 0x2fa07f49 0x2f96a000 + 64698526 CoreFoundation 0x2f972765 0x2f96a000 + 3466127 CoreFoundation 0x2f972547 0x2f96a000 + 3411928 GraphicsServices 0x348cf6cf 0x348c6000 + 3860729 UIKit 0x322d188d 0x32263000 + 45274930 XiaoYu 0x00233c75 0x10000 + 224370131 libdyld.dylib 0x3a6cfab5 0x3a6ce000 + 6837Thread 1:Thread 0 crashed with ARM Thread State (32-bit): r0: 0x00000000 r1: 0x00000000 r2: 0x00000000 r3: 0x00002060 r4: 0x00000006 r5: 0x3c42818c r6: 0x186e33b0 r7: 0x27df21b0 r8: 0x186e33b0 r9: 0x00000001 r10: 0x00000006 r11: 0x00000005 ip: 0x00000148 sp: 0x27df21a4 lr: 0x3a7ee7b7 pc: 0x3a7861f0 cpsr: 0x00000010Binary Images:","tags":[{"name":"iOS","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"iOS-MDM流程记录","date":"2014-01-08T01:56:00.000Z","path":"2014/01/08/iOS-MDM流程记录/","text":"MDM开发流程1.申请企业开发者账号，这一步比较麻烦的是申请邓白氏码，因为要通过华夏邓白氏那边的审核。拖了比较久。2.有开发者账号就可以做MDM证书了， 主要参考:mbaikesofthinker 这里要注意的是12//Change to your alias 是你证书的名字！String alias = \"MbaikeMDMCSR\"; mdm证书制作1.用apple钥匙串访问工具生成CertificateSigningRequest.certSigningRequest2.利用生成的公私钥中的私钥导出为vendor.p122.登陆299企业帐号创建并下载mdm.cer4.下载AppleWWDRCA 证书5.下载AppleIncRootCertificate 苹果根证书6.利用以下命令将cer证书转成证pem书123openssl x509 -inform der -in mdm.cer -out mdm.pemopenssl x509 -inform der -in AppleWWDRCA.cer -out intermediate.pemopenssl x509 -inform der -in AppleIncRootCertificate.cer -out root.pem 7.生成客户端证书123openssl genrsa -des3 -out customerPrivateKey.pem 2048openssl req -new -key customerPrivateKey.pem -out customer.csropenssl req -inform pem -outform der -in customer.csr -out customer.der 8.利用MDMIOSGenerateEncodedPlist.java生成plist.xml和plist_encoded9.打开 https://identity.apple.com/pushcert/ 登陆任意appleid帐号，上传plist_encoded文件，申请通过后，下载apns-mdm.pem证书10.将apns-mdm.pem与customerPrivateKey.pem合并为apns-mdm.p121openssl pkcs12 -export -inkeycustomerPrivateKey.pem -in apns-mdm.pem -out apns-mdm.p12 此apns-mdm.p12就是mdm服务器和苹果anps服务器通讯用的p12也是mobileconf中绑定的p12(mobileconf最终安装在移动设备上) MDMplist 3.申请服务器所需证书 4.部署https(SSL)服务器环境 最好做下域名映射！ 5.配置描述文件mobileconfig的生成 下载iPhone配置实用工具，配置通用和移动设备管理注意：a：Topic must be com.apple.mgmt. b：通用的安全性为总是 c：移动设备管理中的使用开发APNS服务器不能勾选 主要参考：(http://www.mbaike.net/ios/1560.html) 导出（选“无”）后签名 1openssl smime -sign -in unsigned.mobileconfig -out signed.mobileconfig -signer mbaike.crt -inkey mbaike.key -certfile ca-bundle.pem -outform der -nodetach","tags":[{"name":"iOS MDM","slug":"ios-mdm","permalink":"http://yoursite.com/tags/ios-mdm/"}]},{"title":"Lua内存管理","date":"2011-07-04T07:55:00.000Z","path":"2011/07/04/Lua内存管理/","text":"本文主要介绍某项目脚本(lua)部分内存泄漏的查证与处理过程，希望对大家有点帮助。需要说明的是，lua本身并不存在真正的内存泄漏，只是因为使用上面的原因导致无法gc，从而导致逻辑上的泄漏:)。 参考GCObject的声明可以发现，lua中的复杂数据类型变量的传递都是基于引用的。当lua从根开始gc扫描的时候，只要还有一个地方有对此变量的引用，那么这个变量就不会被collect。这种情况造成的危害取决于多大程度上依赖于引用，如果有适当的间接层/弱引用来隔离这个问题，可能问题会有所缓解。 以下是一些常见的错误引用情景: 1.本应该local 的变量进入global空间或者module空间了(忘记写local)，如果这是一个table/function/udata等类型的变量的话，非常不幸的，这个变量将不会被正确gc了 —-除非你再显式的释放。这是非常容易犯的错误，一直在想为什么lua变量不是默认local呢？ 当然这个话题会引发另外一场争论。 1234local function test_user(id) userobj = get_user_by_id(id) --这里总是会有一个玩家对象泄漏 print(\"only test\", userobj:get_name())end 2.c/c++部分调用的lua_ref是否有正常lua_unref释放？ 通过debug.getregistry()可以查到这些ref. 3.其他各种各样的实际bug造成的泄漏。 当怀疑系统有泄漏以后，我们可以怎么查到这些泄漏呢？我强烈建议大家建立一个weak table, 把你所有创建过的能够称之为资源的，包含但不限于“战斗对象，玩家，npc，物品，场景，邮件”等等对象全部扔到这个table里面。当你知道玩家已经下线、战斗已经销毁了，但通过连续的强制full gc以后weak table里面还有这个变量，这就证明了这个变量的引用没有被完全释放，于是问题就被发现了，我们又有事情干了@_@。 知道有泄漏是比较容易的，能够完全揪出来就不是很容易了。是的，它究竟在哪儿呢? 一开始在此项目里面也是先发现比如某npc泄漏了，然后就去查代码，看看究竟哪个地方写得不对。这种方式效率极低，基本上查不到什么问题。在迟一点的时候才使用现在的方案：从_G深度遍历所有的table、metatable、funciton’supvalue、function’s env、registentry(lua_ref)。 目前所知的所有引用必定存在于这几个空间， 遍历完成以后一定可以找到那个“迷失了的引用”。 这种方式在脚本层就可以完成所有事情，甚至你可以在运营环境中在线查证，其遍历的速度是非常快的，但内存开销非常大(:，可以考虑一边遍历一边gc，当然还要记得避免重复搜索。 在应用此方案以后，此项目解决了脚本中所有的泄漏问题。 一点总结：1.如果系统性能还能够承受的话，建议不要直接引用对象，可以多做一层间接层。2.lua里面的弱引用是非常有用的。3.比较大的物理内存是必要的，这可以为大家查证问题争取足够多的时间:) 4.可以把查找泄漏的部分写入到关机逻辑里面，每次关机的时候自动查找泄漏，然后出具报告。","tags":[{"name":"Lua","slug":"lua","permalink":"http://yoursite.com/tags/lua/"}]}]