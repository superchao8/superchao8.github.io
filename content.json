[{"title":"Unit Testing","date":"2016-12-21T09:58:16.000Z","path":"2016/12/21/unit-testing/","text":"12341.Testing Framework Review2.High-level Overview3.Time to Testing4.What’s new?(Asynchronous Testing, Performance Testing) 12345Xcode’s testing frameworks Xcode5: OCUnit -&gt; XCTestXcode5.1: OCUnit Xcode6: new XCTest API 12test class name end with Tests.(e:ViewModelTests)test case methods must start with the word test so that the test runner can find them.(e:testInitialization) 12345XCTestCaseThe default XCTestCase class contains a setup() and a tearDown() method.For every test function, the test runner calls setup() and tearDown()Override these methods to perform any necessary configuration of your object before the test runs, and any cleanup after. 1234567891011121314151617181920AssertionsXCTFail(format…) 生成一个失败的测试； XCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过； XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；XCTAssert(expression, format...)当expression求值为TRUE时通过； XCTAssertTrue(expression, format...)当expression求值为TRUE时通过； XCTAssertFalse(expression, format...)当expression求值为False时通过； XCTAssertEqualObjects(a1, a2, format...)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；XCTAssertNotEqualObjects(a1, a2, format...)判断不等，[a1 isEqual:a2]值为False时通过；XCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）； XCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试； XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试； XCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过； XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过 123456Asynchronous TestingPerformance TestingmeasureBlock: which takes a block of code and measures the execution time of the entire block.measureMetrics: is a more intimate version of measureBlock that offers fine grained control of what to measure,and when to measure it. 12345678910How Xcode decides to mark a performance test as success or failure, here’s the logicFor convenience AVE means average,STDDEV means standard deviation:1. If the test has no baseline, the result is neither a success nor a failure.2. If the current run’s STDDEV minus the baseline STDDEV took less than 0.1 second, ignore it.3. If the current run&apos;s STDDEV minus the baseline STDDEV took more than 0.1 second and the difference is more than 10%, it’s a failure.4. If the current run’s AVE minus the baseline AVE took less than 0.1 second, ignore it.5. If the current run’s AVE minus the baseline AVE took more than 0.1 second and the difference is more than 10%, it’s a failure.6. Everything else is considered a success.","tags":[]},{"title":"产品 产品","date":"2016-12-20T09:52:09.000Z","path":"2016/12/20/产品-产品/","text":"产品的迭代需要有计划，有策略的进行。就像下象棋一样，承前启后，打出组合拳。才能达到目标。","tags":[{"name":"迭代","slug":"迭代","permalink":"http://yoursite.com/tags/迭代/"}]},{"title":"Cornerstone ignore UserInterfaceState.xcuserstate","date":"2014-11-21T09:18:44.000Z","path":"2014/11/21/Cornerstone-ignore-UserInterfaceState.xcuserstate/","text":"在控制台 cd 到项目目录下svn -v status 查看文件的状态(M): M 33769 33757 xxx XXX.xcworkspace/xcuserdata/XXX.xcuserdatad/UserInterfaceState.xcuserstate svn delete --keep-local --force xcuserdata/user.xcuserdatad/UserInterfaceState.xcuserstate 此时，Cornerstone会显示它的状态为”？”,右键Ignore。解决了，世界清静了:] PS:added .xcuserstate to the Global Ignores (Cornerstone -&gt; Preferences -&gt; Subversion -&gt; turn off Use default global ignores -&gt; add “\\.xcuserstate”)","tags":[{"name":"xcode","slug":"xcode","permalink":"http://yoursite.com/tags/xcode/"},{"name":"svn","slug":"svn","permalink":"http://yoursite.com/tags/svn/"},{"name":"tutorial","slug":"tutorial","permalink":"http://yoursite.com/tags/tutorial/"}]},{"title":"iOS Crash Log处理","date":"2014-06-24T06:02:36.000Z","path":"2014/06/24/ios-crash-log处理/","text":"iOS crash log 处理 什么是崩溃日志，从哪里能得它? iOS设备上的应用闪退时，操作系统会生成一个崩溃报告，也叫崩溃日志，保存在设备上。 1234Device LogsCrashReporter ~/Library/Logs/CrashReporter/MobileDevice/iTunes Connect -&gt; Crash Reports用户 什么情况下会产生崩溃日志? 两种主要情况会产生崩溃日志: 1. 应用违反操作系统规则。 2. 应用中有Bug。 Array.map12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Incident Identifier: CE5E9C4A-A13D-4734-8483-97D55825AB57CrashReporter Key: d3adfba37a68e78e6885adfe06034f2798cf0762Hardware Model: iPhone6,1Process: XiaoYu [447]Path: /var/mobile/Applications/20FA34C5-0EC1-4692-A89E-1DC7C818C013/XiaoYu.app/XiaoYuIdentifier: com.rt.FISH4iPhoneVersion: 3.0.0 (3.0.0)Code Type: ARM (Native)Parent Process: launchd [1]Date/Time: 2014-06-20 18:32:00.417 +0800OS Version: iOS 7.1.1 (11D201)Report Version: 104Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Triggered by Thread: 0Last Exception Backtrace:(0x2fa3ef0b 0x3a1d1ce7 0x2fa3ee4d 0x54af09 0x3a7e971b 0x3a7ee7b7 0x3a736ff9 0x3a7add25 0x3a1d83a9 0x322a6857 0x3a1e0b6b 0x2f96f185 0x31ee933d 0x31eee7c7 0x3a1e0b6b 0x2f96f185 0x31ef0e11 0x3a6bad3f 0x3a6bd6c3 0x2fa09681 0x2fa07f4d 0x2f972769 0x2f97254b 0x348cf6d3 0x322d1891 0x233c79 0x3a6cfab7)Thread 0 Crashed:Last Exception Backtrace:(0x2fa3ef0b 0x3a1d1ce7 0x2fa3ee4d 0x54af09 0x3a7e971b 0x3a7ee7b7 0x3a736ff9 0x3a7add25 0x3a1d83a9 0x322a6857 0x3a1e0b6b 0x2f96f185 0x31ee933d 0x31eee7c7 0x3a1e0b6b 0x2f96f185 0x31ef0e11 0x3a6bad3f 0x3a6bd6c3 0x2fa09681 0x2fa07f4d 0x2f972769 0x2f97254b 0x348cf6d3 0x322d1891 0x233c79 0x3a6cfab7)Thread 0 Crashed:0 libsystem_kernel.dylib 0x3a7861f0 0x3a773000 + 783201 libsystem_pthread.dylib 0x3a7ee7b3 0x3a7eb000 + 142592 libsystem_c.dylib 0x3a736ff5 0x3a6ed000 + 3030933 libc++abi.dylib 0x39b8598b 0x39b85000 + 24434 libc++abi.dylib 0x39b9c1f5 0x39b85000 + 947095 libc++abi.dylib 0x39b9ba05 0x39b85000 + 926776 libobjc.A.dylib 0x3a1d1db7 0x3a1ce000 + 157997 CoreFoundation 0x2fa3ee49 0x2f96a000 + 8720098 XiaoYu 0x0054af05 0x10000 + 54842939 libsystem_platform.dylib 0x3a7e9719 0x3a7e6000 + 1410510 libsystem_pthread.dylib 0x3a7ee7b3 0x3a7eb000 + 1425911 libsystem_c.dylib 0x3a736ff5 0x3a6ed000 + 30309312 libsystem_malloc.dylib 0x3a7add21 0x3a7ab000 + 1155313 libobjc.A.dylib 0x3a1d83a5 0x3a1ce000 + 4189314 UIKit 0x322a6853 0x32263000 + 27656315 libobjc.A.dylib 0x3a1e0b67 0x3a1ce000 + 7664716 CoreFoundation 0x2f96f181 0x2f96a000 + 2086517 QuartzCore 0x31ee9339 0x31ede000 + 4588118 QuartzCore 0x31eee7c3 0x31ede000 + 6752319 libobjc.A.dylib 0x3a1e0b67 0x3a1ce000 + 7664720 CoreFoundation 0x2f96f181 0x2f96a000 + 2086521 QuartzCore 0x31ef0e0d 0x31ede000 + 7732522 libdispatch.dylib 0x3a6bad3d 0x3a6ba000 + 338923 libdispatch.dylib 0x3a6bd6bf 0x3a6ba000 + 1401524 CoreFoundation 0x2fa0967d 0x2f96a000 + 65292525 CoreFoundation 0x2fa07f49 0x2f96a000 + 64698526 CoreFoundation 0x2f972765 0x2f96a000 + 3466127 CoreFoundation 0x2f972547 0x2f96a000 + 3411928 GraphicsServices 0x348cf6cf 0x348c6000 + 3860729 UIKit 0x322d188d 0x32263000 + 45274930 XiaoYu 0x00233c75 0x10000 + 224370131 libdyld.dylib 0x3a6cfab5 0x3a6ce000 + 6837Thread 1:Thread 0 crashed with ARM Thread State (32-bit): r0: 0x00000000 r1: 0x00000000 r2: 0x00000000 r3: 0x00002060 r4: 0x00000006 r5: 0x3c42818c r6: 0x186e33b0 r7: 0x27df21b0 r8: 0x186e33b0 r9: 0x00000001 r10: 0x00000006 r11: 0x00000005 ip: 0x00000148 sp: 0x27df21a4 lr: 0x3a7ee7b7 pc: 0x3a7861f0 cpsr: 0x00000010Binary Images:","tags":[{"name":"iOS","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"iOS-MDM流程记录","date":"2014-01-08T01:56:00.000Z","path":"2014/01/08/iOS-MDM流程记录/","text":"MDM开发流程1.申请企业开发者账号，这一步比较麻烦的是申请邓白氏码，因为要通过华夏邓白氏那边的审核。拖了比较久。2.有开发者账号就可以做MDM证书了， 主要参考:mbaikesofthinker 这里要注意的是12//Change to your alias 是你证书的名字！String alias = \"MbaikeMDMCSR\"; mdm证书制作1.用apple钥匙串访问工具生成CertificateSigningRequest.certSigningRequest2.利用生成的公私钥中的私钥导出为vendor.p122.登陆299企业帐号创建并下载mdm.cer4.下载AppleWWDRCA 证书5.下载AppleIncRootCertificate 苹果根证书6.利用以下命令将cer证书转成证pem书123openssl x509 -inform der -in mdm.cer -out mdm.pemopenssl x509 -inform der -in AppleWWDRCA.cer -out intermediate.pemopenssl x509 -inform der -in AppleIncRootCertificate.cer -out root.pem 7.生成客户端证书123openssl genrsa -des3 -out customerPrivateKey.pem 2048openssl req -new -key customerPrivateKey.pem -out customer.csropenssl req -inform pem -outform der -in customer.csr -out customer.der 8.利用MDMIOSGenerateEncodedPlist.java生成plist.xml和plist_encoded9.打开 https://identity.apple.com/pushcert/ 登陆任意appleid帐号，上传plist_encoded文件，申请通过后，下载apns-mdm.pem证书10.将apns-mdm.pem与customerPrivateKey.pem合并为apns-mdm.p121openssl pkcs12 -export -inkeycustomerPrivateKey.pem -in apns-mdm.pem -out apns-mdm.p12 此apns-mdm.p12就是mdm服务器和苹果anps服务器通讯用的p12也是mobileconf中绑定的p12(mobileconf最终安装在移动设备上) MDMplist 3.申请服务器所需证书 4.部署https(SSL)服务器环境 最好做下域名映射！ 5.配置描述文件mobileconfig的生成 下载iPhone配置实用工具，配置通用和移动设备管理注意：a：Topic must be com.apple.mgmt. b：通用的安全性为总是 c：移动设备管理中的使用开发APNS服务器不能勾选 主要参考：(http://www.mbaike.net/ios/1560.html) 导出（选“无”）后签名 1openssl smime -sign -in unsigned.mobileconfig -out signed.mobileconfig -signer mbaike.crt -inkey mbaike.key -certfile ca-bundle.pem -outform der -nodetach","tags":[{"name":"iOS MDM","slug":"ios-mdm","permalink":"http://yoursite.com/tags/ios-mdm/"}]},{"title":"Lua内存管理","date":"2011-07-04T07:55:00.000Z","path":"2011/07/04/Lua内存管理/","text":"本文主要介绍某项目脚本(lua)部分内存泄漏的查证与处理过程，希望对大家有点帮助。需要说明的是，lua本身并不存在真正的内存泄漏，只是因为使用上面的原因导致无法gc，从而导致逻辑上的泄漏:)。 参考GCObject的声明可以发现，lua中的复杂数据类型变量的传递都是基于引用的。当lua从根开始gc扫描的时候，只要还有一个地方有对此变量的引用，那么这个变量就不会被collect。这种情况造成的危害取决于多大程度上依赖于引用，如果有适当的间接层/弱引用来隔离这个问题，可能问题会有所缓解。 以下是一些常见的错误引用情景: 1.本应该local 的变量进入global空间或者module空间了(忘记写local)，如果这是一个table/function/udata等类型的变量的话，非常不幸的，这个变量将不会被正确gc了 —-除非你再显式的释放。这是非常容易犯的错误，一直在想为什么lua变量不是默认local呢？ 当然这个话题会引发另外一场争论。 1234local function test_user(id) userobj = get_user_by_id(id) --这里总是会有一个玩家对象泄漏 print(\"only test\", userobj:get_name())end 2.c/c++部分调用的lua_ref是否有正常lua_unref释放？ 通过debug.getregistry()可以查到这些ref. 3.其他各种各样的实际bug造成的泄漏。 当怀疑系统有泄漏以后，我们可以怎么查到这些泄漏呢？我强烈建议大家建立一个weak table, 把你所有创建过的能够称之为资源的，包含但不限于“战斗对象，玩家，npc，物品，场景，邮件”等等对象全部扔到这个table里面。当你知道玩家已经下线、战斗已经销毁了，但通过连续的强制full gc以后weak table里面还有这个变量，这就证明了这个变量的引用没有被完全释放，于是问题就被发现了，我们又有事情干了@_@。 知道有泄漏是比较容易的，能够完全揪出来就不是很容易了。是的，它究竟在哪儿呢? 一开始在此项目里面也是先发现比如某npc泄漏了，然后就去查代码，看看究竟哪个地方写得不对。这种方式效率极低，基本上查不到什么问题。在迟一点的时候才使用现在的方案：从_G深度遍历所有的table、metatable、funciton’supvalue、function’s env、registentry(lua_ref)。 目前所知的所有引用必定存在于这几个空间， 遍历完成以后一定可以找到那个“迷失了的引用”。 这种方式在脚本层就可以完成所有事情，甚至你可以在运营环境中在线查证，其遍历的速度是非常快的，但内存开销非常大(:，可以考虑一边遍历一边gc，当然还要记得避免重复搜索。 在应用此方案以后，此项目解决了脚本中所有的泄漏问题。 一点总结：1.如果系统性能还能够承受的话，建议不要直接引用对象，可以多做一层间接层。2.lua里面的弱引用是非常有用的。3.比较大的物理内存是必要的，这可以为大家查证问题争取足够多的时间:) 4.可以把查找泄漏的部分写入到关机逻辑里面，每次关机的时候自动查找泄漏，然后出具报告。","tags":[{"name":"Lua","slug":"lua","permalink":"http://yoursite.com/tags/lua/"}]}]