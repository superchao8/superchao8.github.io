[{"title":"工匠精神","date":"2017-02-21T07:19:09.000Z","path":"2017/02/21/工匠精神/","text":"今天早上在上班的路上，听到广播在说日本秋山木工的【工匠精神】。 工匠精神的内涵：精益求精、追求卓越 中国古代圣人孔子就发表过言论 《诗》云：“如切如磋，如琢如磨。” 孔子《论语·学而》 “言治骨角者，既切之而复磋之；治玉石者，既琢之而复磨之，治之已精，而益求其精也。” 朱熹 意思是精雕细琢，精益求精的理念。 从某种意义上说，编程也是一门手艺活，数量的码工编写的代码鲁棒性强，效率高，细节好。一流的人才是技艺和态度的双重修炼。精湛的技艺背后总是有对技术的敬畏、和感情。善于思考和领悟。 程序开发中，码工也应该学习这种精神。追求程序之美，代码之美。从优秀到卓越！","tags":[{"name":"管理","slug":"管理","permalink":"http://yoursite.com/tags/管理/"}]},{"title":"Objective-C id as Swift Any","date":"2017-02-09T06:29:00.000Z","path":"2017/02/09/objective-c-id-as-swift-any/","text":"Swift3 接口和Objective-C 的APIs比之前的版本更强大。例如，Swift 2将Objective-C中的id类型映射到Swift中的AnyObject类型，通常只能保存值类型。 Swift 2还为AnyObject提供了对一些桥接值类型（例如String，Array，Dictionary，Set和一些数字）的隐式转换，以便原生Swift类型可以很容易地使用Cocoa APIs，如NSString，NSArray或Foundation的其他容器类。这些转换与语言的其他部分不一致，使得很难理解什么可以用作AnyObject，结果是bugs。 在Swift 3中，Objective-C中的id类型现在映射到Swift中的Any类型，它描述了任何类型的值，无论是类，枚举，结构还是任何其他Swift类型。这种变化使得Swift中的Objective-C APIs更加灵活，因为Swift定义的值类型可以传递给Objective-C API，并作为Swift类型返回，从而无需手动“box”类型。这些优点也扩展到集合：Objective-C集合类型NSArray，NSDictionary和NSSet，以前只接受AnyObject的元素，现在可以保存Any类型的元素。对于散列容器，例如Dictionary和Set，有一个新类型AnyHashable可以容纳任何类型的值遵循Swift Hashable协议。总之，从Swift 2到Swift 3以下类型映射更改为： Objective-C Swift2 Swift3 id AnyObject Any NSArray * [AnyObject] [Any] NSDictionary * [NSObject: AnyObject] [AnyHashable: Any] NSSet * Set Set 在许多情况下，您的代码不必为响应此更改而显着地更改。 Swift 2中的代码依赖于隐式转换为AnyObject的值类型，它将继续按照Any的原样在Swift 3中工作。但是，有些地方需要更改声明的变量和方法类型，并获得Swift 3的最佳体验。另外，如果你的代码显式使用AnyObject或Cocoa类，如NSString，NSArray或NSDictionary，你将需要引入更多的显式转换使用as NSString或as String，因为在Swift 3中对象和值类型之间的隐式转换不再允许。Xcode中的自动迁移器将进行最小的更改，以保持您的代码从Swift 2到3编译，但结果可能不总是最优雅的。本文将介绍您可能需要做的一些更改，以及在更改代码以充分利用id为Any时需要注意的一些陷阱。 覆盖方法和遵循协议当子类化一个Objective-C类并覆盖它的方法，或者遵循一个Objective-C协议，当父方法在Objective-C中使用id时，需要更新方法的类型。一些常见的例子是NSObject类的isEqual：方法和NSCopying协议的copyWithZone：方法。在Swift 2中，你将写一个遵循NSCopying的NSObject子类，如下所示： 12345// Swift 2class Foo: NSObject, NSCopying &#123; override func isEqual(_ x: AnyObject?) -&gt; Bool &#123; ... &#125; func copyWithZone(_ zone: NSZone?) -&gt; AnyObject &#123; ... &#125;&#125; 在Swift 3中，除了将命名从copyWithZone（_ :)更改为copy（with :)之外，还需要将这些方法的签名更改为Any而不是AnyObject： 12345// Swift 3class Foo: NSObject, NSCopying &#123; override func isEqual(_ x: Any?) -&gt; Bool &#123; ... &#125; func copy(with zone: NSZone?) -&gt; Any &#123; ... &#125;&#125; 非类型集合属性列表，JSON和用户信息字典在Cocoa中很常见，Cocoa本地将这些表示为非类型化集合。在Swift 2中，为此需要构建Array，Dictionary或Set with AnyObject或NSObject元素，依靠隐式桥接转换来处理值类型： 12345678910111213141516171819202122// Swift 2struct State &#123; var name: String var abbreviation: String var population: Int var asPropertyList: [NSObject: AnyObject] &#123; var result: [NSObject: AnyObject] = [:] // Implicit conversions turn String into NSString here… result[\"name\"] = self.name result[\"abbreviation\"] = self.abbreviation // …and Int into NSNumber here. result[\"population\"] = self.population return result &#125;&#125;let california = State(name: \"California\", abbreviation: \"CA\", population: 39_000_000)NSNotification(name: \"foo\", object: nil, userInfo: california.asPropertyList) 或者，您可以使用Cocoa容器类，例如NSDictionary： 12345678910111213141516171819202122// Swift 2struct State &#123; var name: String var abbreviation: String var population: Int var asPropertyList: NSDictionary &#123; var result = NSMutableDictionary() // Implicit conversions turn String into NSString here… result[\"name\"] = self.name result[\"abbreviation\"] = self.abbreviation // …and Int into NSNumber here. result[\"population\"] = self.population return result.copy() &#125;&#125;let california = State(name: \"California\", abbreviation: \"CA\", population: 39_000_000)// NSDictionary then implicitly converts to [NSObject: AnyObject] here.NSNotification(name: \"foo\", object: nil, userInfo: california.asPropertyList) 在Swift 3中，隐式转换已经消失，因此上述两个片段都不会按原样工作。迁移者可能建议用as单独转换每个值，以保持此代码的工作，但有一个更好的解决方案。 Swift现在导入Cocoa API接受Any和/或AnyHashable的集合，所以我们可以更改集合类型为[AnyHashable：Any]替换[NSObject：AnyObject]或NSDictionary，而不更改任何其他代码： 1234567891011121314151617181920212223// Swift 3struct State &#123; var name: String var abbreviation: String var population: Int // Change the dictionary type to [AnyHashable: Any] here... var asPropertyList: [AnyHashable: Any] &#123; var result: [AnyHashable: Any] = [:] // No implicit conversions necessary, since String and Int are subtypes // of Any and AnyHashable result[\"name\"] = self.name result[\"abbreviation\"] = self.abbreviation result[\"population\"] = self.population return result &#125;&#125;let california = State(name: \"California\", abbreviation: \"CA\", population: 39_000_000)// ...and you can still use it with Cocoa API hereNotification(name: \"foo\", object: nil, userInfo: california.asPropertyList) AnyHashable类型Swift的Any类型可以保存任何类型，但是Dictionary和Set需要的键是Hashable，所以Any是太普通。从Swift 3开始，Swift标准库提供了一个新的类型AnyHashable。与Any类似，它充当所有Hashable类型的父类型，因此String，Int和其他hashable类型的值可以隐式地用AnyHashable值，AnyHashable中的类型可以使用is，as!或as?动态检查，动态转换运算符。当从Objective-C导入无类型的NSDictionary或NSSet对象时，使用AnyHashable，但是在纯Swift中也可用于构建异构集合或字典。 未链接上下文的显式转换在某些有限的情况下，Swift不能自动桥接C和Objective-C构造。例如，一些C和Cocoa API使用id * 指针作为“out”或“in-out”参数，并且由于Swift不能静态地确定指针的使用方式，因此它不能对内存中的值自动执行桥接转换。在这种情况下，指针仍将显示为UnsafePointer 。如果您需要使用这些非桥接API，您可以使用显式桥接转换，在代码中使用as Type或as AnyObject显式编写。 1234567// ObjC@interface Foo- (void)updateString:(NSString *)string;- (void)updateObject:(id *)obj;@end 123456789101112// Swiftfunc interactWith(foo: Foo) -&gt; (String, Any) &#123; var string = \"string\" as NSString // explicit conversion foo.updateString(&amp;string) // parameter imports as UnsafeMutablePointer&lt;NSString&gt; let finishedString = string as String var object = \"string\" as AnyObject foo.updateObject(&amp;object) // parameter imports as UnsafeMutablePointer&lt;AnyObject&gt; let finishedObject = object as Any return (finishedString, finishedObject)&#125; 另外，Objective-C协议在Swift中仍然是类约束，所以你不能让Swift结构或枚举直接遵循Objective-C协议或者使用轻量级通用类。您需要使用这些协议和API显式转换String as NSString，Array as NSArray等。 AnyObject成员查找Any没有与AnyObject相同的魔法方法查找行为。这可能会破坏一些Swift 2代码，查找属性或发送消息到一个无类型的Objective-C对象。例如，这个Swift 2的代码： 12345// Swift 2func foo(x: NSArray) &#123; // Invokes -description by magic AnyObject lookup print(x[0].description)&#125; 将抱怨description不是Swift 3中Any的成员。可以将x [0] as AnyObject以获取动态行为： 12345// Swift 3func foo(x: NSArray) &#123; // Result of subscript is now Any, needs to be coerced to get method lookup print((x[0] as AnyObject).description)&#125; 或者，将值强制转换为您期望的具体对象类型： 1234func foo(x: NSArray) &#123; // Cast to the concrete object type you expect print((x[0] as! NSObject).description)&#125; Swift中的值类型Any可以hold住任何结构，枚举，元组或你可以在语言中定义的其他Swift类型。 Swift 3中的Objective-C桥接器可以提供任何Swift值作为Objective-C的id兼容对象。这使得更容易在Cocoa容器，userInfo字典和其他对象中存储自定义Swift值类型。例如，在Swift 2中，您需要将数据类型更改为类，或者手动box它们，以将它们的值附加到NSNotification： 1234567891011121314151617// Swift 2struct CreditCard &#123; number: UInt64, expiration: NSDate &#125;let PaymentMade = \"PaymentMade\"// We can't attach CreditCard directly to the notification, since it// isn't a class, and doesn't bridge.// Wrap it in a Box class.class Box&lt;T&gt; &#123; let value: T init(value: T) &#123; self.value = value &#125;&#125;let paymentNotification = NSNotification(name: PaymentMade, object: Box(value: CreditCard(number: 1234_0000_0000_0000, expiration: NSDate()))) 使用Swift 3，我们可以取消box，并将对象直接附加到Notification： 12345678// Swift 3let PaymentMade = Notification.Name(\"PaymentMade\")// We can associate the CreditCard value directly with the Notificationlet paymentNotification = Notification(name: PaymentMade, object: CreditCard(number: 1234_0000_0000_0000, expiration: Date())) 在Objective-C中，CreditCard值将作为一个id兼容的，继承NSObject对象实现isEqual：，hash和description，如果它们存在原生的Swift类型的话，使用Swift的Equatable，Hashable和CustomStringConvertible。从Swift中，可以通过将其动态地转换回其原始类型来检索该值： 123// Swift 3let paymentCard = paymentNotification.object as! CreditCardprint(paymentCard.number) // 1234000000000000 请注意，在Swift 3.0中，一些常见的Swift和Objective-C结构类型将桥接为不透明对象，而不是惯用的Cocoa对象。例如，Int，UInt，Double和Bool桥接到NSNumber，其他大小的数字类型，例如Int8，UInt16等只桥接为不透明对象。可变结构如CGRect，CGPoint和CGSize也作为不透明对象桥接，即使大多数Cocoa API期望它们一起作为对象在NSValue实例中被box。如果你看到unrecognized selector sent to _SwiftValue错误，这表明Objective-C代码试图调用一个不透明的Swift值类型的方法，你可能需要手动box该类的实例中Objective-C代码期望的值。 要注意的一个特殊问题是Optionals。 Swift Any可以代表任何东西，包括一个Optional，所以可以在不首先检查它情况下将一个包装的Optional传递给Objective-C API，即使API被声明为一个nonnull id类型。这通常表现为包括_SwiftValue的运行时错误，而不是编译时错误。 Xcode 8.1 beta中包含的Swift 3.0.1通过实现这些建议来透明地处理数字类型，Objective-C结构和可选类型，以解决NSNumber，NSValue和Optional桥接中的上述限制： SE–0139: Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue SE–0140: Warn when Optional converts to Any, and bridge Optional As Its Payload Or NSNull 为了避免向前兼容性问题，你不应该依赖_SwiftValue类的不透明对象的实现细节，因为未来版本的Swift可能允许更多的Swift类型桥接到惯用的Objective-C类。 Linux可移植性在Linux上使用Swift Core 运行的Swift程序库使用了原生Swift中编写的一个Foundation版本，没有Objective-C运行时桥接。 id-as-Any允许Core Libraries直接使用原生Swift Any和标准库值类型，同时使用Objective-C Foundation实现保持与Apple平台上的代码兼容。由于Swift在Linux上不与Objective-C交互操作，因此不支持桥接转换，例如string as NSString或value as AnyObject。希望在Cocoa和Swift Core Libraries之间移植的Swift代码应该只使用值类型。 学习更多id-as-Any是Swift语言改进的一个很好的例子，受到用户对早期版本的Swift的反馈的启发，并通过来自开放的Swift Evolution过程的回顾完善。如果你想更多地了解id-as-Any背后的动机和设计决策，原始的Swift Evolution提议可以在GitHub的swift-evolution仓库中找到： SE-0072：完全消除来自Swift的隐式桥接转换 SE-0116：将Objective-C **id**导入为Swift**Any**类型 SE-0131：将AnyHashable添加到标准库 最终结果是，Swift是一种更加一致的语言，当使用Swift时，Cocoa API变得更强大。","tags":[]},{"title":"共享单车","date":"2016-12-25T09:52:09.000Z","path":"2016/12/25/共享单车/","text":"进来厦门的大街小巷出现了小黄车，小白车等各种共享单车。这让人想起了上个世纪的黄包车，城市中大街小巷中穿梭。。。 时代变迁，黄车重现江湖，共享经济炙手可热。移动互联网激烈角逐各领域的最后一公里。 横尸片野的小黄车也让人忧心，维修起来也是个大难题。但听说投资机构都排队上门，不担心资金问题","tags":[{"name":"新鲜事","slug":"新鲜事","permalink":"http://yoursite.com/tags/新鲜事/"}]},{"title":"Unit Testing","date":"2016-12-21T09:58:16.000Z","path":"2016/12/21/unit-testing/","text":"12341.Testing Framework Review2.High-level Overview3.Time to Testing4.What’s new?(Asynchronous Testing, Performance Testing) 12345Xcode’s testing frameworks Xcode5: OCUnit -&gt; XCTestXcode5.1: OCUnit Xcode6: new XCTest API 12test class name end with Tests.(e:ViewModelTests)test case methods must start with the word test so that the test runner can find them.(e:testInitialization) 12345XCTestCaseThe default XCTestCase class contains a setup() and a tearDown() method.For every test function, the test runner calls setup() and tearDown()Override these methods to perform any necessary configuration of your object before the test runs, and any cleanup after. 1234567891011121314151617181920AssertionsXCTFail(format…) 生成一个失败的测试； XCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过； XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；XCTAssert(expression, format...)当expression求值为TRUE时通过； XCTAssertTrue(expression, format...)当expression求值为TRUE时通过； XCTAssertFalse(expression, format...)当expression求值为False时通过； XCTAssertEqualObjects(a1, a2, format...)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；XCTAssertNotEqualObjects(a1, a2, format...)判断不等，[a1 isEqual:a2]值为False时通过；XCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）； XCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试； XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试； XCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过； XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过 123456Asynchronous TestingPerformance TestingmeasureBlock: which takes a block of code and measures the execution time of the entire block.measureMetrics: is a more intimate version of measureBlock that offers fine grained control of what to measure,and when to measure it. 12345678910How Xcode decides to mark a performance test as success or failure, here’s the logicFor convenience AVE means average,STDDEV means standard deviation:1. If the test has no baseline, the result is neither a success nor a failure.2. If the current run’s STDDEV minus the baseline STDDEV took less than 0.1 second, ignore it.3. If the current run&apos;s STDDEV minus the baseline STDDEV took more than 0.1 second and the difference is more than 10%, it’s a failure.4. If the current run’s AVE minus the baseline AVE took less than 0.1 second, ignore it.5. If the current run’s AVE minus the baseline AVE took more than 0.1 second and the difference is more than 10%, it’s a failure.6. Everything else is considered a success.","tags":[]},{"title":"产品 产品","date":"2016-12-20T09:52:09.000Z","path":"2016/12/20/产品-产品/","text":"产品的迭代需要有计划，有策略的进行。就像下象棋一样，承前启后，打出组合拳。才能达到目标。","tags":[{"name":"迭代","slug":"迭代","permalink":"http://yoursite.com/tags/迭代/"}]},{"title":"Swift-Objective-C到底哪家强","date":"2016-08-22T07:44:42.000Z","path":"2016/08/22/Swift-Objective-C到底哪家强/","text":"swift出世后，人们茶余饭后就会讨论Swift和OC到底哪家强？Swift好用吗？下面主要从用法和性能方面来讨论。 语法 毫无疑问，从第一眼看到Swift。就看到了它的简洁，语法更清楚，更容易被理解。这要归结于Swift的设计，它借鉴了很多语言（C、JavaScript、Python、Java）的优点，特别是动态语言。让你写起来更简单有趣。同时，Swift也提供了面向对象编程。 性能 测试平台：MacMini 2.6 GHz Intel Core i5， Xcode8.2，Swift3.0 循环循环一百万次，里面什么事也不做 swift 12345678910111213let oneMillion = 1000000let startTimes = NSDate().timeIntervalSince1970 * 1000func loop() &#123; for _ in 1...oneMillion &#123; &#125;&#125;loop()let endTimes = NSDate().timeIntervalSince1970 * 1000let usedTimes = endTimes - startTimesprint(\"loop a million times used \\(usedTimes) ms\") OC 12345678910int oneMillion = 1000000;NSTimeInterval startTimes = [[NSDate date] timeIntervalSince1970] * 1000;for (NSUInteger i = 0; i &lt; oneMillion; i++)&#123;&#125;NSTimeInterval endTimes = [[NSDate date] timeIntervalSince1970] * 1000;NSTimeInterval usedTimes = endTimes - startTimes;printf(\"used times %f ms\", usedTimes); 用时（运行十次取平均值）Swift： 3.62075195ms（3.333984375, 3.486083984375, 5.197998046875, 3.31982421875, 3.321044921875,3.31982421875, 3.338134765625, 4.220947265625, 3.32177734375, 3.347900390625,）Objective-C：2.4488037ms (2.345947, 2.363037, 2.292725, 2.596924, 2.352051,2.587158, 2.348145, 2.649902, 2.412109, 2.540039,) 快速排序 快速排序就取10k个数，分为三种情况（正常，倒序，均值） 正常swift 123456789101112131415161718192021222324252627let count = 10000let arr = Array(1...count)let startTimes = NSDate().timeIntervalSince1970 * 1000// *** Simple but inefficient version of quicksort ***func quicksort&lt;T: Comparable&gt;(_ a: [T]) -&gt; [T] &#123; guard a.count &gt; 1 else &#123; return a &#125; let pivot = a[a.count/2] let less = a.filter &#123; $0 &lt; pivot &#125; let equal = a.filter &#123; $0 == pivot &#125; let greater = a.filter &#123; $0 &gt; pivot &#125; // Uncomment this following line to see in detail what the // pivot is in each step and how the subarrays are partitioned. //print(pivot, less, equal, greater) return quicksort(less) + equal + quicksort(greater) return quicksort(less) + equal + quicksort(greater)&#125;quicksort(arr)let endTimes = NSDate().timeIntervalSince1970 * 1000let usedTimes = endTimes - startTimesprint(\"times used \\(usedTimes) ms\") OC 12345678910111213141516NSUInteger cap = 10000;NSMutableArray *arr = [NSMutableArray arrayWithCapacity:cap];for (NSUInteger i = 0; i &lt; cap; i++) &#123; NSNumber *num = [NSNumber numberWithInteger:i]; arr[i] =num;&#125;NSTimeInterval startTimes = [[NSDate date] timeIntervalSince1970] * 1000;[self QuickSorkOC:arr Count:[arr count]];NSTimeInterval endTimes = [[NSDate date] timeIntervalSince1970] * 1000;NSTimeInterval usedTimes = endTimes - startTimes;printf(\"used times %f ms\", usedTimes); 用时（运行十次取平均值）Swift： 201.352221ms（226.079833984375, 180.364990234375, 182.054931640625, 195.965087890625, 197.198974609375,193.84375, 268.726806640625, 191.621826171875, 188.782958984375, 188.883056640625,）Objective-C：1551.05075ms (1497.709961, 1507.664062, 1505.760254, 1498.334961, 1578.202148,1499.712158, 1531.479736, 1492.811035, 1684.247070, 1714.586182) 倒序考虑最坏的情况，数据是从大到小的。只需要把数组倒序过来 swift 12var arr = Array(1...count)arr.sort(by: &gt;) OC 1arr = (NSMutableArray *)[[arr reverseObjectEnumerator] allObjects]; 用时（运行十次取平均值）Swift： 193.266601ms（184.419189453125, 255.409912109375, 189.22509765625, 198.416259765625, 190.2978515625,181.308837890625, 187.583984375, 184.344970703125, 183.385009765625, 178.27490234375,）Objective-C：1644.0257ms(1911.626709, 1546.142090, 1542.587158, 1929.552979, 1553.895020,1576.763672, 1586.454102, 1558.053955, 1548.708252, 1686.473145,) 均值swift 12let count = 10000var arr = Array(repeating: 0, count: count) OC 1234for (NSUInteger i = 0; i &lt; cap; i++) &#123; NSNumber *num = [NSNumber numberWithInteger:0]; arr[i] = num;&#125; 用时（运行十次取平均值）Swift： 16.3355224ms（13.64892578125, 21.63916015625, 15.175048828125, 21.05322265625, 17.60595703125,13.64111328125, 17.98193359375, 13.454833984375, 14.905029296875, 14.25, ）Objective-C： 10.8430176ms (18.000977, 10.387207, 10.093994, 10.768066, 9.725098,10.739014, 10.843018, 12.367188, 16.007812, 10.340820, ) 内存管理 Swift也是采用了自动引用计数（ARC）来管理内存，这样可以是程序员专注于核心的应用逻辑以及新的功能特性上。把内存管理交给编译器去做。但值得注意的是，要避免循环引用造成的内存泄漏。 安全 用OC的时候，比较经常遇到的崩溃是空指针（nil、null）和数组越界。在OC中你对nil发送消息，是被允许的，它什么事情都不会发生。而这就是得看起来并不会崩溃，但其实它隐藏着一个巨大的bug。这种bug是随机的，并且很能复现。这就造成在修复的时候必须发大力气来寻找问题所在。 在Swift中提供了可选类型使得一个nil可选值的可能性变得非常的明确，这样你就很明白了。如果你不小心写了不明确的代码时编译器会报错。问题就在编写的时候就修复好了，这就大大节省了修复OC指针逻辑的bug时间。 维护 历史遗留下来的问题，使得OC不得不用两个文件。如果C没有改进的话，OC也就没办法跟着改变。在OC中，优化构建的时间以及创建App的效率就比不上Swift了。OC的两份文件系统就多了额外的工作，特别是在维护的时候，不得不来回的切换，幸好有快捷键，但也会觉得繁琐。 BTW：良好的编程规范是很重要的 好不好用？用了才知道，语言它只是个表现手法，编程思想才是最重要的。适合团队的开发工具，能够高效的工作才是首选！","tags":[{"name":"swift,","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"App-store转让App","date":"2015-08-22T07:44:42.000Z","path":"2015/08/22/App-store转让App/","text":"有时候需要转让App到别的账号下，需要注意的是只有符合条件的App才能转让。由于App store里面应用名字的唯一性，当你新建了应用还没来得急上传，想把它过度到另外账号下只能等第一个版本审核通过后才能操作。 符合条件的才行 填写账号 Team ID在这 同意就行 登录另一个账号 填写信息，接收就可以了。应用马上就过来了，但App store上的信息还要等apple 服务器同步才行。","tags":[{"name":"iTunesconnect,","slug":"itunesconnect","permalink":"http://yoursite.com/tags/itunesconnect/"}]},{"title":"Cornerstone ignore UserInterfaceState.xcuserstate","date":"2014-11-21T09:18:44.000Z","path":"2014/11/21/Cornerstone-ignore-UserInterfaceState.xcuserstate/","text":"在控制台 cd 到项目目录下svn -v status 查看文件的状态(M): M 33769 33757 xxx XXX.xcworkspace/xcuserdata/XXX.xcuserdatad/UserInterfaceState.xcuserstate svn delete --keep-local --force xcuserdata/user.xcuserdatad/UserInterfaceState.xcuserstate 此时，Cornerstone会显示它的状态为”？”,右键Ignore。解决了，世界清静了:] PS:added .xcuserstate to the Global Ignores (Cornerstone -&gt; Preferences -&gt; Subversion -&gt; turn off Use default global ignores -&gt; add “\\.xcuserstate”)","tags":[{"name":"xcode","slug":"xcode","permalink":"http://yoursite.com/tags/xcode/"},{"name":"svn","slug":"svn","permalink":"http://yoursite.com/tags/svn/"},{"name":"tutorial","slug":"tutorial","permalink":"http://yoursite.com/tags/tutorial/"}]},{"title":"Swift笔记","date":"2014-08-22T07:44:42.000Z","path":"2014/08/22/swift笔记/","text":"swift出世时，断断续续看了一些。在PlayGround耍了耍还是挺好玩的:]有OC作为基础，上手swift还是挺快的。但是有一些语法还是要留意下。这个就作为学习笔记吧，记录学习过程中的注意点。swift官网The Swift Programming Language if nil在OC中我们在判断一个值是不是nil时，一般就是123NSString *values = @\"\";if(values) &#123;&#125; 但在swift中，是会报错的12345var apple = \"apple\"if apple &#123; print(apple)&#125;//'String' is not convertible to 'Bool' Apple 在GuidedTour中写道：In an if statement, the conditional must be a Boolean expression—this means that code such as if score { … } is an error, not an implicit comparison to zero. You can use if and let together to work with values that might be missing. These values are represented as optionals. An optional value either contains a value or contains nil to indicate that a value is missing. Write a question mark (?) after the type of a value to mark the value as optional. 正确的写法12345678var optionalString: String? = nilprint(optionalString == nil)if let str = optionalString &#123; print(str)&#125; else &#123; print(\"optionalString is nil\")&#125; 这样写也可以123456789var optionalString: String? = \"janes\"print(optionalString == nil)let isBool = (optionalString == nil)if isBool &#123; print(\"optionalString is nil \\(isBool)\")&#125; else &#123; print(\"optionalString is not nil\")&#125; In-Out Parameters函数中的输入输出参数，可以改变函数参数。 12345678910func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125;var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\") 好奇的看下内存地址有没有改变123456789func address(o: UnsafeRawPointer) -&gt; String &#123; return String.init(format: \"%018p\", unsafeBitCast(o, to: Int.self))&#125;var someInt = 3var anotherInt = 107print(\"before swap:\\(address(o: &amp;someInt)), value:\\(someInt))\")swapTwoInts(&amp;someInt, &amp;anotherInt)print(\"after swap:\\(address(o: &amp;someInt)), value:\\(someInt)\") before swap:0x00007fff595d6ac0, value:3) after swap:0x00007fff595d6ac0, value:107 结果内存中的地址是没有变的 ###12let sortedNumbers = numbers.sort &#123; $0 &gt; $1 &#125;print(sortedNumbers) 12","tags":[{"name":"swift,","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"iOS Crash Log处理","date":"2014-06-24T06:02:36.000Z","path":"2014/06/24/ios-crash-log处理/","text":"iOS crash log 处理 什么是崩溃日志，从哪里能得它? iOS设备上的应用闪退时，操作系统会生成一个崩溃报告，也叫崩溃日志，保存在设备上。 1234Device LogsCrashReporter ~/Library/Logs/CrashReporter/MobileDevice/iTunes Connect -&gt; Crash Reports用户 什么情况下会产生崩溃日志? 两种主要情况会产生崩溃日志: 1. 应用违反操作系统规则。 2. 应用中有Bug。 Array.map12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Incident Identifier: CE5E9C4A-A13D-4734-8483-97D55825AB57CrashReporter Key: d3adfba37a68e78e6885adfe06034f2798cf0762Hardware Model: iPhone6,1Process: XiaoYu [447]Path: /var/mobile/Applications/20FA34C5-0EC1-4692-A89E-1DC7C818C013/XiaoYu.app/XiaoYuIdentifier: com.rt.FISH4iPhoneVersion: 3.0.0 (3.0.0)Code Type: ARM (Native)Parent Process: launchd [1]Date/Time: 2014-06-20 18:32:00.417 +0800OS Version: iOS 7.1.1 (11D201)Report Version: 104Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Triggered by Thread: 0Last Exception Backtrace:(0x2fa3ef0b 0x3a1d1ce7 0x2fa3ee4d 0x54af09 0x3a7e971b 0x3a7ee7b7 0x3a736ff9 0x3a7add25 0x3a1d83a9 0x322a6857 0x3a1e0b6b 0x2f96f185 0x31ee933d 0x31eee7c7 0x3a1e0b6b 0x2f96f185 0x31ef0e11 0x3a6bad3f 0x3a6bd6c3 0x2fa09681 0x2fa07f4d 0x2f972769 0x2f97254b 0x348cf6d3 0x322d1891 0x233c79 0x3a6cfab7)Thread 0 Crashed:Last Exception Backtrace:(0x2fa3ef0b 0x3a1d1ce7 0x2fa3ee4d 0x54af09 0x3a7e971b 0x3a7ee7b7 0x3a736ff9 0x3a7add25 0x3a1d83a9 0x322a6857 0x3a1e0b6b 0x2f96f185 0x31ee933d 0x31eee7c7 0x3a1e0b6b 0x2f96f185 0x31ef0e11 0x3a6bad3f 0x3a6bd6c3 0x2fa09681 0x2fa07f4d 0x2f972769 0x2f97254b 0x348cf6d3 0x322d1891 0x233c79 0x3a6cfab7)Thread 0 Crashed:0 libsystem_kernel.dylib 0x3a7861f0 0x3a773000 + 783201 libsystem_pthread.dylib 0x3a7ee7b3 0x3a7eb000 + 142592 libsystem_c.dylib 0x3a736ff5 0x3a6ed000 + 3030933 libc++abi.dylib 0x39b8598b 0x39b85000 + 24434 libc++abi.dylib 0x39b9c1f5 0x39b85000 + 947095 libc++abi.dylib 0x39b9ba05 0x39b85000 + 926776 libobjc.A.dylib 0x3a1d1db7 0x3a1ce000 + 157997 CoreFoundation 0x2fa3ee49 0x2f96a000 + 8720098 XiaoYu 0x0054af05 0x10000 + 54842939 libsystem_platform.dylib 0x3a7e9719 0x3a7e6000 + 1410510 libsystem_pthread.dylib 0x3a7ee7b3 0x3a7eb000 + 1425911 libsystem_c.dylib 0x3a736ff5 0x3a6ed000 + 30309312 libsystem_malloc.dylib 0x3a7add21 0x3a7ab000 + 1155313 libobjc.A.dylib 0x3a1d83a5 0x3a1ce000 + 4189314 UIKit 0x322a6853 0x32263000 + 27656315 libobjc.A.dylib 0x3a1e0b67 0x3a1ce000 + 7664716 CoreFoundation 0x2f96f181 0x2f96a000 + 2086517 QuartzCore 0x31ee9339 0x31ede000 + 4588118 QuartzCore 0x31eee7c3 0x31ede000 + 6752319 libobjc.A.dylib 0x3a1e0b67 0x3a1ce000 + 7664720 CoreFoundation 0x2f96f181 0x2f96a000 + 2086521 QuartzCore 0x31ef0e0d 0x31ede000 + 7732522 libdispatch.dylib 0x3a6bad3d 0x3a6ba000 + 338923 libdispatch.dylib 0x3a6bd6bf 0x3a6ba000 + 1401524 CoreFoundation 0x2fa0967d 0x2f96a000 + 65292525 CoreFoundation 0x2fa07f49 0x2f96a000 + 64698526 CoreFoundation 0x2f972765 0x2f96a000 + 3466127 CoreFoundation 0x2f972547 0x2f96a000 + 3411928 GraphicsServices 0x348cf6cf 0x348c6000 + 3860729 UIKit 0x322d188d 0x32263000 + 45274930 XiaoYu 0x00233c75 0x10000 + 224370131 libdyld.dylib 0x3a6cfab5 0x3a6ce000 + 6837Thread 1:Thread 0 crashed with ARM Thread State (32-bit): r0: 0x00000000 r1: 0x00000000 r2: 0x00000000 r3: 0x00002060 r4: 0x00000006 r5: 0x3c42818c r6: 0x186e33b0 r7: 0x27df21b0 r8: 0x186e33b0 r9: 0x00000001 r10: 0x00000006 r11: 0x00000005 ip: 0x00000148 sp: 0x27df21a4 lr: 0x3a7ee7b7 pc: 0x3a7861f0 cpsr: 0x00000010Binary Images:","tags":[{"name":"iOS","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"iOS-MDM流程记录","date":"2014-01-08T01:56:00.000Z","path":"2014/01/08/iOS-MDM流程记录/","text":"MDM开发流程1.申请企业开发者账号，这一步比较麻烦的是申请邓白氏码，因为要通过华夏邓白氏那边的审核。拖了比较久。2.有开发者账号就可以做MDM证书了， 主要参考:mbaikesofthinker 这里要注意的是12//Change to your alias 是你证书的名字！String alias = \"MbaikeMDMCSR\"; mdm证书制作1.用apple钥匙串访问工具生成CertificateSigningRequest.certSigningRequest2.利用生成的公私钥中的私钥导出为vendor.p122.登陆299企业帐号创建并下载mdm.cer4.下载AppleWWDRCA 证书5.下载AppleIncRootCertificate 苹果根证书6.利用以下命令将cer证书转成证pem书123openssl x509 -inform der -in mdm.cer -out mdm.pemopenssl x509 -inform der -in AppleWWDRCA.cer -out intermediate.pemopenssl x509 -inform der -in AppleIncRootCertificate.cer -out root.pem 7.生成客户端证书123openssl genrsa -des3 -out customerPrivateKey.pem 2048openssl req -new -key customerPrivateKey.pem -out customer.csropenssl req -inform pem -outform der -in customer.csr -out customer.der 8.利用MDMIOSGenerateEncodedPlist.java生成plist.xml和plist_encoded9.打开 https://identity.apple.com/pushcert/ 登陆任意appleid帐号，上传plist_encoded文件，申请通过后，下载apns-mdm.pem证书10.将apns-mdm.pem与customerPrivateKey.pem合并为apns-mdm.p121openssl pkcs12 -export -inkeycustomerPrivateKey.pem -in apns-mdm.pem -out apns-mdm.p12 此apns-mdm.p12就是mdm服务器和苹果anps服务器通讯用的p12也是mobileconf中绑定的p12(mobileconf最终安装在移动设备上) MDMplist 3.申请服务器所需证书 4.部署https(SSL)服务器环境 最好做下域名映射！ 5.配置描述文件mobileconfig的生成 下载iPhone配置实用工具，配置通用和移动设备管理注意：a：Topic must be com.apple.mgmt. b：通用的安全性为总是 c：移动设备管理中的使用开发APNS服务器不能勾选 主要参考：(http://www.mbaike.net/ios/1560.html) 导出（选“无”）后签名 1openssl smime -sign -in unsigned.mobileconfig -out signed.mobileconfig -signer mbaike.crt -inkey mbaike.key -certfile ca-bundle.pem -outform der -nodetach","tags":[{"name":"iOS MDM","slug":"ios-mdm","permalink":"http://yoursite.com/tags/ios-mdm/"}]},{"title":"打电话英语","date":"2013-09-28T11:38:11.000Z","path":"2013/09/28/打电话英语/","text":"Starting1.May I speak to Mr.Yang? 可以请杨先生听电话吗？2.Is Mark there? 马克在吗？（和该部门的人都很熟）3.(May I have) Extension 208, please. 请帮我接分机208.4.Is this the Marketing department? 这里是营销部门吗？（不确定是否找对部门）5.Hi, Mr.Yang. This is Jerry Chan, calling from ABC Company China. 嗨，杨先生。我是陈杰瑞，从中国的ABC公司打来的。6.Am I calling a good time? 现在打来合适啊？7.Is it good time? 现在讲话方便吗？8.Are you busy now? 你现在忙吗？9.Do you have time to talk to me now? 你现在有时间和我说话吗？10.Good morning. I’d like to make an appointment with Kevin Yang. 早上好，我想和杨凯文约个时间碰面。11.When is the best time to phone you? 什么时间打电话给你最好？12.Where shall we meet? 我们要在哪里见面呢？13.When is it convenient for you? 你什么时候方便见面？14.When would be a good time? 何时见面比较好？15.Are you free/available next Monday? 你下星期一有空吗？16.How about Thursday? 星期二如何？17.Would Monday suit you? 星期一你可以吗？18.Shall we say 2:30 then? 我们可以约两点半吗？19.Are you free on Wednesday? Say ten o’clock? 你星期三有空吗？十点钟可以吗？20.When would be convenient? 什么时候方便？21.I’m coming to China next week. Could you fix a time to meet? 我下周会到中国。你可以找个时间见面吗？22.Could we reschedule it? 我们可以改时间吗？23.When would be a good time we can call you for this? 何时打电话给你讨论这个较适当。 Requesting others24.Could you tell me when I could reach him? 可以告诉我什么时候可以找到他吗？25.Could you give me his cell phone number? 可以告诉我他的手机号码吗？26.Could I speak to someone else?(Is there someone I can speak to?) 我可以和其他人说话吗？27.Is Kevin’s secretary available? 凯文的秘书在吗？28.Could I speak to Kevin’s secretary? 我可以和凯文的秘书说话吗？29.It’s rather urgent. 我有紧急的事。Wrong number30.Sorry, I must have the wrong number. 抱歉，我一定是打错电话了。31.Oh, sorry for bothering/troubling you. 噢，很抱歉打扰您。32.What would be the right number to call please? 那么我应该打什么号？（同家公司，只是打错部门） Leaving message33.May I leave a message? 我可以留个话吗？34.My name is Kevin.K-E-V-I-N. And my number is 02112345678. 我是凯文，我的电话号码是35.Could you ask him to call me? 可以请他打电话给我吗？36.Can you ask him to call me as soon as possible? 可以请他尽快回电给我吗？37.He already has my telephone number. 他已经有我的电话号码。38.Will you tell him that I called? 能不能告诉他我打过电话？39.Let’s me give you my mobile number。 It’s . 给你我的手机号码，*40.No, thanks. It’s all right. I’ll call back later. 不用，谢谢。没关系。我会再打来。Ending41.See you then. 到时候见。42.Thank you. Goodbye. 谢谢，再见。43.Great. I’ll look forward to it. 太好了，我会很期待。 常用接电话英语Starting1.Hello. 喂。（O__O”…）2.Yes, speaking. 我是，请讲。3.Who’s calling please? 请问你是哪一位？4.This is Kevin Yang. Speaking. 我是杨凯文，请说。5.How can I help you? 有什么可以为你效劳？6.This is Kevin Yang. How may I help you? 我是杨凯文，有什么可以为你服务？ Warming responses7.Hi, Jim, How are you? 嘿，吉姆，你好吗？8.What can I do for you, Allen? 有什么我可以帮你的，艾伦？9.I’m fine, thanks, and you? 我很好，谢谢，你呢？ Wrong number10.Sorry, wrong number. 抱歉，拨错电话了。11.I’m sorry you have the wrong number. 抱歉，你可能拨错电话了。12.I’m afraid you have the wrong number. 你恐怖拨错电话了。 Hearing not well13.Can you hear me? 听得到吗？14.I can’t hear you. Could you speak up/louder? 我听不到，你可以再大声一点吗？15.Can you speak slowly? 可以请你说慢一点？16.Could you speak lower? 你可以说小声一点吗？（不常用，太大声就把话筒拿远一点好了。）17.Sorry, what was that again? 抱歉，你刚刚说什么？18.Could you repeat that, please? 请你可以再说一次吗？19.Pardon/Excuse me, could you repeat that again more slowly? 对不起，你可以再说一次且慢一点吗？20.Not very well. 听不太到。21.It’s a very bad connection. 线路不好。22.Something is wrong with this time. 电话线路有点问题。23.Something is wrong with the phone. 电话有点问题。Not available24.Do you mind if I call you back? 你介意我给你打过去吗？25.Call you in a minute/in a half hour, ok? 一会儿/半小时后回电给你，好吗？26.Sorry, I am in the meeting. Catch you later. 抱歉，我现在正在开会，待会再打电话给你。27.Talk to you later. 待会再聊。28.May I put you on hold? 你可以稍等一下吗？29.Yes, I’ll get back to you as soon as I can. 是的，我会尽快回电话给你。 Further contact30.I’m not quite sure about that. Can I call you back in few minutes? 我不是很确定，我可以几分钟后再打给你吗？31.I’ll give you a call. 我会打电话给你。32.I must go now. 我得挂电话了。33.Let me check that out. Then I will call you back. 让我确认一下。然后我再回电话给你。 Confirmation34.Let e check my schedule. 让我确认一下我的时间表。35.That day is fine with me. 那天我可以。36.Let’s shoot for on Monday morning. 那么我们就暂定星期一早上。37.See you on Thursday at three-thirty then. 星期二下午3点半见。38.Cood. So that’s Wednesday at ten then. 好，那么就星期三10点钟见。 Ending Thanks for calling. Bye. 谢谢你打电话来。再见。40.Nice talking to you. Bye. 很高兴和你谈话，再见。41.Have a nice day! 祝你有个愉快的一天！常用代接电话英语Starting1.Hold on,please.(one moment,please) (Just a moment,please) 请稍候。2.I’ll put you though. 我帮你接过去。3.Can I help you? 有什么可以效劳的？4.May I have your name? 请问你叫什么名字？ Not available5.He is not in right now./ He is not here right now. 他不在。6.He has visitors right now. 他有客人。7.He is away from his desk now. 他不在座位上。8.Mr.Yang is on line one. 杨先生正在接另一个电话。9.Her line is busy now. 她现在正在打电话。10.He is in a meeting right now. 他现在正在开会。11.He is off today./He is day off. 他今天休假。12.He is out to lunch. 他出去吃午餐了。13.He’s not in office today. 他今天不在办公室。14.Is there anything I can help you with? 有设么我可以帮你吗？15.It’s always engaged.(it’s busy all the time.) 有什么我可以帮你吗？16.The line’s engaged. Will you hold? 电话占线。你要等吗？17.I’m afraid the line’s still busy. Do you still want to wait? 很抱歉电话还是占线，你想等吗？18.I’m sorry to have kept you waiting. 很抱歉让你久等。19.Mark is on a business trip abroad and will return to China in one week. 马克到国外出差，大约一星期才会回中国。 Transferring20.Would you like me to put you through to Kevin’s secretary? 你要我把电话转给凯文的秘书吗？21.I’m transferring your call to the Sales department. 我把电话转给销售部门。22.Would you like to speak to his colleague? 你想和他的同事说话吗？23.Would you like me to put you through to someone else? 你想请别人来接听吗？ Further contact24.Could you call back later? 你可以待会再打来吗？25.Can I have a message? 我可以留个口信吗？26.Would you like to leave a message? 你想要留个口信吗？27.Your number, please.你告诉我你的电话号码。28.Is that correct? 那样正确吗？29.Could you spell that please? 你可以拼给我听吗？30.How do you spell your name? 请问你的名字怎么样？31.Could you repeat your name and number? 你可以再说一次你的姓名及电话吗？32.Please leave your contact information. Then I will pass it on for you. 请你留下联络信息，我会为你转达。33.Does he have your phone number? 他有你的电话号码吗？34.Would you ask him to call you? 你要他回电话吗？","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"英文面试","date":"2013-09-27T11:18:29.000Z","path":"2013/09/27/英文面试/","text":"面试时描述个人特质的正面说法1.I am a self-motivated hard worker. 我是一个自我激励、工作认真的人。2.I work well under pressure. 我在压力之下，仍然可以很好地工作。3.I am knowledgeable and levelheaded. 我知识广泛且很冷静。4.I work well with all types of people. 我可以和各式各样的人相处得很好。5.I am good with people. 我的人际关系很好。6.I’m very easygoing. 我很随和。7.I’m a dependable hard worker. 我是个可靠又认真的员工。8.I am intelligent and driven. 我既聪明又上进。9.I am a quick/fast learner. 我的学习能力很强。10.I’m very honest and I have strong sense of responsibility. 我很坦诚且富有责任感。11.I get very serious and cautious when I work. 我在工作时很认真且小心谨慎。12.I’m a curious person and like to learn new things. 我是充满好奇心且喜欢学习新事物的人。13.I’m interested in learning new things very much. 我对于学习新的事物感到很有兴。14.I am a man with self-confidence and optimistic,我是个自信又乐观的人。15.I am outgoing and easy to get along with. 我的个性外向且容易相处。16.I suppose I’m very patient. 我想我很有耐性。17.I’d rather cooperate with other people, and get the job done as a team. 我乐于与其他人合作，加入团队工作。18.I like to be with people and to do things with them. 我喜欢跟人打交道，和其他人一起做事。8.","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"最常用的英语祝福语","date":"2013-09-26T11:03:39.000Z","path":"2013/09/26/最常用的英语祝福语/","text":"英文信的结尾比较单纯，意思就是中文的”敬上“，常用的结尾词如下：对人的敬意、尊敬：Regards, Kind regards, Best regards, Warm Regards祝福对方幸福、健康、成功：Wishes, Best wishesSincerely, Sincerely yours 比较常用在书信里，现在也可用在email中Cheers一般是用在敬酒，但较熟的朋友也可以用此作为email的结尾 祝贺用语 Happy New Year! 新年快乐！Happy Chinese/ Lunar New Year! 春节快乐！Gong Xi Fa Cai！恭喜发财（囧…)Happy Lantern Festival! 元宵节快乐！Happy Valentine‘s Day! 情人节快乐！Happy Easter! 复活节快乐！Happy Dragon Boat Festival! 端午节快乐！Happy Mid-Autumn/Moon Festival! 中秋节快乐！Happy Halloween! 万圣节快乐！Happy Thanksgiving! 感恩节快乐！Merry Christmas! 圣诞节快乐！May the coming year bring you prosperity and happiness! 祝你新的一年成功与幸福！Wish you all the best that comes with the Rat! 祝您鼠年事事如意！","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"英文通知","date":"2013-09-24T11:07:05.000Z","path":"2013/09/24/英文通知/","text":"开会通知Dear all,The next monthly management meeting will be held at10:00 a.m. on Monday, April 5, at meeting room A. Please kindly arrange your work.(这句我加的。。。） Following is the agenda for the meeting: 1.Monthly sales goal review.2.Department cost review.3.Action plans for next month. If there are any other items you would like to have placed on the agenda, let me know by email by the end of this week. Thank you. Regards,Kevin Yang 休假通知Dear all,I will be out of the office starting from 06/08/2008 and I will not return until 06/18/2008.During my absence, Andy Huang will be acting for me. Please contact him for Investment services business at 86-021-12345678. Regards,Kevin. 离职通知Dear all,As today is my last working day with SCB, I would like to take this oppurtunity to thank everyone for being so supportive and helpful during my stay here, not to mention your true friendship. I fee fortunate to have the opportunity to work at SCB plus the friendship I’ve made over the years. This experience will always be treasured forever. Let’s keep in touch. CarolCarol@yahoo.com.cn sample2Dear all,On my last working day in Wealth Management, I would like to thank you all for your assistance and caring. I truly enjoyed the time working at Standard Chartered Bank. It has been an honor to work with great people like you, and thanks again! For any matters, you are welcome to contact me via email or mobile as attached below. Best wishes to you in the future! Regards, Calvin Chen13001234567calvinchen@hotmail.com. sample4Dear All,Today’s my last working day at ABC. Thank you for your assistance and support during my 2 years stay. It’s my great honor to have worked with you all and I’ll cherish our memories during good and tough times. Now I’ve made the decision to fulfill my other dreams, and I’ll certainly do my very best to achieve the goals.It’s not the end of our relationship but instead it’s the beginning of a great one, so let’s keep in touch. I wish everyone the very best in your career, family, and health… Thank you all again！ Jerry Yang13001234567jerryyang@yahoo.com 离职祝福Jenny,Nice working with you and will sure get in touch with you when I’m in Beijing again.Here is my personal contact:省略Let me know where you are when everything is settled.Wish you all the best!Sam Good luck to you wherever you go and whatever you do on your next stop! Take care! Thanks for your great support to us and wish you the best !! Take care! 开会常用英语1.Is this seat taken? 这个位子有人坐吗？2.He is coming.(he is on the way/he will be here shortly/soon) 他快到了。（主持问某人在哪里？）3.How are today? 你今天好吗？4.Where would you like to sit? 你想坐哪里？5.What time are we starting? 我们几点开始？6.Has everyone got a copy of the agenda? 每个人都拿到会议议程的复本了吗？7.What’s on the agenda? 今天的议程是什么？ Shall we start/begin? 我们可以开始了吗？9.Let‘s get started. 我们开始吧！10.Hello, everyone. Thanks for joining the meeting. 各位好。谢谢大家来参加这个会议。11.Good morning everyone. Welcome. 早上好，欢迎各位。12.Let’s brief you on the agenda today. 让我先简单介绍一下今天开会的议程。13.Let’s review our agenda for today. 让我们先看一下今天开会的议程。14.Let me review/go over the agenda. Firstly…Secondly…Thirdly…Finally…让我介绍一下今天会议议程，首先。。第二。。第三。。最后。。15.Now, then, the first thing we need to talk about… 现在，第一件事我们要谈的是。。。16.All right. Now, the first item on the agenda is to… 好的，现在，在议程上第一个项目是…17.Our objective for this meeting is to… 我们今天会议的主题是…18.On the agenda, you’ll see three items. 在议程上，你将看到三个项目。19.Let’s take a break. 休息一下吧！20.it’s almost lunchtime. 差不多该吃午餐了。21.We have an hour lunch break. 差不多该吃午餐了。 May I have your attention, please? 可以请大家注意吗？ Get to the point. 请讲重点。24.Be clear and specific. 请明确且具体一点。25.Could you be more specific? 你可以再具体一点吗？26.Could you repeat those figures again more slowly, please? 请你慢慢地再说一次那些数字？27.Could you write that down for me, please? 你可以帮我记一下吗？28.Sorry, Mark, could you please let Nadia finish? 抱歉，马克，你可不可以让纳迪亚先讲完？29.Can we talk about this later? 我们可以等一下再谈这个吗？30.Okay, go on. (Yes, go ahead.) 好的，继续。31.Don’t you think we should take a short break and have some coffee? 你不认为我们该休息一下，喝点咖啡吗？32.Mary, any thoughts? 玛丽，有没有任何想法？33.What’s your view? 你的看法是什么？34.Does anyone have any questions before we move on? 在我们继续之前，有没有人有任何问题？35.Could you answer that for us? 你可以为我们回答那个问题吗？36.Shall we move on to the next point? 我们可以进行下一个议题吗？37.Could I ask everyone to please focus on the relevant issues here? 我可以请大家集中在相关的问题上吗？38.Tell us about your ideas for this. 告诉大家你对于这个的看法。39.The next issue I would like to focus on is… 下个议题，我想把重点放在…40.Can you give us more detail in what has happened? 你能让我知道发生的事情的更过细节吗？41.Can we please stick to the main topic/subject here? 我们可不可以跟进主要的议题？42.What’re you trying to say? 你想说什么？43.Let me give you an example. 让我举一个例子。44.Can you explain that to another discussion? 我们可以把那个留到以后讨论吗？45.Can we leave this until another date? 我们可以改天讨论这个吗？46.Can you explain that in more detail? 你可以解释得再详细一点吗？47.Is that clear now? 现在清楚了吗？48.I think we need more time to consider this. 我想我们需要更多的时间来考虑这个。49.What do you think? 你认为如何？50.Do you agree? 你同意吗？","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"最常用的50个英文短语","date":"2013-09-23T11:18:00.000Z","path":"2013/09/23/最常用的50个英文短语/","text":"First of all 首先First of all, a warm welcome to our company.首先，诚挚的欢迎你加入我们公司。 In the meantime(Meanwhile) 同时In the meantime, can you give me some thoughts and come up with any recommendations?同时你能给我一些想法及提出任何建议吗？ From one’s point of view 从…的观点I would like to agree with Marketing’s suggestion as this will be great enhancement for our proposed scheme from a sales point of view.我同意营销部门的建议，因为从销售的断电，这对于我们提出的方案有很大的改善。 Generally (Speaking) 一般而言Generally speaking, I think you’re right.一般而言，我认为你是对的。 In conclusion (All in all) 总之In conclusion,I’d like to thank you for all your efforts.总之，我要感谢你们所有的努力。 In accordance with( According to) 根据In accordance with the announcement made by CEO today…根据首席执行官今天所宣布… In terms of 就什么而论；在某方面The ABC company is number one in the terms of net sales in China在净销售量方面，ABC公司在中国市场是第一名。 Apart from that (Besides/In addition) 除…之外Besides, I want you to promise me one thing.此外，我要你答应我一件事。 Rather than(Instead of) 而不是You should be responsible for this issue instead of me.你该为这件事负责而不是我。 Due to (Because of) 由于Her absence was due to sickness.由于生病她没来上班。 In case 假使、倘若We also provide the contact window for you in case you have further questions regarding this product.我们也提供联络窗口给你，倘若你对这项产品有进一步的问题。 As far as I know 据我所知As far as I know. they will invest quite a big amount in marketing this product next year.据我所知，他们明年将花大量的钱来营销这个产品。 In view of 鉴于；考虑到In view of the above, we consider it may be better if dialog can be arranged between A and B.鉴于以上论述，我们可以考虑安排A和B对话，这样可能会比较好。 Even though 虽然Even though I tried very hard, I didn’t manage to finish the work.虽然我努力地尝试，我还是无法完成这项工作。 15.prior to 在…之前Prior to that, we need to communicate with the salespersons on the process.在那之前，我们需要与业务同仁沟通流程。 As long as 只要We are prepared to pay your asking price, as long as you can deliver on time.只要你能准时交货，我们已预备支付你们要求的价格。 As a reminder 在此提醒As a reminder, all sales are counted if they are booked by end of this month.在此提醒，如果是在月底前预订的则所有业绩都会被计算。 From one’s perspective 从…观点This is very sensitive from both regulatory and customer reputation perspectives.从主管机关及顾客信誉的观点，这都是非常敏感的。 In that case 既然那样In that case, let’s start earlier.既然那样，我们就早点开始。 On one’s behalf 代表某人On my boss’ s behalf, I agree on the special price.代表我老板，我同意这个特别的优惠价格。 For reasons outlined above 根据上述的理由For reasons outlined above, we decided not to launch this product.根据上述的理由，我们决定不发布这个产品。 Be subject to 决定于The new product launch schedule is subjected to approval by Headquarter.新产品的发布决定于总部的同意。 In light of 按照We reviewed our strategies in light of recent market changes.按照市场变化我们复审公司的策略。 As well 同样地、也It was decided by the company’s top management that the event would be expanded to other functions as well.公司的管理阶层会决定将这个活动也推广至其他部门。 In my opinion 在我看来In my opinion, we should delay our decision until the end of the week.在我看来，我们应该推迟到这个周末再做决定。 Compared with (In comparison with) 跟什么比His performance is not bad in comparison with his co-workers in the same department.同部门的同事相比，他的表现不差。 By the way 顺便提起By the way, thanks for helping us arrange the meeting.顺便提起，谢谢你帮我安排这个会议。 To my knowledge (Based upon my understanding) 据我理解To my knowledge. there are still some problems with the new system.据我理解，这个新系统还有一些问题。 Actually(As a matter of fact/In fact) 事实上As a matter of fact, I’ve never been there before.事实上，我从未到过那儿。 To tell you the truth (Frankly speaking) 坦白说To tell you the truth, I have no idea about it.坦白说，我不知道。 In spite of 尽管In spite of spending all night, I wasn’t able to finish the work.尽管花了整夜的时间，我还是无法完成工作。 32.In order to 为了We propose to launch a sales competition campaign in order to achieve the sales target.我们提议举办业务销售竞赛以达成销售目标。 As usual 像往常一样Annual bonuses will be paid as usual to employees who have performed well this year.像往常一样，今年表现优异的员工可以获得年终奖金。 34.In principle 原则上In principle, we are happy to agree on the new proposal.原则上，我们乐意赞同这个新提案。 On the whole 整体而言On the whole, last year was successful, with profits up by eight percent, in spite of difficulties in the market.整体而言，虽然去年市场不景气，但是获利上升了8%，算是相当成功。 As for 至于As for product A, we include it in our product because the company can make a highest profit.至于A商品，我们把它包含进产品，因为公司可以赚更多利润。 As you know 如你所知As you know, we include it in our product because the company can make the most of this opportunity.如你所知，这个月我们只有一种产品可销售，我们需要好好把握这个机会。 With regards to 关于Overall, the responses are positive with regards to the activities, which were undertaken in 1Q.整体而言，关于第一季所办的活动，反应都还算较好。 As yet (So far) 迄今As yet, we have not had time to consider your proposal.到目前为止，我们还没有时间考虑你的提案。 For the time being 暂时We’re ahead of our competitors of the time being.我们暂时领先对手。 In any case 无论如何In any case, we will support you.无论如何，我们都会支持你。 What’s more(Moreover/Furthermore) 再者，而且She learns quickly, and what’s more, she remembers what she has learnt.她学的很快，而且，她学过的全都记得。 Account for 解释Oil price rises can be accounted for by increased demand or decreased availability of supply.需求的扩大或供给的不足可以解释油价的上扬。 Be in line with 与…一致Although your proposals were sound, they were not in line with company policy.虽然你的提案很合理，但与公司的政策并不一致。 On the basis of 基于On the basis of recent market research, there seems to be a clear need for this kind of product.基于最近的市场调查，这种产品似乎有相当明确的需求。 On the thought of 因为；基于以下理由He was dismissed on the ground of his inefficiency and poor results.他被辞退的理由是缺乏效率及表现不佳。 In advance 事前But if you do so, please let me know in advance.如果你这么做，请事前让我知道。 At first sight 初看之下At first sight the contract seemed normal.初看之下这份合约很正常。 In this regard 就这方面而言Vicky please liaises with Kenny in this regard tomorrow.薇姬明天请与肯尼联系这方面事情。 Run into 遇到If anyone runs into barriers, please fee free to call or email me.如果任何人遇到困难，请不用客气打电话或发电子邮件给我。","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"英文时间数字如何表达","date":"2013-09-22T11:08:09.000Z","path":"2013/09/22/英文时间数字如何表达/","text":"Five days later ( After five days) 五天后 Five days earlier 五天前 Early May 五月初 Middle of May(Mid-May) 五月中 Late May (End of May) 五月底 Over the next few weeks 未来几周 In the coming months 未来几个月8.Earlier this year 年初 Middle of this year 年中 End of this year 年底 A couple of years 好几年 on Friday morning 星期五早上 This Friday（On Friday of this week） 本周五 In the near future 近期内 On Friday 每逢周五 First half of Aug. 八月的上半月 Second half of 2008 2008年的下半年 In the next day or so 这一、两天之内 March 2,2005（3/2/2005) 美式2005年3月2日2nd March, 2005 (2/3/2005) 英式2005年3月2日 B.C. (before Christ) 公元前 A.D. (after his dead) 公元 At 4:00 p.m. on Monday, April 1. 4月1日星期一下午4点 On Tuesday, December 24, from 6:00 to 9:00 p.m. 12月24日星期二下午6点到9点 Starting on April 1 this year… 从今年的4月1日开始 12:00 pm/12:00 noon 中午12点 12:00 am/12:00 midnight 午夜12点 老外习惯的数字用法千 1,000 One thousand万 10,000 Ten thousand十万 100,000 One hundred thousand百万 1,000,000 One million千万 10,000,000 Ten million亿 100,000,000 One hundred million十亿 1,000,000,000 One billion百亿 10,000,000,000 Ten billion千亿 100,000,000,000 One hundred billion万亿 1,000,000,000,000 One trillion 数字的英文表达方式二分之一 one half五分之一 one-fifth七分之三 three-sevenths加 plus减 minus乘 time除 divide10mx15m ten meters by fifteen大于 greater than等于 equal to小于 less than1.5 one point five2008 two thousand and eight1947 nineteen forty-seven932811 night three two eight double one-8℃ minus eight degree centigrade","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"进了外企再学英语","date":"2013-04-12T12:10:03.000Z","path":"2013/04/12/进了外企再学英语/","text":"email 部分第一部分：开场（opening）提及你写这封信的缘由及目的，并定出全文的主题，举例如下：Thank you for your email on 10 August, requesting…Thank you for calling me yesterday to discuss…I would like to suggest that you…I am delighted to give you the detail about…第二部分：主旨（reason for writing）具体陈述这封信的主旨，以一个段落表达一个主题为原则，看需要几个段落来陈述主旨，举例如下：Attached please find the latest information on…In order to achieve our sales target, we need to….第三部分：行动（request for action）主旨说明完后，对方应该了解你写这封信的目的及背景，接下来就是要求对方有所行动，例如回信、回电话、表达意见、缴交文件等，举例如下：Could you please call me later today?Please confirm that these arrangements are find with you.第四部分：结尾（ending）最后再以客气的口语做总结，让对方了解你的期待，举例如下：I look forward to hearing from you.I hope this information is helpful.Please call me if you have any question. 最常用的100种句型 Starting I am writing to confirm/ enquire/ inform you…我写信时要确认/询问/通知你… I am writing to follow up on our earlier decision on the marketing campaign in Q2.我写信来追踪我们先前对于第二季度营销活动的决定。 Starting a reference With reference to our telephone conversation today…关于我们今天在电话中的谈话…. In my previous email on October 5… 先前在10月5日所写的信… As I mentioned earlier about…如我先前所提及关于…. As indicated in my previous email…如我在先前的信中所指出…. As we discussed on the telephone…如我们上次在电话中的讨论… From our decision at the previous meeting…如我们在上次会议的决定… As you requested/ Per your requirement…按照你的要求… In reply to your email dated April 1, we decided…回答你在4月1日写的信，我们决定… This is in response to your email today.这是针对你今天早上来信的回复。 As mentioned before,we deem this product has strong unique selling points in China. 如先前所述，我们认为这个产品在中国有强有力且独一无二的销售点。 As a follow-up to our phone conversation yesterday, I wanted to get back to you about the pending issues of our agreement. 追踪我们昨天在电话中所谈，我想答复你关于我们合约的一些待解决的议题。 I received your voice message regarding the subject. I’m wondering if you can elaborate i.e. provide more details. 我收到你关于这个主题的留言。我想你是否可以再详尽说明，也就是再提供多一点细节。 Giving information Please be advised/ informed that…请被告知… Please note that…请注意… We would like to inform you that…我们想要通知你… I am convinced that…我确信…. We agree with you on…我们同意你在…. With effect from 4 Oct.,2008…从2008年10月4日开始生效…. We will have a meeting scheduled as noted below. 我们将举行一个会议，时间表如下。 Be assured that individual statistics are not disclosed and this is for internal use only.请确保个人信息不会外泄且只供内部使用。 I am delighted to tell you that…我很高兴地告诉你…. We are pleased to learn that…我们很高兴得知…. We wish to notify you that…我们希望通知你… Congratulations on your…恭喜您关于… I am fine with the proposal.我对这份提案没有意见。 I am pleased to inform you that you have been accepted to join the workshop scheduled for 22-24 Nov,2008. Giving bad news We are sorry to inform you that…我们很抱歉地通知你… I’m afraid I have some bad news.我恐怕要带来一些坏消息。 There are a number of issues with our new system. 我们的新系统有些问题。 Due to circumstances beyond our control…由于情况超于我们所能控制…. I don’t fee too optimistic about…我觉得不太乐观关于…. It would be difficult for us to accept…我们很难接受…. Unfortunately I have to say that, since receiving your inquiries on the subject, our view has not changed. 很不幸地，我必须这么说，自从收到你关于这个主题的询问，我们的看法都没有改变。 Making a request We would be grateful if you could…我们会很感激如何你可以.. I would appreciate it if you could…我会很感激如果你可以…. Would you please send us…? 可否请你寄给我们…? We need your help. 我们需要你的帮助。 We seek your assistance to cascade/relay this message to all your staff.我们请求你的帮助，将此信息传达给你们的员工。 We look forward to your clarification. 我们期待你的澄清。 Your prompt attention to this matter will be appreciated. 您能立即注意此事，我们将非常感激 I would really appreciate meeting up if you can spare the time.Please let me know what suits you best.如果您能抽出时间，我希望能与你见面，请让我知道您最合适的时间。 Please give us your preliminary thoughts about this. 请让我知道您对于这件事情初步的想法。 Would you please reply to this email if you plan to attend? 请您回信如果您计划参加？ Please advise if you agree with this approach. 请告知是否你同意这个方法。 Could you please let me know the status of this project?请让我知道这个计划的进度？ If possible, I hope to receive a copy of your proposal when it is finished. 如果可能，当你完成提案，我希望能收到一份复本。 I would appreciate it very much if you would send me your reply by next Monday. 如果能在下周一前收到您的答复，我将非常感激。50.Hope this is OK with you. If not, let me know by email ASAP. 希望您对此没有问题，如果不行，请利用电子邮件尽快让我知道。 Could you please send me your replies to the above questions by the end of June? 请您在6月底前答复我上述问题好吗？ May I have your reply by April 1, if possible? 如果可能，我能否在4月1号前收到您的答复？ Offering help If you wish , we would be happy to…如果你希望，我们很乐意… Please let me know if there’s anything I can do to help.请让我知道任何我可以帮得上忙的地方。 If there’s anything else I can do for you on/regarding this matter,please feel free to contact me at any time. 对于这件事，如果还有任何我能帮得上忙的地方，请不要客气，随时与我联络。 If you want additional recommendations on this, please let us know and we can try to see if this is possible. 如果关于此事你需要额外的建议，请让我知道，我们会尝试看看是否可能。 Reminder I’m just writing to remind you of… 我只是写信来提醒您… May we remind you that…? 我们想要提醒您… Enclosing documents I am enclosing…我附上… Please find enclosed…请查阅附件…. Attached here to…附件是关于…. Attached please find the most up-to-date information on/regarding/concerning…附上关于某某的最新资料… Attached please find the draft product plan for your review and comment.附上产品计划书的草稿，请复审及评价。 Closing Remarks If you have any further questions, please feel free to contact me. 如果你有任何问题，请不要客气与我联系。 I hope my clarification has been helpful. 希望我的说明是由帮助的。 Please feel free to call me at any time, I will continually provide full support. 请随时与我联络，我会继续提供全力的支持。 Please let me know if this is suitable. 请让我知道这是否恰当。 Referring to future contact Looking forward to seeing you soon. 期待很快能见到你。 We look forward to hearing from you soon. 我们期待很快得到您的答复。 Hope this is clear and we are happy to discuss this further if necessary. 希望上述说很清楚，如有必要，我们很乐意再进一步讨论。 I look forward to receiving your reply soon. 我期待很快收到您的答复。 Looking forward to receiving your comments in due course. 期待在预期的时间收到你的反馈。 I’ll keep you posted. 我会与你保持联络。 Please keep me informed on the matter. 请随时让我知道这件事的发展。 For any comment/ suggestions, please contact Nadia at 10086（我诌的）. 任何评价或建议，请打电话10086联络Nadia。 Apologizing I would like to apologize for… 我想就….道歉…. I apologize for the delay in…对于…的耽搁，我深感抱歉。 We are sorry for any inconvenience caused. 对于产生任何不便，我们感到抱歉。 I am sorry for any inconvenience this has caused you. 对于造成你的任何不便，我感到抱歉。 I’m sorry about last time. 关于上次的事我很抱歉。 We apologize for not replying you earlier. 对于未能早一点回信给你，我们感到抱歉。 I’m really sorry about this. 关于这件事，我真的很抱歉。 Sorry,I’m late in replying to your email dated Monday, April 1.抱歉，我太迟回您在4月1号（星期一）发给我的邮件。 We apologize for the delay, and hope that it doesn’t inconvenience you too much. 我们为耽搁道歉，希望不会给您带来太多的不便。 Hoping that this will not cause you too much trouble. 希望不会为您带来太多的麻烦。 Sorry if my voice message is not clear enough. 如果我的电话留言不够清楚，我深感抱歉。 Thank you Thank you for your help/assistance/effort/cooperation. 谢谢你的帮助/协助/努力/合作。 I appreciate very much that…我非常感激你…. I truly appreciate it. 我真的很感激。 Thank you for your participation. 谢谢你的参加。 Thank you so much for inviting me. 非常感谢你邀请我。 Congratulations to all of you and thanks for your efforts. 恭喜各位并谢谢各位的努力。 Your understanding and cooperation is greatly/highly appreciated. 很感激你的理解及合作。 Your prompt response will be most appreciated.很感激你快速的答复。 Once again, thank you all for your commitment and support. 再一次感谢你的承诺及支持。 Thanks for your input/clarification/message. 谢谢你的投入/澄清/信息。 Any comments will be much appreciated. 对于您的任何建议，我将非常感激。 Thank you very much for everything you’ve done for me. 感谢你为我做的一切。 I would appreciate your kindest understanding with/ regarding this matter. 我和感激你对这件事情的理解。 Please convey my thanks to all the staff involved, they certainly did an excellent job. 请表达我的谢意给那些有关的同仁，他们真的干得很好。","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"Python入门教程","date":"2013-01-22T12:10:03.000Z","path":"2013/01/22/Python入门教程/","text":"Python官网 Python 入门教程 简明 Python 教程","tags":[{"name":"教程, Python，引道","slug":"教程-python，引道","permalink":"http://yoursite.com/tags/教程-python，引道/"}]},{"title":"Markdown语法说明","date":"2011-12-20T09:52:09.000Z","path":"2011/12/20/Markdown语法说明/","text":"Markdown 语法说明 标题： #h1级标题 ##h2级标题 ###h3级标题 ####h4级标题 #####h5级标题 ######h6级标题 分割线：三个以上的短线 即可作出分割线 超链接：连接名称我是链接名 点我刷新 另一种超链接写法：[链接名][链接代号]here然后在别的地方定义 3 这个详细链接信息， 直接展示链接的写法：http://www.izhangbo.cn 键盘键Ctrl+[ and Ctrl+] code格式：反引号Use the printf() function. There is a literal backtick (`) here.针对在代码区段内插入反引号的情况 强调：斜体强调粗体强调 图片 使用 icon 图标文字 段落：以一个空行开始，以一个空行结束，中间的就是一个段落。 表格： Item Value Computer $1600 Phone $12 Pipe $1 无序列表：使用 - 加一个空格（） 无需列表1 无序列表2 无序列表3 有序列表：使用 数字 加一个英文句点 有序列表 有序列表 有序列表 有序列表 有序列表 换行缩进形成代码区块 这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。 块引用 给引用的文本开始位置都加一个 ‘&gt;’，便可组成一个块引用。在块引用中，可以结合其他markdown元素一块使用，比如列表。强调也可以只在第一行加大于号，其他位置不加。 块引用里使用列表，需要和上面的内容隔开一个空行 记得加空格哦。","tags":[]},{"title":"学习Objective-C语言","date":"2011-09-22T11:19:09.000Z","path":"2011/09/22/学习Objective-C语言/","text":"Objective-C领域的经典著作：Objective-C 2.0程序设计 learn_objectivec Apple 官方的「The Objective-C Programming Language」Programming with Objective-C 重要的内存管理Memory Management Programming Guide for Core Foundation","tags":[{"name":"教程, Objective-C，引道","slug":"教程-objective-c，引道","permalink":"http://yoursite.com/tags/教程-objective-c，引道/"}]},{"title":"Lua内存管理","date":"2011-07-04T07:55:00.000Z","path":"2011/07/04/Lua内存管理/","text":"本文主要介绍某项目脚本(lua)部分内存泄漏的查证与处理过程，希望对大家有点帮助。需要说明的是，lua本身并不存在真正的内存泄漏，只是因为使用上面的原因导致无法gc，从而导致逻辑上的泄漏:)。 参考GCObject的声明可以发现，lua中的复杂数据类型变量的传递都是基于引用的。当lua从根开始gc扫描的时候，只要还有一个地方有对此变量的引用，那么这个变量就不会被collect。这种情况造成的危害取决于多大程度上依赖于引用，如果有适当的间接层/弱引用来隔离这个问题，可能问题会有所缓解。 以下是一些常见的错误引用情景: 1.本应该local 的变量进入global空间或者module空间了(忘记写local)，如果这是一个table/function/udata等类型的变量的话，非常不幸的，这个变量将不会被正确gc了 —-除非你再显式的释放。这是非常容易犯的错误，一直在想为什么lua变量不是默认local呢？ 当然这个话题会引发另外一场争论。 1234local function test_user(id) userobj = get_user_by_id(id) --这里总是会有一个玩家对象泄漏 print(\"only test\", userobj:get_name())end 2.c/c++部分调用的lua_ref是否有正常lua_unref释放？ 通过debug.getregistry()可以查到这些ref. 3.其他各种各样的实际bug造成的泄漏。 当怀疑系统有泄漏以后，我们可以怎么查到这些泄漏呢？我强烈建议大家建立一个weak table, 把你所有创建过的能够称之为资源的，包含但不限于“战斗对象，玩家，npc，物品，场景，邮件”等等对象全部扔到这个table里面。当你知道玩家已经下线、战斗已经销毁了，但通过连续的强制full gc以后weak table里面还有这个变量，这就证明了这个变量的引用没有被完全释放，于是问题就被发现了，我们又有事情干了@_@。 知道有泄漏是比较容易的，能够完全揪出来就不是很容易了。是的，它究竟在哪儿呢? 一开始在此项目里面也是先发现比如某npc泄漏了，然后就去查代码，看看究竟哪个地方写得不对。这种方式效率极低，基本上查不到什么问题。在迟一点的时候才使用现在的方案：从_G深度遍历所有的table、metatable、funciton’supvalue、function’s env、registentry(lua_ref)。 目前所知的所有引用必定存在于这几个空间， 遍历完成以后一定可以找到那个“迷失了的引用”。 这种方式在脚本层就可以完成所有事情，甚至你可以在运营环境中在线查证，其遍历的速度是非常快的，但内存开销非常大(:，可以考虑一边遍历一边gc，当然还要记得避免重复搜索。 在应用此方案以后，此项目解决了脚本中所有的泄漏问题。 一点总结：1.如果系统性能还能够承受的话，建议不要直接引用对象，可以多做一层间接层。2.lua里面的弱引用是非常有用的。3.比较大的物理内存是必要的，这可以为大家查证问题争取足够多的时间:) 4.可以把查找泄漏的部分写入到关机逻辑里面，每次关机的时候自动查找泄漏，然后出具报告。","tags":[{"name":"Lua","slug":"lua","permalink":"http://yoursite.com/tags/lua/"}]},{"title":"Java教程","date":"2010-02-22T07:19:09.000Z","path":"2010/02/22/Java教程/","text":"Code Conventions for the Java TM Programming Language Java教程","tags":[{"name":"教程, Java,引道","slug":"教程-java-引道","permalink":"http://yoursite.com/tags/教程-java-引道/"}]},{"title":"Java教程","date":"2010-02-22T07:19:09.000Z","path":"2010/02/22/java教程/","text":"Code Conventions for the Java TM Programming Language Java教程","tags":[{"name":"教程, Java","slug":"教程-java","permalink":"http://yoursite.com/tags/教程-java/"}]}]