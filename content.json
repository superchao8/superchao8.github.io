[{"title":"Entrez Direct--Appendices","date":"2019-04-19T01:29:12.000Z","path":"2019/04/19/Entrez Direct--Appendices/","text":"附录设置联系地址和脚本名称EDirect自动从系统获取用户的电子邮件地址，以便有人在失控脚本导致Entrez服务器出现问题时通知，但是如果需要其他联系地址（例如，系统管理员或软件开发人员）可以在管道或脚本的开头显式设置： 1econtact -email author_email_address -tool name_of_script 这样，如果脚本中的无限循环意外滥用NCBI资源，NCBI就会有关于联系人的信息。 （为方便起见，还可以在所有电子实用程序调用操作中设置首选电子邮件地址和软件工具名称。） 命令行参数下面列出了EDirect功能的参数： 使用esearch在索引条款上开始新的Entrez搜索： 查询规范 12-db Database name-query Query string 文件订单 1-sort Result presentation order 日期 1234-days Number of days in the past-datetype Date field abbreviation-mindate Start of date range-maxdate End of date range 按现场限制 12-field Query words individually in field-pairs Query overlapping word pairs 拼写检查 1-spell Correct misspellings in query 杂项参数 1-label Alias for query step elink函数查找相关文章或相关记录： 目标数据库 123related Neighbors in same database-target Links in different database-name Link name (e.g., pubmed_protein_refseq) 直接记录选择 12-db Database name-id Unique identifier(s) 高级控制 123-cmd Command type (returns eLinkResult XML)-mode \"ref\" uses LinkOut provider's web site-holding Name of LinkOut provider 批量处理 1-batch Bypass Entrez history mechanism 杂项参数 1-label Alias for query step 使用efilter通过索引术语限制搜索或链接结果： 查询规范 1-query Query string 文件订单 1-sort Result presentation order 日期 1234-days Number of days in the past-datetype Date field abbreviation-mindate Start of date range-maxdate End of date range 按现场限制 12-field Query words individually in field-pairs Query overlapping word pairs 拼写检查 1-spell Correct misspellings in query 出版过滤器 12345-pub abstract, clinical, english, free, historical, journal, medline, preprint, published, review, structured-journal pnas, \"j bacteriol\", ...-released last_week, last_month, last_year, prev_years 序列过滤器 12345678-country usa:minnesota, united_kingdom, \"pacific ocean\", ...-feature gene, mrna, cds, mat_peptide, ...-location mitochondrion, chloroplast, plasmid, plastid-molecule genomic, mrna, trna, rrna, ncrna-organism animals, archaea, bacteria, eukaryotes, fungi, human, insects, mammals, plants, prokaryotes, protists, rodents, viruses-source genbank, insd, pdb, pir, refseq, swissprot, tpa 基因过滤器12-status alive-type coding, pseudo SNP过滤器 12-class acceptor, donor, frameshift, indel, intron, missense, nonsense, synonymous 杂项参数 1-label Alias for query step 记录检索功能是efetch： 格式选择 123-format Format of record or report-mode text, xml, asn.1, json-style withparts, conwithfeat 直接记录选择 12-db Database name-id Unique identifier or accession number 序列范围 123-seq_start First sequence position to retrieve-seq_stop Last sequence position to retrieve-strand Strand of DNA to retrieve 基因范围 12-chr_start Sequence range from 0-based coordinates-chr_stop in gene docsum GenomicInfoType object 序列标志 123-complexity 0 = default, 1 = bioseq, 3 = nuc-prot set-extend Extend sequence retrieval in both directions-extrafeat Bit flag specifying extra features 杂 12-raw Skip database-specific XML modifications-json Convert adjusted XML output to JSON xtract函数用于处理XML数据： 处理标志 12345678-strict Remove HTML and MathML tags-mixed Allow mixed content XML-accent Excise Unicode accents and diacritical marks-ascii Unicode to numeric HTML character entities-compress Compress runs of spaces-stops Retain stop words in selected phrases 数据源 12-input Read XML from file instead of stdin-transform File of substitutions for -translate 探索参数层次结构 1234-pattern Name of record within set-group Use of different argument-block names allows command-line-subset control of nested looping 勘探建筑 123456Object DateRevisedParent/Child Book/AuthorListHeterogeneous \"PubmedArticleSet/*\"Exhaustive \"History/**\"Nested \"*/Taxon\"Recursive \"**/Gene-commentary\" 条件执行 1234567-if Element [@attribute] required-unless Skip if element matches-and All tests must pass-or Any passing test suffices-else Execute if conditional test failed-position [first|last|outer|inner|even|odd|all]-select Select record subset by conditions 字符串约束 123456-equals String must match exactly-contains Substring must be present-is-within String must be present-starts-with Substring must be at beginning-ends-with Substring must be at end-is-not String must not match 数字约束 123456-gt Greater than-ge Greater than or equal to-lt Less than-le Less than or equal to-eq Equal to-ne Not equal to 格式定制 1234567891011121314-ret Override line break between patterns-tab Replace tab character between fields-sep Separator between group members-pfx Prefix to print before group-sfx Suffix to print after group-plg Prologue to print once before elements-elg Epilogue to print once after elements-rst Reset -sep through -elg-clr Clear queued tab separator-pfc Preface combines -clr and -pfx-deq Delete and replace queued tab separator-wrp Wrap elements in XML object-def Default placeholder for missing fields-lbl Insert arbitrary text 元素选择 1234-element Print all items that match tag name-first Only print value of first item-last Only print value of last item-NAME Record value in named variable -element Constructs 123456789101112Tag CaptionGroup Initials,LastNameParent/Child MedlineCitation/PMIDRecursive \"**/Gene-commentary_accession\"Unrestricted \"PubDate/*\"Attribute DescriptorName@MajorTopicYNRange MedlineDate[1:4]Substring \"Title[phospholipase | rattlesnake]\"Object Count \"#Author\"Item Length \"%Title\"Element Depth \"^PMID\"Variable \"&amp;NAME\" 特殊元素操作 12345Parent Index \"+\"Object Name \"?\"XML Subtree \"*\"Children \"$\"Attributes \"@\" 数字处理 12345678910111213-num Count-len Length-sum Sum-min Minimum-max Maximum-inc Increment-dec Decrement-sub Difference-avg Average-dev Deviation-med Median-bin Binary-bit Bit Count 字符串处理 123456-encode URL-encode &lt;, &gt;, &amp;, \", and ' characters-upper Convert text to upper-case-lower Convert text to lower-case-title Capitalize initial letters of words-year Extract first 4-digit year from string-translate Substitute values with -transform table 文字处理 1234567-terms Partition text at spaces-words Split at punctuation marks-pairs Adjacent informative words-reverse Reverse words in string-letters Separate individual letters-clauses Break at phrase separators-indices Index normalized words 序列处理 12-revcomp Reverse-complement nucleotide sequence-nucleic Subrange determines forward or revcomp 序列坐标 123-0-based Zero-Based-1-based One-Based-ucsc-based Half-Open 命令生成器 1-insd Generate INSDSeq extraction commands -insd参数顺序 1234Descriptors INSDSeq_sequence INSDSeq_definition INSDSeq_divisionFlags [complete|partial]Feature(s) CDS,mRNAQualifiers INSDFeature_key \"#INSDInterval\" gene product 杂 1234-head Print before everything else-tail Print after everything else-hd Print before each record-tl Print after each record 重新格式化 1-format [copy|compact|flush|indent|expand] 修改 123-filter Object [retain|remove|encode|decode|shrink|expand|accent] [content|cdata|comment|object|attributes|container] 验证 1-verify Report XML data integrity problems 摘要 12-outline Display outline of XML structure-synopsis Display count of unique XML paths 文档 1-examples Examples of EDirect and xtract usage einfo函数返回有关Entrez索引字段的信息： 数据库选择 12-db Database name-dbs Get all database names 数据摘要 12-fields Print field names-links Print link names EDirect提供了几个附加功能： epost 12345-db Database name-id Unique identifier(s) or accession number(s)-format uid or acc-input Read from file instead of stdin-label Alias for query step eproxy 12-alias File of aliases-pipe Read aliases from stdin econtact 12-email Contact person's address-tool Name of script or program nquire 12-get Uses HTTP GET instead of POST-url Base URL for external search 此外，-email和-tool在所有E-utilities调用函数中都可用于覆盖默认值，-http get将强制使用GET而不是POST，-alias将指定快捷键关键字和查询字符串或URL的文件sections和-help将打印每个函数的参数列表。 对于调试，-silent将禁止链接失败重试消息，-verbose将在每一步显示字段值，-debug将打印内部URL查询和每个步骤的XML结果，-base将指定特定的服务器质量保证测试。 EFetch格式每个数据库的EFetch -format和-mode值如下所示： ESearch排序下面列出了几个数据库的ESearch -sort值： ELink命令ELink -cmd选项生成结果为LinkSet XML： -cmd Result neighbor Neighbors or links neighbor_score Neighbors with computed similarity scores acheck All links available ncheck Existence of neighbors lcheck Existence of external links (LinkOuts) llinks Non-library LinkOut providers llinkslib All LinkOut providers prlinks Primary LinkOut provider,or URL for single UID with -mode ref EInfo数据 EInfo字段数据包含多个术语列表索引属性的状态标志： 12345678910111213&lt;Field&gt; &lt;Name&gt;ALL&lt;/Name&gt; &lt;FullName&gt;All Fields&lt;/FullName&gt; &lt;Description&gt;All terms from all searchable fields&lt;/Description&gt; &lt;TermCount&gt;138982028&lt;/TermCount&gt; &lt;IsDate&gt;N&lt;/IsDate&gt; &lt;IsNumerical&gt;N&lt;/IsNumerical&gt; &lt;SingleToken&gt;N&lt;/SingleToken&gt; &lt;Hierarchy&gt;N&lt;/Hierarchy&gt; &lt;IsHidden&gt;N&lt;/IsHidden&gt; &lt;IsTruncatable&gt;Y&lt;/IsTruncatable&gt; &lt;IsRangable&gt;N&lt;/IsRangable&gt;&lt;/Field&gt; UNIX实用程序下面介绍了几个有用的UNIX文本处理过滤器类，带有选定的参数： 按内容处理： sort Sorts lines of text -f Ignore case -n Numeric comparison -r Reverse result order -k | Field key (start,stop or first) -u | Unique lines with identical keys -b | Ignore leading blanks -s | Stable sort -t | Specify field separator uniq | Removes repeated lines -c | Count occurrences -i | Ignore case -f | Ignore first n fields -s | Ignore first n characters -d | Only output repeated lines -u | Only output non-repeated lines grep | Matches patterns using regular expressions -i | Ignore case -v | Invert search -w | Search expression as a word -x | Search expression as whole line -e | Specify individual pattern -c | Only count number of matches -n | Print line numbers 常用表达： 1234567891011121314151617181920Characters . Any single character (except newline) \\w Alphabetic [A-Za-z], numeric [0-9], or underscore (_) \\s Whitespace (space or tab) \\ Escapes special characters [] Matches any enclosed charactersPositions ^ Beginning of line $ End of line \\b Word boundaryRepeat Matches ? 0 or 1 * 0 or more + 1 or more &#123;n&#125; Exactly n 修改内容： 123456789sed Replaces text strings -e Specify individual expressiontr Translates characters -d Delete characterrev Reverses characters on line 格式内容： 列按内容宽度对齐列 12-s Specify field separator-t Create table expand将列对齐到指定位置 1-t Tab positions fold以特定宽度包裹线条 1-w Line width 按位置筛选： cut删除部分线条 12345-c Characters to keep-f Fields to keep-d Specify field separator-s Suppress lines with no delimiters head打印第一行 1-n Number of lines tail打印最后一行 1-n Number of lines 杂： wc计算单词，行或字符 123-c Characters-l Lines-w Words xargs构造参数 1-n Number of words per batch 文件压缩： tar存档文件 123-c Create archive-f Name of output file-z Compress archive with gzip gzip压缩文件 12-k Keep original file-9 Best compression 解压缩.zip存档 1-p Pipe to stdout gzcat解压缩.gz归档和管道到stdout目录和文件导航： cd更改目录 12345/ Root~ Home. Current.. Parent- Previous ls列出文件名 123456-1 One entry per line-a Show files beginning with dot (.)-l List in long format-R Recursively explore subdirectories-S Sort files by size-t Sort by most recently modified pwd打印工作目录路径通过键入“man”后跟命令名称，可以获得包含详细说明和示例的其他文档。 终端键盘快捷键可以在终端会话中使用控制和转义序列来浏览命令历史记录并移动光标以编辑当前输入的命令： 命令历史： Ctrl-n 下一个命令 Ctrl-p 上一个命令向前移动光标： Ctrl-e 到行尾 Ctrl-f 由一个字符组成 Esc-f 一个论点向后移动光标： Ctrl-a 到行首 Ctrl-b 一个字符 Esc-b 一个论点删除： Esc-Del以前的论点上一个角色 Ctrl-d 下一个字符 Ctrl-k 到行尾 Ctrl-u 整行 Ctrl-w 上一个单词 Esc-Del 以前的论点 Esc-d 下一个参数自动完成： Tab 选项卡完成目录或文件名程序控制： Ctrl-c 退出正在运行的程序 ^x^y 运行最后一个命令将x替换为y（注意，通过按住Control，按下另一个键并释放Control来键入控制序列，同时通过按Escape然后按另一个键来键入Escape序列。）","tags":[{"name":"生信","slug":"生信","permalink":"http://yoursite.com/tags/生信/"}]},{"title":"Entrez Direct--XML Processing","date":"2019-04-18T07:35:12.000Z","path":"2019/04/18/Entrez Direct--XML Processing/","text":"XML处理除了-first和-last命令之外，xtract还有其他元素变体，它们返回所选数据值的变换版本。它还有一些方法可以很容易地将提取的值包装在XML标记中，以便通过xtract进行进一步处理。 数据转换数字评估命令使用具有相同标签名称的一组数据。例如，-num将计算命名对象的数量（将-element“#Author”快捷方式转换为-num Author）。可以使用-sum添加XML对象中的整数值，并且可以使用-avg计算其算术平均值。选定内容中的字符数由-len返回（-element“％Title”实现为-len Title）。 文本和字符串命令适用于单个字符串值。使用-words将句子分隔为标点符号，或使用-upper将句子转换为大写。 -year命令返回数据中遇到的第一个四位数令牌，因此它可以使用整数Year或半结构化MedlineDate字符串正常工作。将-year应用于“PubDate/*”将检查所有内部对象的值，无论标记名称如何，并且是获取PubMed出版年份的一般解决方案。 通过运行xtract -help可以看到完整的元素变体集。 顺序处理数据分析经常涉及文本或数字处理的几个连续步骤。例如，检查PubMed摘要随时间的增长需要隔离每个摘要的单个单词，计算每篇文章的单词，按年度过滤结果，然后计算每年的平均单词数。各个操作都受到xtract函数的支持，因此将中间值包装在XML中可以消除对单独脚本执行计算的需要。 对选定日记中发布的文章运行搜索查询，将结果限制为带有摘要的文章，获取单个PMID，以及从本地数据缓存中获取记录： 123esearch -db pubmed -query \"PNAS [JOUR]\" -pub abstract | efetch -format uid | fetch-pubmed 返回一个XML PubmedArticleSet，其中包含超过115,000个PubmedArticle记录。下一步将提取出版年份和文章摘要中的单个词。原始XML中的所需字段是： 12345678910...&lt;PubDate&gt; &lt;Year&gt;2018&lt;/Year&gt; ...&lt;/PubDate&gt;...&lt;Abstract&gt; &lt;AbstractText&gt;Ammonia plays a key role in the ....&lt;/AbstractText&gt;&lt;/Abstract&gt;... 将PubmedArticleSet管道化为提取命令的初始版本： 123xtract -stops -pattern PubmedArticle \\ -year \"PubDate/*\" \\ -pfc \"\\n\" -sep \"\\n\" -words Abstract/AbstractText 在单独的行上打印年份和每个单独的抽象单词： 123456789101112132018ammoniaplaysakeyroleintheneutralizationofatmosphericacids... 用XML包装结果自定义参数使得可以将中间值（例如，每个抽象的单个单词和每篇文章的单词计数）包装回XML格式，因此可以将它们发送到另一个xtract命令以进行下一个处理步骤。将PubmedArticleSet管道化为： 12345xtract -stops -head \"&lt;Set&gt;\" -tail \"&lt;/Set&gt;\" -hd \"&lt;Rec&gt;\" -tl \"&lt;/Rec&gt;\" \\ -pattern PubmedArticle \\ -pfx \"&lt;Year&gt;\" -sfx \"&lt;/Year&gt;\" -year \"PubDate/*\" \\ -pfx \"&lt;Abst&gt;\" -sfx \"&lt;/Abst&gt;\" -sep \"&lt;/Abst&gt;&lt;Abst&gt;\" \\ -words Abstract/AbstractText 允许将提取的值写为结构化XML片段（显示为重新格式化以便于阅读）： 123456789101112131415&lt;Set&gt; &lt;Rec&gt; &lt;Year&gt;2018&lt;/Year&gt; &lt;Abst&gt;ammonia&lt;/Abst&gt; &lt;Abst&gt;plays&lt;/Abst&gt; &lt;Abst&gt;a&lt;/Abst&gt; &lt;Abst&gt;key&lt;/Abst&gt; &lt;Abst&gt;role&lt;/Abst&gt; &lt;Abst&gt;in&lt;/Abst&gt; &lt;Abst&gt;the&lt;/Abst&gt; &lt;Abst&gt;neutralization&lt;/Abst&gt; &lt;Abst&gt;of&lt;/Abst&gt; &lt;Abst&gt;atmospheric&lt;/Abst&gt; &lt;Abst&gt;acids&lt;/Abst&gt; ... -wrp参数是一个方便，它只设置XML对象名称，设置所有适当的自定义参数，如上所示： 123xtract -stops -wrp Set,Rec -pattern PubmedArticle \\ -wrp \"Year\" -year \"PubDate/*\" \\ -wrp \"Abst\" -words Abstract/AbstractText 使包装中间值变得容易。 然后将结果传送到下一步，使用-num计算每篇文章摘要中的单词数： 123xtract -wrp Set,Pub -pattern Rec \\ -wrp \"Year\" -element Year \\ -wrp \"Num\" -num Abst 再次将结果包装为结构化XML： 12345&lt;Set&gt; &lt;Pub&gt;&lt;Year&gt;2018&lt;/Year&gt;&lt;Num&gt;198&lt;/Num&gt;&lt;/Pub&gt; &lt;Pub&gt;&lt;Year&gt;2018&lt;/Year&gt;&lt;Num&gt;167&lt;/Num&gt;&lt;/Pub&gt; &lt;Pub&gt;&lt;Year&gt;2018&lt;/Year&gt;&lt;Num&gt;242&lt;/Num&gt;&lt;/Pub&gt; ... 使用“&gt;countsByYear.xml”重定向输出会将结果保存在文件中，以用于所有后续处理。 XML子集的选择xtract -select参数允许按数据值记录子集，例如发布年份。它充当“-if”语句，后跟条件语句，但没有 - 元素，因为它的目的是传递满足条件的所有记录的全部内容。 这比每年运行单独的esearch查询更方便，速度更快，并且可以查看未被Entrez索引的数据元素。它在下面的循环中用于将处理的查询结果限制为一年一次，将相关子集传递给第二个xtract命令： 123456for yr in &#123;1960..2018&#125;do cat countsByYear.xml | xtract -wrp Raw -pattern Pub -select Year -eq \"$yr\" | xtract -pattern Raw -lbl \"$yr\" -avg Numdone 将-avg应用于单词count以计算当前年度每篇文章的平均抽象单词数： 12345671969 1211970 1191971 126...2016 2072017 2062018 205 可以通过重定向到文件来保存此结果，也可以将其传送到： 12tee /dev/tty | xy-plot pnas.png 将数据打印到终端，然后以图形格式显示结果。最后一步应该是： 1rm countsByYear.xml 删除中间文件。","tags":[{"name":"生信","slug":"生信","permalink":"http://yoursite.com/tags/生信/"}]},{"title":"Entrez Direct--Local Data Cache","date":"2019-04-18T07:14:12.000Z","path":"2019/04/18/Entrez Direct--Local Data Cache/","text":"本地数据缓存Entrez Direct用户通常使用efetch获取所选数据记录，这会调用efetch.fcgi网络服务器。当需要几千条记录时，此解决方案很有效，但它不能扩展到更大的数据集，其中下载所需的时间成为限制因素。 随机存取档案作为替代方案，整个PubMed记录集可以通过文件传输协议获得，并且可以通过检索每日更新文件来保持最新。可以通过xtract对发布文件进行解压缩和管道传输以进行批量分析，但它们不提供对单个记录的随机访问。 计算机文件系统技术的最新进展现在允许将所有这些已发布的期刊文章引用重新打包为廉价的500千兆字节外部固态驱动器上的单个文件，使用文件夹层次结构来组织2800万个PubMed记录。此方法使用PMID中的数字对作为目录结构中的节点，从而提供对任何记录的直接和快速访问。例如，PMID 12345678将作为压缩的XML文件存储在/Archive/12/34/56/12345678.xml.gz中。 EDirect现在包含一个存档发布的脚本，可以完全自动化下载，更新，提取和存储过程。专用固态驱动器的路径将传递到命令行上的脚本： 1archive-pubmed -path /Volumes/alexandria 它可以每天或每周重新运行，以使存档保持最新。填充存档后，可以将PMID传送到fetch-pubmed脚本，以便从本地数据缓存中检索PubmedArticle XML记录。fetch-pubmed需要Archive子目录的路径才能找到数据。例如： 123esearch -db pubmed -query \"cancer AND regulation\" | efetch -format uid | fetch-pubmed -path /Volumes/alexandria/Archive 如果在用户的.bash_profile配置文件中设置了环境变量，则任一脚本都不需要-path参数： 1export EDIRECT_PUBMED_MASTER=/Volumes/alexandria 假设在后续示例中设置了EDIRECT_PUBMED_MASTER。 本地查询索引类似的分而治之策略可用于创建适用于大数据挖掘查询的本地信息检索索引。第二个新脚本index-pubmed会自动执行此活动。 （它是存档发布的超集，也可以定期运行。） 对于选定的PubMed文本字段（标题和主要摘要），索引过程会删除特定前缀后的连字符，删除重音符号和变音符号，在标点符号处拆分单词，更正编码工件以及拼写出希腊字母以便于搜索科学术语。然后它准备带有术语位置的倒排索引，并使用它们来构建分布式术语列表和发布文件。 例如，包含“癌症”的术语列表将位于/Postings/c/a/n/c/canc.trm。因此，对癌症的查询仅需要加载总指数的非常小的子集。 该设计支持有效的布尔表达式评估（例如，“(literacy AND numeracy) NOT (adolescent OR child)”），不受限制的通配符截断（例如，“therap*”），短语查询（例如，“selective serotonin reuptake inhibitor”），和邻近搜索（例如，“vitamin c ~ ~ common cold”）。 本地搜索命令短语搜索脚本控制对本地索引的访问。实际的基础工作由rchive程序完成。术语计数由-count（将通配符扩展组合为单个数字）或-counts（扩展通配符并显示单个术语和计数）返回。使用-query返回与搜索表达式匹配的PMID。 例如，使用截断的短语检查术语列表： 1phrase-search -count \"catabolite repress*\" 翻译为： 1rchive -path /Volumes/alexandria/Postings -count \"catabolite repress*\" 并返回单个单词的总计数： 124325 catabolite104977 repress* 使用-counts而不是-count返回扩展的术语和单个帖子计数： 1234567891011124325 catabolite12002 repress1 repressa5 repressable1 repressae1 repressant2 repressants1 repressc1 represse26322 repressed1 repressedm... 使用短语搜索： 12phrase-search -query \"selective serotonin reuptake inhibitor*\" | fetch-pubmed 为包含该短语的记录生成PMID列表，然后从本地存档中检索相关的PubmedArticle XML。使用[STEM]附加查询使用已通过Porter2词干分析算法处理的单词来评估相同的表达式。","tags":[{"name":"生信","slug":"生信","permalink":"http://yoursite.com/tags/生信/"}]},{"title":"Entrez Direct--Automation","date":"2019-04-17T07:20:12.000Z","path":"2019/04/17/Entrez Direct--Automation/","text":"自动化脚本中的Entrez命令冒险尝试进入编程领域时，可以在需要独立处理一个步骤的每个输出行时编写shell脚本，而不是将输出完整地传输到下一个命令。 （最简单的shell脚本只是一组命令的副本，这些命令被输入到终端中以供执行。） 在脚本中，可以通过将语句括在反引号（“`”）字符中来将变量设置为命令的结果。变量名称以美元符号（“$”）作为前缀，以将其值用作另一个命令中的参数。注释以井号（“＃”）开头并被忽略。引用字符串中的引号通过反斜杠（“\\”）“转义”输入。子例程可用于收集公共代码或简化脚本的组织。 例如，执行包含以下内容的脚本文件： 123456789101112131415161718192021222324#!/bin/bash -norc parse_fields() &#123; echo \"$1\" | xtract -pattern Field \\ -pfx \"[\" -sfx \"]\" -element Name \\ -pfx \"\" -sfx \"\" -element FullName Description | sort -t $'\\t' -k 2,2f | column -s $'\\t' -t &#125; dbs=`einfo -dbs | sort` for db in $dbs do eix=`einfo -db $db` flds=`parse_fields \"$eix\"` echo \"$db\" echo \"\" echo \"$flds\" echo \"\" sleep 1 done 将获得Entrez数据库列表： 1234annotinfoassemblybioproject... 然后为每个单独的数据库返回索引搜索字段的缩写，名称和描述： 123456789101112131415161718... mesh [ALL] All Fields All terms from all searchable fields [FILT] Filter Limits the records [MESH] MeSH Terms MeSH Terms [MHUI] MeSH Unique ID NLM MeSH Browser Unique ID [MULT] Multi Multi [PREV] Previous Indexing Previous Indexing [TYPE] Record Type Record type [REG] Registry Number Registry Number [NOTE] Scope Note Scope Note [ALSO] See Also See Also [SUBS] Substance Name Substance Name [WORD] Text Word Free text [TN] Tree Number Tree Number [UID] UID Unique number assigned to publication ... shell脚本命令： 1sleep 1 在循环中的步骤之间添加一秒延迟，并可用于帮助防止高级脚本过度使用Entrez服务器。 Xargs/Sh Loop通过创造性地使用UNIX xargs和sh命令，有时可以避免编写脚本来循环遍历数据。在“sh -c”命令字符串中，姓氏和首字母参数（由“xargs -n 2”成对传递）在“$0”和“$1”变量中替换。sh字符串中的所有命令都在每个名称上单独运行： 123echo \"Garber ED Casadaban MJ Mortimer RK\" | xargs -n 2 sh -c 'esearch -db pubmed -query \"$0 $1 [AUTH]\" | xtract -pattern ENTREZ_DIRECT -lbl \"$1 $0\" -element Count' 这会为每位作者生成PubMed文章计数： 123ED Garber 35MJ Casadaban 46RK Mortimer 85 While Loop“while”循环也可用于独立处理数据行。给定一个包含genus-species名称的文件“organisms.txt”，UNIX“cat”命令： 1cat organisms.txt 写入文件的内容： 12345678Arabidopsis thalianaCaenorhabditis elegansDanio rerioDrosophila melanogasterEscherichia coliHomo sapiensMus musculusSaccharomyces cerevisiae 这可以通过管道连接到一次读取一行的循环： 1234567while read org do esearch -db taxonomy -query \"$org [LNGE] AND family [RANK]\" &lt; /dev/null | efetch -format docsum | xtract -pattern DocumentSummary -lbl \"$org\" \\ -element ScientificName Division done 查找每个生物的分类学姓氏和BLAST分部： 12345678Arabidopsis thaliana Brassicaceae eudicotsCaenorhabditis elegans Rhabditidae nematodesDanio rerio Cyprinidae bony fishesDrosophila melanogaster Drosophilidae fliesEscherichia coli Enterobacteriaceae enterobacteriaHomo sapiens Hominidae primatesMus musculus Muridae rodentsSaccharomyces cerevisiae Saccharomycetaceae ascomycetes （“&lt;/dev/null”输入重定向构造阻止esearch从stdin“排空”剩余的行。） For Loop嵌入“for”循环的生物体名称可以获得相同的结果： 123456789101112131415for org in \\ \"Arabidopsis thaliana\" \\ \"Caenorhabditis elegans\" \\ \"Danio rerio\" \\ \"Drosophila melanogaster\" \\ \"Escherichia coli\" \\ \"Homo sapiens\" \\ \"Mus musculus\" \\ \"Saccharomyces cerevisiae\" do esearch -db taxonomy -query \"$org [LNGE] AND family [RANK]\" | efetch -format docsum | xtract -pattern DocumentSummary -lbl \"$org\" \\ -element ScientificName Division done File Explorationfor循环也可用于浏览计算机的文件系统： 1234567for i in * do if [ -f \"$i\" ] then echo $(basename \"$i\") fi done 访问当前目录中的每个文件。星号（“”）字符表示所有文件，可以用任何模式（例如“.txt”）替换以限制文件搜索。 if语句“-f”运算符可以更改为“-d”以查找目录而不是文件，“ -s”选择大小大于零的文件。 Processing in Groups由于Entrez链接服务器中的技术限制，可能需要使用将唯一标识符或序列登录号拆分为较小组的函数对大量记录执行elink操作： 12345JoinIntoGroupsOf() &#123; xargs -n \"$@\" echo | sed 's/ /,/g' &#125; alias join-into-group-of='JoinIntoGroupsOf' 以下示例将一次处理200个加入的组中的序列记录： 123456... efetch -format acc | join-into-groups-of 200 | xargs -n 1 sh -c 'epost -db nuccore -format acc -id \"$0\" | elink -target pubmed | efetch -format abstract'","tags":[{"name":"生信","slug":"生信","permalink":"http://yoursite.com/tags/生信/"}]},{"title":"Entrez Direct--Advanced Topics","date":"2019-04-17T06:16:51.000Z","path":"2019/04/17/Entrez Direct--Advanced Topics/","text":"高级主题在别名文件中存储常用短语可以将长或复杂的搜索短语保存在文件中，以避免必须为每个查询重新键入（或复制和粘贴）全文。文件的每一行都有一个快捷键，一个制表符和一个扩展的搜索词。在使用井号（“＃”）前缀后，将它们放在括号中，以引用快捷方式。 例如，给定名为“q_aliases”的文件包含： 12jour_filt [MULT] AND ncbijournals [FILT]trans_imm (transposition OR target) immunity 在esearch语句中： 1234esearch -alias q_aliases -db nlmcatalog -query \"Science (#jour_filt)\" |efetch -format docsum |xtract -pattern DocumentSummary -element ISOAbbreviation \\ -subset ISSNInfo -sep \"|\" -element issn,issntype 将扩展开为： 1esearch -db nlmcatalog -query \"Science [MULT] AND ncbijournals [FILT]\" 查询生成： 1234J. Zhejiang Univ. Sci. 1009-3095|Print 1009-3095|LinkingJ King Saud Univ Sci 1018-3647|Print 2213-686X|Electronic 1018-3647|LinkingScience (80- ) 0193-4511|Print 0193-4511|LinkingScience 0036-8075|Print 1095-9203|Electronic 0036-8075|Linking 别名文件也可以在管道或脚本开头的单独指令中读取： 1eproxy -alias q_aliases 为了获得最大的灵活性，可以将单独的eproxy命令连接在一起以加载多个快捷方式文件，只要快捷方式字符串都是唯一的。 其他EDirect选项可以为ESearch和EFilter指定一个-sort参数来指定检索记录时的结果顺序： 123esearch -db pubmed -query \"opsin gene conversion\" -sort \"last author\" | efetch -format docsum | xtract -pattern DocumentSummary -element Id LastAuthor PubDate Title ELink可以使用“-name pubmed_pubmed_citedin”返回引用列表的链接，但仅适用于PubMed Central（PMC）中保留全文的出版物。例如，查询： 123456esearch -db pubmed -query \"Beadle GW [AUTH]\" | elink -related -name pubmed_pubmed_citedin | efetch -format docsum | xtract -pattern Author -element Name | sort-uniq-count-rank | head -n 10 生成十个被引用最多的作者的排名列表： 1234567891014 Hawley RS13 Beadle GW9 Glass NL8 Ephrussi B7 Mitchell MB7 PERKINS DD7 Tatum EL6 Miller DE6 Mitchell HK6 Sekelsky J 类似地，“ -name pubmed_pubmed_refs”再次返回文章的引用列表，对于存放在PMC中的出版物也是如此。 ELink有几种命令模式，可以使用-cmd参数指定这些模式。当不使用默认的“neighbor_history”命令时，elink将返回一个eLinkResult XML对象，每个UID的链接在不同的块中显示。例如： 123esearch -db pubmed -query \"Hoffmann PC [AUTH] AND dopamine [MAJR]\" | elink -related -cmd neighbor | xtract -pattern LinkSetDb -element Id 将在后续列中显示第一列中的原始PMID和相关文章PMID： 12341504781 11754494 3815119 1684029 14614914 12128255 ...1684029 3815119 1504781 8097798 17161385 14755628 ...2572612 2903614 6152036 2905789 9483560 1352865 ...... 当elink命令“prlinks”与“ref”模式一起使用时，它可以直接从发布者获取包含或引用全文文章的HTML。 UNIX“xargs”命令为每个标识符分别调用elink： 1234epost -db pubmed -id 22966225,19880848 | efilter -query \"freetext [FILT]\" | efetch -format uid | xargs -n 1 elink -db pubmed -cmd prlinks -mode ref -http get -id elink -batch标志将绕过大型查询的Entrez历史记录机制。 Xtract专题标准格式的自闭标签： 1&lt;Na-strand/&gt; 或替代形式： 1&lt;Na-strand&gt;&lt;/Na-strand&gt; 没有文本内容，因此无法使用-element命令进行选择。如果标记包含属性： 123&lt;Seq-interval_strand&gt; &lt;Na-strand value=\"plus\"/&gt; &lt;/Seq-interval_strand&gt; 它可以通过匹配指定的值来选择： 123-group Seq-interval_strand \\ -block Seq-interval_strand -if Na-strand@value -equals plus -lbl \"+\" \\ -block Seq-interval_strand -if Na-strand@value -equals minus -lbl \"-\" -pattern，-group，-block和-subset命令提供了一个嵌套的循环组织器层次结构，用于探索XML对象。每个模式可以包含多个组，每个组可以包含多个块，并且每个块可以具有多个子集。 使用不同的参数名称允许循环嵌套的线性表示，并提供足够的灵活性来从Entrez中的XML记录中识别和提取任意数据。 在伪代码中绘制草图可以阐明相对嵌套级别。提取命令： 123456xtract -pattern PubmedArticle \\ -block Author -element Initials,LastName \\ -block MeshHeading \\ -if QualifierName \\ -element DescriptorName \\ -subset QualifierName -element QualifierName 可以用伪代码表示为计算机程序： 12345678910111213for each Pubmed record &#123; for each Author &#123; print Initials LastName &#125; for each MeSH term &#123; if Subheadings are present &#123; print Term Name for each Subheading &#123; print Subheading Name &#125; &#125; &#125; &#125; 额外的参数（-division，-branch，-section和-unit）保留用于提供额外的组织级别，如果将来需要处理复杂的，深度嵌套的XML数据。按排名顺序排列的完整命令是： 12345678-pattern-division-group-branch-block-section-subset-unit 使用-block启动xtract探索，并使用-group和-subset进行扩展，会留下可在任何需要的地方使用的其他级别名称，而无需重新设计整个命令。 查询外部Web服务EDirect nquire函数可用于从任意URL获取数据。查询是从命令行参数构建的。例如： 12nquire -url \"https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi\" \\ -db pubmed -term insulin 读取URL然后标记/值对以生成电子实用程序查询： 1https://eutils. ... .gov/entrez/eutils/esearch.fcgi?db=pubmed&amp;term=insulin 路径可以分为组件，与斜杠组合，因此： 1-url https://eutils.ncbi.nlm.nih.gov entrez/eutils efetch.fcgi 转换为： 1https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi 标签之间的多个值与逗号组合。从而： 1-db nuccore -id U54469 V00328 -rettype fasta 转化为： 1db=nuccore&amp;id=U54469,V00328&amp;rettype=fasta 以连字符（或减号）开头的值可以通过在其前面添加反斜杠来区分标记，因此： 1nquire -url http://api.geonames.org/countryCode -lat 41.796 -lng \"\\-87.577\" 将被发送为： 1http://api.geonames.org/countryCode?lat=41.796&amp;lng=-87.577 并且将返回“US”作为芝加哥内部的坐标，其具有负（西半球）经度值。 -alias参数可以读取快捷键和URL别名的文件。以下别名始终可用： 12ncbi_url https://www.ncbi.nlm.nih.gov eutils_url https://eutils.ncbi.nlm.nih.gov/entrez/eutils 所以命令： 12nquire -url \"(#eutils_url)\" esearch.fcgi \\ -db gds -term \"GSE22309 [ACCN] AND gse [ETYP]\" -retmax 200 将运行ESearch查询并返回eSearchResult XML对象。 可以重新格式化具有不一致的换行和缩进的原始XML，以便通过管道传输来更容易地目视检查数据结构和内容： 1xtract -format","tags":[{"name":"生信","slug":"生信","permalink":"http://yoursite.com/tags/生信/"}]},{"title":"Entrez Direct--Complex Objects","date":"2019-04-17T02:46:51.000Z","path":"2019/04/17/Entrez Direct--Complex Objects/","text":"复杂对象异构数据XML对象可以包含异构的组件组合。例如： 1efetch -db pubmed -id 21433338,17247418 -format xml 返回书籍和期刊记录的混合： 123456789101112&lt;PubmedArticleSet&gt; &lt;PubmedBookArticle&gt; &lt;BookDocument&gt; ... &lt;/PubmedBookData&gt; &lt;/PubmedBookArticle&gt; &lt;PubmedArticle&gt; &lt;MedlineCitation&gt; ... &lt;/PubmedData&gt; &lt;/PubmedArticle&gt;&lt;/PubmedArticleSet&gt; “Parent/*”构造用于访问各个组件，即使它们可能具有不同的名称。将XML输出管道化为： 1xtract -pattern \"PubmedArticleSet/*\" -element \"*\" 单独打印每个XML组件的全部内容： 12&lt;PubmedBookArticle&gt;&lt;BookDocument&gt; ... &lt;/PubmedBookData&gt;&lt;/PubmedBookArticle&gt;&lt;PubmedArticle&gt;&lt;MedlineCitation&gt; ... &lt;/PubmedData&gt;&lt;/PubmedArticle&gt; 使用“父/子”构造可以隔离具有相同名称的对象，这些对象因其在XML层次结构中的位置而不同。例如： 12345efetch -db pubmed -id 21433338,17247418 -format xml |xtract -pattern \"PubmedArticleSet/*\" \\ -group \"BookDocument/AuthorList\" -tab \"\\n\" -element LastName \\ -group \"Book/AuthorList\" -tab \"\\n\" -element LastName \\ -group \"Article/AuthorList\" -tab \"\\n\" -element LastName 为书/章作者，书籍编辑和文章作者写单独的行： 123Fauci DesrosiersCoffin Hughes VarmusLederberg Cavalli Lederberg 只需用个别参数进行探索： 1-group BookDocument -block AuthorList -element LastName 将访问编辑器（在BookDocument / Book / AuthorList）以及作者（在BookDocument / AuthorList），并按照XML中的外观顺序打印名称： 1Coffin Hughes Varmus Fauci Desrosiers （在这个特定的例子中，书籍作者列表可以通过使用-if“@Type”-equals作者或-if“@Type”-equals编辑器来区分，但是通过“父/子”进行探索是一种基于位置的一般方法。 ） 递归定义由efetch返回的某些XML对象是递归定义的，包括TaxaSet中的Taxon（-db分类法）和Entrezgene中的Gene-commentary（-db gene）。因此，它们可以具有相同XML标记的嵌套对象。 检索一组分类记录： 1efetch -db taxonomy -id 9606,7227 -format xml 对于分类谱系中的每个等级，使用嵌套的Taxon对象（下面标有行引用）生成XML： 1234567891011121314151617181920212223242526 &lt;TaxaSet&gt;1 &lt;Taxon&gt; &lt;TaxId&gt;9606&lt;/TaxId&gt; &lt;ScientificName&gt;Homo sapiens&lt;/ScientificName&gt; ... &lt;LineageEx&gt;2 &lt;Taxon&gt; &lt;TaxId&gt;131567&lt;/TaxId&gt; &lt;ScientificName&gt;cellular organisms&lt;/ScientificName&gt; &lt;Rank&gt;no rank&lt;/Rank&gt;3 &lt;/Taxon&gt;4 &lt;Taxon&gt; &lt;TaxId&gt;2759&lt;/TaxId&gt; &lt;ScientificName&gt;Eukaryota&lt;/ScientificName&gt; &lt;Rank&gt;superkingdom&lt;/Rank&gt;5 &lt;/Taxon&gt; ... &lt;/LineageEx&gt; ...6 &lt;/Taxon&gt;7 &lt;Taxon&gt; &lt;TaxId&gt;7227&lt;/TaxId&gt; &lt;ScientificName&gt;Drosophila melanogaster&lt;/ScientificName&gt; ...8 &lt;/Taxon&gt; &lt;/TaxaSet&gt; Xtract跟踪XML对象嵌套，以确定第1行的开始标记实际上是由第6行的&lt;/ Taxon&gt;停止标记关闭，而不是第3行遇到的第一个&lt;/ Taxon&gt;。 当一个递归对象被赋予一个探索命令时，使用-element命令选择数据： 123efetch -db taxonomy -id 9606,7227,10090 -format xml |xtract -pattern Taxon \\ -element TaxId ScientificName GenbankCommonName Division 不检查内部对象中的字段，仅返回主条目的信息： 1239606 Homo sapiens human Primates7227 Drosophila melanogaster fruit fly Invertebrates10090 Mus musculus house mouse Rodents “*/Child”构造将跳过外部开始标记： 123efetch -db taxonomy -id 9606,7227,10090 -format xml |xtract -pattern Taxon -block \"*/Taxon\" \\ -tab \"\\n\" -element TaxId,ScientificName 单独访问下一级嵌套对象： 12345131567 cellular organisms2759 Eukaryota33154 Opisthokonta33208 Metazoa... 可以使用双星斜杠前缀完全探索递归对象： 1234esearch -db gene -query \"DMD [GENE] AND human [ORGN]\" |efetch -format xml |xtract -pattern Entrezgene -block \"**/Gene-commentary\" \\ -tab \"\\n\" -element Gene-commentary_type@value,Gene-commentary_accession 无论嵌套深度如何，它都会访问每个子对象： 123456789genomic NC_000023mRNA XM_006724469peptide XP_006724532mRNA XM_011545467peptide XP_011543769mRNA XM_006724473peptide XP_006724536mRNA XM_006724475...","tags":[{"name":"生信","slug":"生信","permalink":"http://yoursite.com/tags/生信/"}]},{"title":"Entrez Direct--Sequence Coordinates","date":"2019-04-17T01:44:42.000Z","path":"2019/04/17/Entrez Direct--Sequence Coordinates/","text":"序列坐标基因位置为了使用基因位置通过efetch或UCSC浏览器检索相应的染色体子区域，必须理解序列坐标约定。 以GenBank或​​GenPept格式显示的序列记录使用“基于一个”的坐标系，序列位置编号从“1”开始： 12345 1 catgccattc gttgagttgg aaacaaactt gccggctagc cgcatacccg cggggctgga 61 gaaccggctg tgtgcggcca cagccaccat cctggacaaa cccgaagacg tgagtgaggg 121 tcggcgagaa cttgtgggct agggtcggac ctcccaatga cccgttccca tccccaggga 181 ccccactccc ctggtaacct ctgaccttcc gtgtcctatc ctcccttcct agatcccttc ... 根据这个惯例，位置是指序列字母本身： C A T G C C A T T C. 1 2 3 4 5 6 7 8 9 10并且最后一个碱基或残基的位置等于序列的长度。上述ATG起始密码子位于2至4位，包括端点。 但是，对于计算机程序，使用“从零开始”的坐标可以简化用于计算序列位置的算术。基于0的表示中的ATG密码子位于1到3位置。（UCSC浏览器使用混合半开表示，其中起始位置从0开始，停止位置从1开始。） NCBI的软件通常在输入时将位置转换为0坐标，执行所需的任何计算，然后将结果转换为基于1的表示以进行显示。通过简单地从基于1的值中减去1或将基数加到1来完成这些变换。 协调转换检索特定基因的文档： 12esearch -db gene -query \"BRCA2 [GENE] AND human [ORGN]\" | efetch -format docsum 以0为基础的坐标返回该基因的染色体位置： 123456789 ... &lt;GenomicInfoType&gt; &lt;ChrLoc&gt; 13 &lt;/ ChrLoc&gt; &lt;ChrAccVer&gt; NC_000013.11 &lt;/ ChrAccVer&gt; &lt;ChrStart&gt; 32315479 &lt;/ ChrStart&gt; &lt;ChrStop&gt; 32399671 &lt;/ ChrStop&gt; &lt;ExonCount&gt; 27 &lt;/ ExonCount&gt; &lt;/ GenomicInfoType&gt; ... 将文档摘要管道化为xtract命令： 1xtract -pattern GenomicInfoType -element ChrAccVer ChrStart ChrStop 获取加入的和基于0的坐标值： 1NC_000013.11 32315479 32399671 EFetch具有-seq_start和-seq_stop参数来检索基因片段，但是这些参数希望序列子范围在基于1的坐标中。 为解决此问题，另外两个efetch参数-chr_start和-chr_stop允许直接使用基于0的坐标： 12efetch -db nuccore -format gb -id NC_000013.11 \\ -chr_start 32315479 -chr_stop 32399671 并且无需编写UNIX shell命令来增加两个值。 Xtract具有数字提取命令以协助进行坐标转换。使用-inc参数选择字段： 1xtract -pattern GenomicInfoType -element ChrAccVer -inc ChrStart ChrStop 获取入口和基于0的坐标，然后递增位置以生成从1开始的值： 1NC_000013.11 32315480 32399672 EDirect了解所有相关Entrez数据库（例如，gene，snp，dbvar）中序列位置的策略，并提供了将这些转换为其他约定的其他快捷方式。例如： 1xtract -pattern GenomicInfoType -element ChrAccVer -1-based ChrStart ChrStop 了解基因ChrStart和ChrStop字段是基于0的，看到所需的输出是基于1的，并转换命令以使用-inc参数转换坐标。同理： 1-element ChrAccVer -ucsc-based ChrStart ChrStop 保留基于0的起始值不变但增加原始停止值以生成可以传递给UCSC浏览器的半开放表单： 1NC_000013.11 32315479 32399672","tags":[{"name":"生信","slug":"生信","permalink":"http://yoursite.com/tags/生信/"}]},{"title":"Entrez Direct--Sequence Records","date":"2019-04-16T07:44:42.000Z","path":"2019/04/16/Entrez Direct--Sequence Records/","text":"序列记录用于序列记录的NCBI数据模型NCBI代表基于分子生物学中心法则的数据模型中的序列记录。序列，包括基因组DNA，信使RNA和蛋白质产物，用实际的序列字母“实例化”，并且被分配标识符（例如，登录号）以供参考。特征携带关于给定区域的生物学的信息，其具有涉及特定序列的特定间隔的位置。某些特征也可能指向特定变换的产品序列。 基因特征指示可遗传的核酸区域的位置，其赋予可测量的表型。基因组DNA上的mRNA特征代表在转录和剪接后保留的信息的外显子和非翻译区。编码区（CDS）特征具有对翻译的蛋白质的产物参考。 由于信使RNA序列并不总是与基因组区域一起提交，因此CDS特征（其模拟核糖体在转录物分子上的行程）传统上在基因组序列上注释，具有编码外显子区间的位置。 功能在限定符中显示特定的生物注释。例如，基因的名称显示在/gene限定符中。为了方便用户，可以从底层数据动态生成限定符。因此，成熟肽的序列可以从前体蛋白上的mat_peptide特征的位置提取并显示在/肽限定符中，即使未实例化成熟肽。 INSDSeq XML中的序列记录可以在GenBank或​​GenPept平面文件的XML版本中检索序列记录。查询： 1efetch -db protein -id 26418308,26418074 -format gpc 返回一组INSDSeq对象： 1234567891011121314151617181920212223&lt;INSDSet&gt; &lt;INSDSeq&gt; &lt;INSDSeq_locus&gt;AAN78128&lt;/INSDSeq_locus&gt; &lt;INSDSeq_length&gt;17&lt;/INSDSeq_length&gt; &lt;INSDSeq_moltype&gt;AA&lt;/INSDSeq_moltype&gt; &lt;INSDSeq_topology&gt;linear&lt;/INSDSeq_topology&gt; &lt;INSDSeq_division&gt;INV&lt;/INSDSeq_division&gt; &lt;INSDSeq_update-date&gt;24-JUL-2016&lt;/INSDSeq_update-date&gt; &lt;INSDSeq_create-date&gt;10-DEC-2002&lt;/INSDSeq_create-date&gt; &lt;INSDSeq_definition&gt;alpha-conotoxin ImI precursor, partial [Conus imperialis]&lt;/INSDSeq_definition&gt; &lt;INSDSeq_primary-accession&gt;AAN78128&lt;/INSDSeq_primary-accession&gt; &lt;INSDSeq_accession-version&gt;AAN78128.1&lt;/INSDSeq_accession-version&gt; &lt;INSDSeq_other-seqids&gt; &lt;INSDSeqid&gt;gb|AAN78128.1|&lt;/INSDSeqid&gt; &lt;INSDSeqid&gt;gi|26418308&lt;/INSDSeqid&gt; &lt;/INSDSeq_other-seqids&gt; &lt;INSDSeq_source&gt;Conus imperialis&lt;/INSDSeq_source&gt; &lt;INSDSeq_organism&gt;Conus imperialis&lt;/INSDSeq_organism&gt; &lt;INSDSeq_taxonomy&gt;Eukaryota; Metazoa; Lophotrochozoa; Mollusca; Gastropoda; Caenogastropoda; Hypsogastropoda; Neogastropoda; Conoidea; Conidae; Conus&lt;/INSDSeq_taxonomy&gt; &lt;INSDSeq_references&gt; &lt;INSDReference&gt; ... INSDSeq XML提供生物特征和限定符（此处以GenPept格式显示）： 12345678910111213141516FEATURES Location/Qualifiers source 1..17 /organism=\"Conus imperialis\" /db_xref=\"taxon:35631\" /country=\"Philippines\" Protein &lt;1..17 /product=\"alpha-conotoxin ImI precursor\" mat_peptide 5..16 /product=\"alpha-conotoxin ImI\" /note=\"the C-terminal glycine of the precursor is post translationally removed\" /calculated_mol_wt=1357 /peptide=\"GCCSDPRCAWRC\" CDS 1..17 /coded_by=\"AY159318.1:&lt;1..54\" /note=\"nAChR antagonist\" 在结构化功能表中： 1234567891011121314151617181920212223242526272829303132...&lt;INSDFeature&gt; &lt;INSDFeature_key&gt;mat_peptide&lt;/INSDFeature_key&gt; &lt;INSDFeature_location&gt;5..16&lt;/INSDFeature_location&gt; &lt;INSDFeature_intervals&gt; &lt;INSDInterval&gt; &lt;INSDInterval_from&gt;5&lt;/INSDInterval_from&gt; &lt;INSDInterval_to&gt;16&lt;/INSDInterval_to&gt; &lt;INSDInterval_accession&gt;AAN78128.1&lt;/INSDInterval_accession&gt; &lt;/INSDInterval&gt; &lt;/INSDFeature_intervals&gt; &lt;INSDFeature_quals&gt; &lt;INSDQualifier&gt; &lt;INSDQualifier_name&gt;product&lt;/INSDQualifier_name&gt; &lt;INSDQualifier_value&gt;alpha-conotoxin ImI&lt;/INSDQualifier_value&gt; &lt;/INSDQualifier&gt; &lt;INSDQualifier&gt; &lt;INSDQualifier_name&gt;note&lt;/INSDQualifier_name&gt; &lt;INSDQualifier_value&gt;the C-terminal glycine of the precursor is post translationally removed&lt;/INSDQualifier_value&gt; &lt;/INSDQualifier&gt; &lt;INSDQualifier&gt; &lt;INSDQualifier_name&gt;calculated_mol_wt&lt;/INSDQualifier_name&gt; &lt;INSDQualifier_value&gt;1357&lt;/INSDQualifier_value&gt; &lt;/INSDQualifier&gt; &lt;INSDQualifier&gt; &lt;INSDQualifier_name&gt;peptide&lt;/INSDQualifier_name&gt; &lt;INSDQualifier_value&gt;GCCSDPRCAWRC&lt;/INSDQualifier_value&gt; &lt;/INSDQualifier&gt; &lt;/INSDFeature_quals&gt;&lt;/INSDFeature&gt;... 功能和限定符名称在数据值中指示，而不是XML元素标记，并且需要-if和-equals来选择所需的对象和内容。 xtract -insd参数简化了此过程，如下所示。 生成限定符提取命令因为从INSDSeq XML获取特定限定符值比以前的情况稍微复杂一些，所以xtract -insd参数可用于生成提取指令。 在单独的命令中运行xtract -insd会打印一个新的xtract语句，然后可以在必要时对其进行复制，编辑并粘贴到其他查询中。在多步骤管道中运行-insd命令可动态执行构造的查询。 提供可选（完整/部分）位置指示，功能键，然后提供一个或多个限定符名称： 1xtract -insd complete mat_peptide \"%peptide\" product peptide 创建一个新的xtract语句，该语句将生成具有完整位置的成熟肽特征的限定符值表。该语句以记录加入和查找指定类型的功能的说明开头： 1234xtract -pattern INSDSeq -ACCN INSDSeq_accession-version \\ -group INSDFeature -if INSDFeature_key -equals mat_peptide \\ -unless INSDFeature_partial5 -or INSDFeature_partial3 \\ -clr -pfx \"\\n\" -element \"&amp;ACCN\" 然后，每个限定符都会生成附加到不断增长的查询中的自定义提取代码。例如： 123-block INSDQualifier \\ -if INSDQualifier_name -equals peptide \\ -element INSDQualifier_value 在海洋蜗牛毒肽的查询中加入xtract -insd命令： 12345esearch -db pubmed -query \"conotoxin\" |elink -target protein |efilter -query \"mat_peptide [FKEY]\" |efetch -format gpc |xtract -insd complete mat_peptide \"%peptide\" product peptide 生成一个表格，其中包含登录号，计算肽长度，产品名称和肽序列的列： 123456789AGO59814.1 32 del13b conotoxin DCPTSCPTTCANGWECCKGYPCVRQHCSGCNHAAO33169.1 16 alpha-conotoxin GIC GCCSHPACAGNNQHICADB65788.1 20 conotoxin Cal 16 LEMQGCVCNANAKFCCGEGRAAN78128.1 12 alpha-conotoxin ImI GCCSDPRCAWRCAAF23167.1 31 BeTX toxin CRAEGTYCENDSQCCLNECCWGGCGHPCRHPADB65789.1 20 conotoxin Cal 16 LEMQGCVCNANAKFCCGEGRAAN78279.1 21 conotoxin Vx-II WIDPSHYCCCGGGCTDDCVNCABW16858.1 15 marmophin DWEYHAHPKPNSFWT... 将结果管道化为一系列UNIX命令： 123456grep -i conotoxin |awk -F '\\t' -v 'OFS=\\t' '&#123;if ( 10 &lt;= $2 &amp;&amp; $2 &lt;= 30 ) print&#125;' |sort -t $'\\t' -u -k 3,4 |sort -t $'\\t' -k 2,2n -k 3,3f |cut -f 1,3- |column -s $'\\t' -t 按产品名称过滤，将结果限制为指定的肽段长度，删除多余的加入，按肽长度对表格进行排序，删除长度列，并对齐列以进行更清晰的打印： 12345678910111213141516171819202122232425AAN78128.1 alpha-conotoxin ImI GCCSDPRCAWRCAAN78127.1 alpha-conotoxin ImII ACCSDRRCRWRCADB43130.1 conotoxin Cal 1a KCCKRHHGCHPCGRKADB43131.1 conotoxin Cal 1b LCCKRHHGCHPCGRTAAO33169.1 alpha-conotoxin GIC GCCSHPACAGNNQHICADB43128.1 conotoxin Cal 5.1 DPAPCCQHPIETCCRRAAD31913.1 alpha A conotoxin Tx2 PECCSHPACNVDHPEICRADB43129.1 conotoxin Cal 5.2 MIQRSQCCAVKKNCCHVGADD97803.1 conotoxin Cal 1.2 AGCCPTIMYKTGACRTNRCRADB65789.1 conotoxin Cal 16 LEMQGCVCNANAKFCCGEGRAAD31912.1 alpha A conotoxin Tx1 PECCSDPRCNSSHPELCGGRRAAN78279.1 conotoxin Vx-II WIDPSHYCCCGGGCTDDCVNCADB43125.1 conotoxin Cal 14.2 GCPADCPNTCDSSNKCSPGFPGADD97802.1 conotoxin Cal 6.4 GCWLCLGPNACCRGSVCHDYCPRCAH64846.1 four-loop conotoxin CRPSGSPCGVTSICCGRCSRGKCTAAD31915.1 O-superfamily conotoxin TxO2 CYDSGTSCNTGNQCCSGWCIFVCLAAD31916.1 O-superfamily conotoxin TxO3 CYDGGTSCDSGIQCCSGWCIFVCFAAD31920.1 omega conotoxin SVIA mutant 1 CRPSGSPCGVTSICCGRCYRGKCTAAD31921.1 omega conotoxin SVIA mutant 2 CRPSGSPCGVTSICCGRCSRGKCTABE27010.1 conotoxin fe14.1 SPGSTICKMACRTGNGHKYPFCNCRABE27011.1 conotoxin fe14.2 SSGSTVCKMMCRLGYGHLYPSCGCRABE27007.1 conotoxin p114.1 GPGSAICNMACRLGQGHMYPFCNCNABE27008.1 conotoxin p114.2 GPGSAICNMACRLEHGHLYPFCHCRABE27009.1 conotoxin p114.3 GPGSAICNMACRLEHGHLYPFCNCD... 对于缺少特定限定符的记录： 1234esearch -db protein -query \"RAG1 [GENE] AND Mus musculus [ORGN]\" |efetch -format gpc |xtract -insd source organism strain |sort -t $'\\t' -u -k 2,3 短划线作为占位符插入： 12345678P15919.2 Mus musculus -AAO61776.1 Mus musculus 129/SvNP_033045.2 Mus musculus C57BL/6XP_006499075.1 Mus musculus C57BL/6JEDL27655.1 Mus musculus mixedBAD69530.1 Mus musculus castaneus -BAD69531.1 Mus musculus domesticus BALB/cBAD69532.1 Mus musculus molossinus MOA","tags":[{"name":"生信","slug":"生信","permalink":"http://yoursite.com/tags/生信/"}]},{"title":"Entrez Direct--Structured Data","date":"2019-04-12T07:44:42.000Z","path":"2019/04/12/Entrez Direct--Structured Data/","text":"数据结构XML格式的优点能够以结构化XML格式获取Entrez记录并轻松提取基础数据，使用户能够提出现有分析软件无法解决的新问题。 XML的优点是许多信息都位于定义明确的数据层次结构中的特定位置。访问按名称提供的各个数据单元，例如： 12345&lt;PubDate&gt;2013&lt;/PubDate&gt; &lt;Source&gt;PLoS One&lt;/Source&gt; &lt;Volume&gt;8&lt;/Volume&gt; &lt;Issue&gt;3&lt;/Issue&gt; &lt;Pages&gt;e58144&lt;/Pages&gt; 需要匹配相同的通用模式，仅由元素名称不同。这比从长而复杂的字符串解析单位要简单得多： 11. PLoS One. 2013;8(3):e58144 ... XML的缺点是数据提取通常需要编程。但是EDirect依赖于XML值表示的通用模式来提供解释XML数据的简化方法。 将XML数据转换为表格形式xtract函数使用命令行参数来指导XML数据的选择性转换为制表符分隔的表。 -pattern参数将结果划分为行，而将数据放入列中则由-element控制。一个简单的例子： 1 xtract -pattern ENTREZ_DIRECT -element Count 将打印当前查询中的记录数。 Xtract使用单独的参数进行元素选择，路径探索，条件处理和报告格式化，使用分而治之策略来控制数据转换。 元素选择查找每个指示项目的每次出现，在遇到它们时打印值。探索控制限制按上下文选择，一次呈现一个指定的对象。条件处理按内容过滤，要求存在（或不存在）特定数据值以便继续。最后，自定义格式可以覆盖默认输出的常规表格布局。 本节其余部分将讨论这种灵活方法的细节和分支。 提取参数选择参数（-element，-first和-last）从指示的元素名称中提取和打印数据值： 1-element Id -first Name Title 探测参数（-pattern，-group，-block和-subset）将数据提取限制为XML的指定区域，一次访问一个所有相关对象。这为数据收集设置了上下文，消除了提供数据元素的完整路径的需要，并从“在哪里找到它”中提升为“寻找什么”的概念： 12-pattern DocumentSummary -block Author 每个模式可以有多个组，每个组可以有多个块，每个块可以有多个子集。此设计允许嵌套探索复杂的分层数据，这些数据由命令行参数语句的线性链控制。 条件处理参数按对象名称和值（-if和-unless）或项目位置（-position）限制探索语句： 12-if Source -equals \"J Bacteriol\"-position first 这些命令在探测参数后立即发出。 格式化参数（-ret，-tab，-sep，-pfx，-sfx和-def）允许对默认行/列表显示进行大量自定义： 1-pfx \"\\n[\" -sfx \"]\\t\" -sep \" \" -tab \"\" -ret \"\\n\\n\" -def \"-\" 并适用于后续的选择陈述。（“\\n”转义序列表示换行符，而“\\t”指定制表符。） XML文档摘要Entrez为每条记录提供结构化XML格式的文档摘要。将查询管道化为“efetch -format docsum”： 1234esearch -db pubmed -query \"Garber ED [AUTH] AND PNAS [JOUR]\" |elink -related |efilter -query \"mouse\" |efetch -format docsum 将生成XML文档摘要集： 12345678910111213141516171819202122232425262728293031323334&lt;DocumentSummarySet status=\"OK\"&gt;&lt;DocumentSummary&gt;&lt;Id&gt;19650888&lt;/Id&gt; &lt;PubDate&gt;2009 Aug 3&lt;/PubDate&gt; &lt;EPubDate&gt;2009 Aug 3&lt;/EPubDate&gt; &lt;Source&gt;BMC Microbiol&lt;/Source&gt; &lt;Authors&gt; &lt;Author&gt; &lt;Name&gt;Cano V&lt;/Name&gt; &lt;AuthType&gt;Author&lt;/AuthType&gt; &lt;ClusterID&gt;&lt;/ClusterID&gt; &lt;/Author&gt; &lt;Author&gt; &lt;Name&gt;Moranta D&lt;/Name&gt; &lt;AuthType&gt;Author&lt;/AuthType&gt; &lt;ClusterID&gt;&lt;/ClusterID&gt; &lt;/Author&gt; &lt;Author&gt; &lt;Name&gt;Llobet-Brossa E&lt;/Name&gt; &lt;AuthType&gt;Author&lt;/AuthType&gt; &lt;ClusterID&gt;&lt;/ClusterID&gt; &lt;/Author&gt; &lt;Author&gt; &lt;Name&gt;Bengoechea JA&lt;/Name&gt; &lt;AuthType&gt;Author&lt;/AuthType&gt; &lt;ClusterID&gt;&lt;/ClusterID&gt; &lt;/Author&gt; &lt;Author&gt; &lt;Name&gt;Garmendia J&lt;/Name&gt; &lt;AuthType&gt;Author&lt;/AuthType&gt; &lt;ClusterID&gt;&lt;/ClusterID&gt; &lt;/Author&gt; &lt;/Authors&gt; ... 将文档摘要管道输出到： 1xtract -outline 将给出XML层次结构的缩进概述： 1234567891011121314DbBuild DocumentSummary Id PubDate EPubDate Source Authors Author Name AuthType ClusterID Author Name ... 大纲视图提供了一个清晰，整洁的XML层次结构图，可用于设计适当的实际数据提取命令。从-outline输出复制并粘贴到xtract参数可以帮助避免印刷错误。从而： 12345esearch -db pubmed -query \"Garber ED [AUTH] AND PNAS [JOUR]\" | elink -related | efilter -query \"mouse\" | efetch -format docsum | xtract -pattern DocumentSummary -element Id SortFirstAuthor Title 返回PubMed标识符（PMID），第一作者姓名和文章标题： 12345619650888 Cano V Klebsiella pneumoniae triggers a cytotoxic effect on airway epithelial cells.19248821 Fukumoto N Hypoalgesic behaviors of P/Q-type voltage-gated Ca2+ channel mutant mouse, rolling mouse Nagoya.18822497 Trishin AV [Protective activity of secreted proteins of Streptococcus pneumoniae and Klebsiella pneumoniae].18486404 Yu WL Comparison of prevalence of virulence factors for Klebsiella pneumoniae liver abscesses between isolates with capsular K1/K2 and non-K1/K2 serotypes.18433330 Hsieh PF Serum-induced iron-acquisition systems and TonB contribute to virulence in Klebsiella pneumoniae causing primary pyogenic liver abscess.... 使用xtract“-synopsis”而不是-outline显示每个元素的完整路径。将这些结果管道化为“sort-uniq-count”（见下文）会生成一个唯一路径计数表。 使用UNIX实用程序处理结果许多UNIX实用程序可以处理制表符分隔的表。例如： 123456esearch -db pubmed -query \"Garber ED [AUTH] AND PNAS [JOUR]\" | elink -related | efilter -query \"mouse\" | efetch -format docsum | xtract -pattern DocumentSummary -element Id SortFirstAuthor Title | sort -t $'\\t' -k 2,2f -k 3,3f 按作者名称排序前一个示例的结果，然后按标题按字母顺序排序（如果同一作者有多个出版物）： 12345617474906 Benghezal M Inhibitors of bacterial virulence identified in a surrogate host model.19650888 Cano V Klebsiella pneumoniae triggers a cytotoxic effect on airway epithelial cells.17102561 Chatterjee S How reliable are models for malaria vaccine development? Lessons from irradiated sporozoite immunizations.17142396 Fresno S A second galacturonic acid transferase is required for core lipopolysaccharide biosynthesis and complete capsule association with the cell surface in Klebsiella pneumoniae.16735743 Fresno S The ionic interaction of Klebsiella pneumoniae K2 capsule and core lipopolysaccharide.... 不必总是重新键入一系列常见的后处理指令，经常使用的UNIX命令组合可以放在一个函数中，存储在别名文件（例如用户的.bash_profile）中，并按名称执行。 （以下两个函数现在作为脚本包含在EDirect软件中。）例如： 1234567891011121314WordAtATime() &#123; sed 's/[^a-zA-Z0-9]/ /g; s/^ *//' | tr 'A-Z' 'a-z' | fmt -w 1 &#125; alias word-at-a-time='WordAtATime' SortUniqCountRank() &#123; sort -f | uniq -i -c | perl -pe 's/\\s*(\\d+)\\s(.+)/$1\\t$2/' | sort -t $'\\t' -k 1,1nr -k 2f &#125; alias sort-uniq-count-rank='SortUniqCountRank' 标题可以传递给一对这些UNIX别名命令： 123456esearch -db pubmed -query \"Casadaban transposition immunity\" | elink -related | efetch -format docsum | xtract -pattern DocumentSummary -element Title | word-at-a-time | sort-uniq-count-rank 生成一个单词出现次数表，按频率排序： 1234567891011250 of141 the103 transposition82 and81 mu76 in62 a59 tn345 dna42 for39 transposon 输出格式自定义-pattern对象之间的换行符可以用-ret覆盖，字段之间的制表符可以用-tab替换。 -sep参数用于区分同一类型的多个元素，并独立于-tab参数控制它们的分隔。例如： 12345esearch -db gene -query \"deuteranopia\" | efetch -format xml | xtract -pattern Entrezgene \\ -element Gene-track_geneid Gene-ref_locus \\ -sep \"|\" -element Gene-ref_syn_E 将基因的所有同义词组合成一个列，由竖线分隔： 1235956 OPN1LW CBP|RCP|ROP|CBBM|COD52652 OPN1MW CBD|GCP|GOP|CBBM|COD5|OPN1MW1611 OPN1SW BCP|BOP|CBT -sep值也适用于以逗号分组的不相关元素项。否则，-tab值描述各个字段。 组或字段前面带有-pfx值，后跟-sfx值，这两个值最初都是空的。 可以使用-def参数标记缺少的数据值。例如： 1234esearch -db pubmed -query \"deuteranopia\" |efetch -format xml |xtract -pattern PubmedArticle -def \"-\" \\ -first MedlineCitation/PMID Author/LastName Keyword 在缺少指定元素的列中插入破折号。 Pubmed Article XML RecordsPubmedArticle对象（对于-db pubmed）具有比DocumentSummary更详细的结构： 123esearch -db pubmed -query \"tetrachromacy\" | efetch -format xml | xtract -outline 提供更多信息，包括作者姓名，日期和摘要： 123456789101112131415161718192021222324252627282930313233343536373839PubmedArticle MedlineCitation PMID DateCompleted Year Month Day DateRevised Year Month Day Article Journal ISSN JournalIssue Volume Issue PubDate Year Month Day Title ISOAbbreviation ArticleTitle Pagination MedlinePgn Abstract AbstractText CopyrightInformation AuthorList Author LastName ForeName Initials AffiliationInfo Affiliation Author LastName ... 使用此信息来创建新的xtract语句： 123esearch -db pubmed -query \"tetrachromacy\" |efetch -format xml |xtract -pattern PubmedArticle -element MedlineCitation/PMID LastName 得出每个记录的所有作者的表格： 1234567891011121325827838 Yewers McLean Moussalli Stuart-Fox Bennett Knott25609782 Olsson Lind Kelber24967877 Benson Manning Brainard23393278 Sabbah Troje Gray Hawryshyn20884587 Jordan Deeb Bosten Mollon18230593 Koshitaka Kinoshita Vorobyev Arikawa17685813 Wachtler Doi Lee Sejnowski16086150 Goldsmith Butler12795212 Bonnardel Varela11511668 Ventura Zana de Souza DeVoe9839454 Vorobyev Osorio Bennett Marshall Cuthill9461554 Wilkie Vissers Das Degrip Bowmaker Hunt8351822 Jordan Mollon （请注意，“-element MedlineCitation/PMID”使用“父/子”构造来防止显示稍后可能在CommentsCorrections对象中出现的其他PMID项。） 如果合适，可以使用-first或-last参数代替-element。 XML集的探索可以通过efetch直接检索单个PubmedArticle对象： 1efetch -db pubmed -id 20643751 -format xml 生成的XML具有作者，其中包含姓氏和首字母的单独字段： 123456789101112131415161718192021&lt;AuthorList CompleteYN=\"Y\"&gt;&lt;Author ValidYN=\"Y\"&gt;&lt;LastName&gt;Inamdar&lt;/LastName&gt;&lt;ForeName&gt;Arati A&lt;/ForeName&gt;&lt;Initials&gt;AA&lt;/Initials&gt;&lt;AffiliationInfo&gt;&lt;Affiliation&gt;Department of Plant Biology and Pathology, Rutgers, The State University of New Jersey, New Brunswick, New Jersey 08901, USA. inamdar@rci.rutgers.edu&lt;/Affiliation&gt;&lt;/AffiliationInfo&gt;&lt;/Author&gt;&lt;Author ValidYN=\"Y\"&gt;&lt;LastName&gt;Masurekar&lt;/LastName&gt;&lt;ForeName&gt;Prakash&lt;/ForeName&gt;&lt;Initials&gt;P&lt;/Initials&gt;&lt;/Author&gt;&lt;Author ValidYN=\"Y\"&gt;&lt;LastName&gt;Bennett&lt;/LastName&gt;&lt;ForeName&gt;Joan Wennstrom&lt;/ForeName&gt;&lt;Initials&gt;JW&lt;/Initials&gt;&lt;/Author&gt;&lt;/AuthorList&gt;... 在没有给出关于上下文的任何指导的情况下，带有“Initials”和“LastName”参数的-element语句： 123efetch -db pubmed -id 1413997,6301692,781293 -format xml |xtract -pattern PubmedArticle -element MedlineCitation/PMID \\ -element Initials LastName 将分别探索每个参数的当前记录，从而打印所有作者姓名首字母，后跟所有作者姓氏： 1231413997 RK CR JS Mortimer Contopoulou King6301692 MA NR Krasnow Cozzarelli781293 MJ Casadaban 插入-block语句会重定向数据探索，以便一次考虑每个作者。后续元素语句仅查看当前作者的值： 123efetch -db pubmed -id 1413997,6301692,781293 -format xml |xtract -pattern PubmedArticle -element MedlineCitation/PMID \\ -block Author -element Initials LastName 恢复首字母和姓氏的正确关联： 1231413997 RK Mortimer CR Contopoulou JS King6301692 MA Krasnow NR Cozzarelli781293 MJ Casadaban 添加-sep语句以替换组成员之间的常规选项卡，并使用逗号将两个参数（“Initials，LastName”）组合到一个组中： 123efetch -db pubmed -id 1413997,6301692,781293 -format xml |xtract -pattern PubmedArticle -element MedlineCitation/PMID \\ -block Author -sep \" \" -element Initials,LastName 导致更理想的作者姓名格式： 1231413997 RK Mortimer CR Contopoulou JS King6301692 MA Krasnow NR Cozzarelli781293 MJ Casadaban 可以通过-position语句选择第一个或最后一个结构化对象： 123efetch -db pubmed -id 1413997,6301692,781293 -format xml |xtract -pattern PubmedArticle -element MedlineCitation/PMID \\ -block Author -position first -sep \" \" -element Initials,LastName 结果如下：1231413997 RK Mortimer6301692 MA Krasnow781293 MJ Casadaban 探索单独的XML区域可以在单个提取中使用多块语句来探索XML的不同区域。这将元素提取限制到所需的子区域，并允许消除具有相同名称的字段的歧义。 将独立字段与逗号组合允许将它们视为集合。通常用于分隔这些选项卡的选项可以替换为-sep参数： 12345efetch -db pubmed -id 6092233,4640931,4296474 -format xml |xtract -pattern PubmedArticle -element MedlineCitation/PMID \\ -block AuthorList -sep \"/\" -element LastName \"#Author\" \\ -block PubDate -sep \" \" -element Year,Month MedlineDate |sort -t $'\\t' -k 3,3n -k 2,2f 这将生成一个表，允许轻松解析作者姓氏，计算作者的数量，并打印每个记录发布的日期，按作者计数对结果进行排序： 1234296474 Friedmann 1 1968 Apr4640931 Tager/Steiner 2 1972 Dec6092233 Calderon/Contopoulou/Mortimer 3 1984 Jul-Aug （请注意，PubDate对象可以以结构化形式存在： 12345&lt;PubDate&gt; &lt;Year&gt;1968&lt;/Year&gt; &lt;Month&gt;Apr&lt;/Month&gt; &lt;Day&gt;25&lt;/Day&gt;&lt;/PubDate&gt; （常常缺少Day字段）或字符串形式： 123&lt;PubDate&gt; &lt;MedlineDate&gt;1984 Jul-Aug&lt;/MedlineDate&gt;&lt;/PubDate&gt; 但不包含两种类型的混合，因此指令： 1-element Year,Month MedlineDate 只会为输出一列。） XML集中子集的嵌套探索记录中的Medical Subject Headings（MeSH术语）可以分配小标题： 123456789101112131415 ... &lt;MeshHeading&gt; &lt;DescriptorName&gt;RNA, Messenger&lt;/DescriptorName&gt; &lt;QualifierName&gt;genetics&lt;/QualifierName&gt; &lt;/MeshHeading&gt; &lt;MeshHeading&gt; &lt;DescriptorName&gt;Transcription, Genetic&lt;/DescriptorName&gt; &lt;/MeshHeading&gt; &lt;MeshHeading&gt; &lt;DescriptorName&gt;beta-Galactosidase&lt;/DescriptorName&gt; &lt;QualifierName&gt;genetics&lt;/QualifierName&gt; &lt;QualifierName&gt;metabolism&lt;/QualifierName&gt; &lt;/MeshHeading&gt;&lt;/MeshHeadingList&gt;... 使用-block语句访问每个MeSH术语，并在-block中添加-subset语句，允许嵌套探索当前MeSH术语的子标题： 1234efetch -db pubmed -id 6162838 -format xml |xtract -pattern PubmedArticle -tab \"\" -element MedlineCitation/PMID \\ -block MeshHeading -pfx \"\\n\" -tab \"\" -element DescriptorName \\ -subset QualifierName -pfx \" / \" -tab \"\" -element QualifierName 并创建一个带有相关子标题的MeSH术语列表： 1234567891011126162838Base SequenceDNA, RecombinantEscherichia coli / geneticsGalactosidases / geneticsLac OperonPlasmidsProtein BiosynthesisRNA, Bacterial / geneticsRNA, Messenger / geneticsTranscription, Geneticbeta-Galactosidase / genetics / metabolism 属性的选择MeSH术语和子标题字段实际上具有主要的主题属性： 1234567...&lt;MeshHeading&gt; &lt;DescriptorName MajorTopicYN=\"N\"&gt;beta-Galactosidase&lt;/DescriptorName&gt; &lt;QualifierName MajorTopicYN=\"Y\"&gt;genetics&lt;/QualifierName&gt; &lt;QualifierName MajorTopicYN=\"N\"&gt;metabolism&lt;/QualifierName&gt;&lt;/MeshHeading&gt;... 可以选择“DescriptorName@MajorTopicYN”或“@MajorTopicYN”： 123456efetch -db pubmed -id 6162838 -format xml |xtract -pattern PubmedArticle -tab \"\" -element MedlineCitation/PMID \\ -block MeshHeading -pfx \"\\n\" -sep \"|\" -tab \"\" \\ -element DescriptorName@MajorTopicYN,DescriptorName \\ -subset QualifierName -pfx \" / \" -sep \"|\" -tab \"\" \\ -element \"@MajorTopicYN,QualifierName\" 主要主题值放在每个MeSH术语或子标题之前： 1234567891011126162838N|Base SequenceY|DNA, RecombinantN|Escherichia coli / N|geneticsN|Galactosidases / Y|geneticsN|Lac OperonN|PlasmidsY|Protein BiosynthesisN|RNA, Bacterial / N|geneticsN|RNA, Messenger / Y|geneticsN|Transcription, GeneticN|beta-Galactosidase / Y|genetics / N|metabolism 结果可以由UNIX流编辑器“sed”处理： 1sed -e 's/N|//g' -e 's/Y|/*/g' 显示主要（“已加星标的”MeSH术语）概念的星号： 123456786162838Base Sequence*DNA, RecombinantEscherichia coli / genetics...RNA, Messenger / *geneticsTranscription, Geneticbeta-Galactosidase / *genetics / metabolism 以变​​量记录值可以将值记录在变量中，然后根据需要多次显示。变量用连字符后跟一串大写字母或数字表示。变量“-PMID”在-element参数中称为“＆PMID”。例如： 1234efetch -db pubmed -id 1413997,6301692,781293 -format xml |xtract -pattern PubmedArticle -PMID MedlineCitation/PMID \\ -block Author -element \"&amp;PMID\" \\ -sep \" \" -tab \"\\n\" -element Initials,LastName 生成作者列表，每行的第一列中有PMID： 1234561413997 RK Mortimer1413997 CR Contopoulou1413997 JS King6301692 MA Krasnow6301692 NR Cozzarelli781293 MJ Casadaban 变量初始化可以使用括号中的文字值初始化变量： 1234efetch -db pubmed -id 1413997,6301692,781293 -format xml |xtract -pattern PubmedArticle -element MedlineCitation/PMID \\ -block Author -sep \" \" -tab \"\" \\ -element \"&amp;COM\" Initials,LastName -COM \"(, )\" 这可以用作占位符，以防止丢失数据移动表中的列，或者对输出格式进行额外控制： 123 1413997 RK Mortimer，CR Contopoulou，JS King 6301692 MA Krasnow，NR Cozzarelli 781293 MJ Casadaban 处理下一条记录时，将重置所有变量。 条件处理Xtract提供-if和-unless参数，按元素名称或名称加数据值进行过滤。例如： 123456esearch -db pubmed -query \"Cozzarelli NR [AUTH]\" |efetch -format xml |xtract -pattern PubmedArticle -if \"#Author\" -eq 3 \\ -block Author -if LastName -is-not Cozzarelli \\ -sep \", \" -tab \"\\n\" -element LastName,Initials |sort | uniq 将选择正好3位作者的论文并打印共同作者姓名： 123456Ackerman, RSAdams, DEAlexandrov, AIArimondo, PBBauer, WR... 使用-and和-or命令指定多个条件： 1-if @score -equals 1 -or @score -starts-with 0.9 -else命令可以提供替代-element或-lbl指令，以便在不满足条件时运行： 1-if MapLocation -element MapLocation -else -lbl \"\\-\" parallel -if和-unless语句可用于为包含嵌套探索的替代条件提供更复杂的响应。","tags":[{"name":"生信","slug":"生信","permalink":"http://yoursite.com/tags/生信/"}]},{"title":"Entrez Direct入门","date":"2019-04-11T07:44:42.000Z","path":"2019/04/11/Entrez Direct入门/","text":"Entrez Direct（EDirect）提供从UNIX终端窗口访问NCBI的互连数据库套件（发布，序列，结构，基因，变异，表达等）。函数从命令行参数中获取搜索项。将各个操作组合在一起以构建多步查询。记录检索和格式化通常会完成整个过程。 EDirect还包括一个参数驱动函数，它简化了从文档摘要或结构化XML格式返回的其他结果中提取数据的过程。这可以消除编写自定义软件以回答临时问题的需要。查询可以在EDirect命令和UNIX实用程序或脚本之间无缝移动，以执行无法在Entrez中完全完成的操作。 EDirect 官网 测试平台 MacMini 2.6 GHz Intel Core i5，macOS Mojave 10.14.2 安装进入工作文件夹1cd work 创建src文件夹1mkdir src 进入src文件夹1cd src 下载edirect1curl ftp://ftp.ncbi.nlm.nih.gov/entrez/entrezdirect/edirect.zip -O 解压缩1unzip edirect.zip 进入edirect文件夹并查看12cd edirectls 你可能已经发现setup，没错，这个就是安装文件1./setup.sh 稍（喝）等（杯）片（茶）刻（吧），当看到输出 123456789101112Trying to establish local installations of any missing Perl modules(as logged in /Users/adu/work/src/edirect/setup-deps.log).Please be patient, as this step may take a little while.Entrez Direct has been successfully downloaded and installed.In order to complete the configuration process, please execute the following: echo \"source ~/.bash_profile\" &gt;&gt; $HOME/.bashrc echo \"export PATH=\\$&#123;PATH&#125;:/Users/adu/work/src/edirect\" &gt;&gt; $HOME/.bash_profileor manually edit the PATH variable assignment in your .bash_profile file. 恭喜安装成功！ 配置环境变量 把上面打印出来的 echo “export PATH=\\${PATH}:/Users/adu/work/src/edirect” &gt;&gt; $HOME/.bash_profile 放到终端中，并回车已告诉系统EDirect的安装位置。注意每个人的安装路径都不一样，不要复制这里的应该复制你终端打印出来的。1echo \"export PATH=\\$&#123;PATH&#125;:/Users/adu/work/src/edirect\" &gt;&gt; $HOME/.bash_profile 1esearch -help 如果出现 -bash: esearch: command not found 说明环境变量没有配置正确。看到 esearch 11.1，说明可以愉快的使用 eDirect了 Entrez Direct 函数导航功能支持Entrez数据库中的探索： esearch使用索引字段中的术语执行新的Entrez搜索。 elink查找邻居（在数据库中）或链接（在数据库之间）。 efilter过滤或限制先前查询的结果。 可以指定格式或文档摘要检索记录： efetch以指定格式下载记录或报告。 无需编写程序即可提取XML结果中的所需字段： xtract将EDirect XML输出转换为数据值表。 还提供了几个附加功能： einfo获取Entrez数据库中索引字段的信息。 epost上传唯一标识符（UID）或序列登录号。 nquire向网页或CGI服务发送URL请求。 esearch语法1esearch -db databaseName -query queryString databaseName(required)数据库名字。指定数据库里查询queryString(required)查询关键字。在所在的数据库里查询的关键字 例子在pubmed数据库中查询 “opsin gene conversion”1esearch -db pubmed -query \"opsin gene conversion\" #######构建多步查询edirect允许单独执行各个操作，通过使用竖线（“|”）Unix管道符号将它们组合成一个多步骤查询。从esearch到elink：1esearch -db pubmed -query \"opsin gene conversion\" | elink -related 将查找初始结果的相关文章（预先计算的PubMed邻居）。 #######在多行上写入命令通过在按回车键之前立即键入反斜杠（“\\”）unix转义符，可以在下一行继续查询。继续查询链接到相关文章中发布的所有蛋白质序列：123esearch -db pubmed -query \"opsin gene conversion\" | \\ elink -related | \\ elink -target protein 垂直条管道符号还允许在下一行继续查询。 #######检索PubMed报告通过管道将pubmed查询结果传送到efetch并指定“abstract”格式：12esearch -db pubmed -query \"lycopene cyclase\" | efetch -format abstract 使用efetch格式的“medline”可生成一份报告，该报告可输入通用书目管理软件包中： #######检索序列报告核苷酸和蛋白质记录可以用fasta格式下载：12esearch -db protein -query \"lycopene cyclase\" | efetch -format fasta 其他FASTA格式的变体是fasta-cds-na、fasta-cds-aa和gene-fasta序列记录也可以以genbank（-format gb）或genpept（-format gp）格式文件获得，这些文件具有注释序列特定区域的功能： 搜索和筛选####### 限制查询结果目前的结果可以通过Entrez中的进一步术语搜索来改进（在蛋白质数据库中用于将BLAST邻居限制为分类子集）：123esearch -db pubmed -query \"opsin gene conversion\" | elink -related | efilter -query \"tetrachromacy\" 结果也可以按时间过滤。例如，以下语句： 12efilter -days 60 -datetype PDAT efilter -mindate 1990 -maxdate 1999 -datetype PDAT 将结果分别限制在前两个月或1990年代发表的文章中。 ####### 索引字段的合格查询 可以通过在括号中输入索引字段缩写来限定esearch或efilter中的查询字词。布尔运算符和括号也可以在查询表达式中用于更复杂的搜索。 PubMed查询的常用字段包括： Item Value [AFFL] Affiliation [ALL] All Fields [AUTH] Author [FAUT] Author - First [LAUT] Author - Last [PDAT] Date - Publication [FILT] Filter [JOUR] Journal [LANG] Language [MAJR] MeSH Major Topic [SUBH] MeSH Subheading [MESH] MeSH Terms [PTYP] Publication Type [WORD] Text Word [TITL] Title [TIAB] Title/Abstract [UID] UID 一个合格的查询看起来像：1\"Tager HS [AUTH] AND glucagon [TIAB]\" 结果如下12345678Mac-mini:work adu$ esearch -db pubmed -query \"Tager HS [AUTH] AND glucagon [TIAB]\"&lt;ENTREZ_DIRECT&gt; &lt;Db&gt;pubmed&lt;/Db&gt; &lt;WebEnv&gt;NCID_1_123525658_130.14.22.76_9001_1555050683_279099027_0MetA0_S_MegaStore&lt;/WebEnv&gt; &lt;QueryKey&gt;1&lt;/QueryKey&gt; &lt;Count&gt;24&lt;/Count&gt; &lt;Step&gt;1&lt;/Step&gt;&lt;/ENTREZ_DIRECT&gt; 将搜索结果限制为PubMed子集的过滤器包括： Item Value humans [MESH] pharmacokinetics [MESH] chemically induced [SUBH] all child [FILT] english [FILT] freetext [FILT] has abstract [FILT] historical article [FILT] randomized controlled trial [FILT] clinical trial, phase ii [PTYP] review [PTYP] 序列数据库使用一组不同的搜索字段编制索引，包括： Item Value [ACCN] Accession [ALL] All Fields [AUTH] Author [GPRJ] BioProject [ECNO] EC/RN Number [FKEY] Feature key [FILT] Filter [GENE] Gene Name [JOUR] Journal [KYWD] Keyword [MLWT] Molecular Weight [ORGN] Organism [PACC] Primary Accession [PROP] Properties [PROT] Protein Name [SQID] SeqID String [SLEN] Sequence Length [SUBS] Substance Name [WORD] Text Word [TITL] Title [UID] UID 并且蛋白质数据库中的样本查询是：1\"alcohol dehydrogenase [PROT] NOT (bacteria [ORGN] OR fungi [ORGN])\" 结果如下12345678Mac-mini:work adu$ esearch -db protein -query \"alcohol dehydrogenase [PROT] NOT (bacteria [ORGN] OR fungi [ORGN])\"&lt;ENTREZ_DIRECT&gt; &lt;Db&gt;protein&lt;/Db&gt; &lt;WebEnv&gt;NCID_1_123764783_130.14.18.97_9001_1555052879_1098401792_0MetA0_S_MegaStore&lt;/WebEnv&gt; &lt;QueryKey&gt;1&lt;/QueryKey&gt; &lt;Count&gt;8402&lt;/Count&gt; &lt;Step&gt;1&lt;/Step&gt;&lt;/ENTREZ_DIRECT&gt; 序列数据库中子集过滤器的其他示例如下： Item Value mammalia [ORGN] mammalia [ORGN:noexp] cds [FKEY] lacz [GENE] beta galactosidase [PROT] protein snp [FILT] reviewed [FILT] country united kingdom glasgow [TEXT] biomol genomic [PROP] dbxref flybase [PROP] gbdiv phg [PROP] phylogenetic study [PROP] sequence from mitochondrion [PROP] src cultivar [PROP] srcdb refseq validated [PROP] 150:200 [SLEN] （计算的分子量（MLWT）字段仅针对蛋白质（和结构）而非核苷酸编制索引。） ####### 检查中间结果 EDirect将中间结果存储在Entrez历史服务器上。 EDirect导航功能生成一个自定义XML消息，其中包含相关字段（数据库，Web环境，查询键和记录计数），可以读取管道中的下一个命令。 在添加下一步骤之前，可以检查查询中每个步骤的结果以确认预期的行为。 ENTREZ_DIRECT对象中的Count字段包含上一步返回的记录数。查询成功的一个很好的衡量标准是合理的（非零）计数值。例如：12345esearch -db protein -query \"NP_567004 [ACCN]\" | elink -related | efilter -query \"28000:30000 [MLWT]\" | elink -target structure | efilter -query \"0:2 [RESO]\" 结果如下：123456789101112131415161718192021222324252627282930313233Mac-mini:work adu$ esearch -db protein -query \"NP_567004 [ACCN]\" | elink -related | efilter -query \"28000:30000 [MLWT]\" | elink -target structure | efilter -query \"0:2 [RESO]\"Retrying elink, step 2: callMLink: Timeout waiting for response from MegaLink server (3)Retrying elink, step 2: callMLink: Timeout waiting for response from MegaLink server (3)Retrying elink, step 2: callMLink: Timeout waiting for response from MegaLink server (3)ERROR in link output: callMLink: Timeout waiting for response from MegaLink server (3)WebEnv: NCID_1_123813944_130.14.22.76_9001_1555053764_1622274016_0MetA0_S_MegaStoreURL: dbfrom=protein&amp;db=protein&amp;query_key=1&amp;WebEnv=NCID_1_123813944_130.14.22.76_9001_1555053764_1622274016_0MetA0_S_MegaStore&amp;cmd=neighbor_history&amp;linkname=protein_proteinResult: &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE eLinkResult PUBLIC \"-//NLM//DTD elink 20101123//EN\" \"https://eutils.ncbi.nlm.nih.gov/eutils/dtd/20101123/elink.dtd\"&gt;&lt;eLinkResult&gt;&lt;LinkSet&gt; &lt;DbFrom&gt;protein&lt;/DbFrom&gt; &lt;IdList&gt; &lt;Id&gt;18410104&lt;/Id&gt; &lt;/IdList&gt; &lt;LinkSetDbHistory&gt; &lt;DbTo&gt;protein&lt;/DbTo&gt; &lt;LinkName&gt;protein_protein&lt;/LinkName&gt; &lt;ERROR&gt;callMLink: Timeout waiting for response from MegaLink server (3)&lt;/ERROR&gt; &lt;/LinkSetDbHistory&gt; &lt;WebEnv&gt;NCID_1_123813944_130.14.22.76_9001_1555053764_1622274016_0MetA0_S_MegaStore&lt;/WebEnv&gt;&lt;/LinkSet&gt;&lt;/eLinkResult&gt;ERROR in filt input: callMLink: Timeout waiting for response from MegaLink server (3)ERROR in link input: callMLink: Timeout waiting for response from MegaLink server (3)&lt;ENTREZ_DIRECT&gt; &lt;Error&gt;callMLink: Timeout waiting for response from MegaLink server (3)&lt;/Error&gt;&lt;/ENTREZ_DIRECT&gt;ERROR in filt input: callMLink: Timeout waiting for response from MegaLink server (3) 在指定的分子量范围内具有39个蛋白质结构并具有所需的（X射线晶体学）原子位置分辨率。 （QueryKey值为7而不是5，因为每个elink命令通过在ELink操作之后立即运行单独的ESearch查询来获取记录计数。） ####### 结合独立查询 可以执行独立的esearch，elink和efilter操作，然后使用历史服务器的“＃”约定来表示查询键号。 （要组合的步骤必须位于同一个数据库中。）后续的esearch命令可以使用-db参数覆盖上一步中传送的数据库。 （将查询连接在一起对于共享相同的历史记录线程是必要的。）例如，查询： 1234567esearch -db protein -query \"amyloid* [PROT]\" | elink -target pubmed | esearch -db gene -query \"apo* [GENE]\" | elink -target pubmed | esearch -query \"(#3) AND (#6)\" | efetch -format docsum | xtract -pattern DocumentSummary -element Id Title 使用截断搜索（输入单词的开头后跟星号）返回与淀粉样蛋白序列和载脂蛋白基因记录相关的论文标题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Mac-mini:work adu$ esearch -db protein -query \"amyloid* [PROT]\" |&gt; elink -target pubmed |&gt; esearch -db gene -query \"apo* [GENE]\" |&gt; elink -target pubmed |&gt; esearch -query \"(#3) AND (#6)\" |&gt; efetch -format docsum |&gt; xtract -pattern DocumentSummary -element Id Title20301340 Alzheimer Disease Overview28987665 Altered spontaneous brain activity pattern in cognitively normal young adults carrying mutations of APP, presenilin-1/2 and APOE ε4.28252024 Evolution of complexity in the zebrafish synapse proteome.28071753 De novo assembly, annotation, and characterization of the whole brain transcriptome of male and female Syrian hamsters.27626380 High-throughput discovery of novel developmental phenotypes.27535807 Sex-specific characterization and evaluation of the Alzheimer's disease genetic risk factor sorl1 in zebrafish during aging and in the adult brain following a 100 ppb embryonic lead exposure.27234028 Alzheimer's disease risk genes in wild-type adult zebrafish exhibit gender-specific expression changes during aging.27189481 Gene evolution and gene expression after whole genome duplication in fish: the PhyloFish database.26871637 Widespread Expansion of Protein Interaction Capabilities by Alternative Splicing.26614614 Multi-tissue transcriptome profiles for coho salmon (Oncorhynchus kisutch), a species undergoing rediploidization following whole-genome duplication.26469318 RFX transcription factors are essential for hearing in mice.26319212 Transcriptome sequencing and development of an expression microarray platform for liver infection in adenovirus type 5-infected Syrian golden hamsters.26107351 Annotation of the Protein Coding Regions of the Equine Genome.25852190 Integrative analysis of kinase networks in TRAIL-induced apoptosis provides a source of potential targets for combination therapy.25765076 Tissue-specific transcriptome assemblies of the marine medaka Oryzias melastigma and comparative analysis with the freshwater medaka Oryzias latipes.25319552 A new rhesus macaque assembly and annotation for next-generation sequencing analyses.24952961 A high-resolution spatiotemporal atlas of gene expression of the developing mouse brain.24709693 Genome-wide data reveal novel genes for methotrexate response in a large cohort of juvenile idiopathic arthritis cases.24705354 The palmitoyl acyltransferase HIP14 shares a high proportion of interactors with huntingtin: implications for a role in the pathogenesis of Huntington's disease.24658140 The mammalian-membrane two-hybrid assay (MaMTH) for probing membrane-protein interactions in human cells.24402279 Elephant shark genome provides unique insights into gnathostome evolution.23962925 Genome analysis reveals insights into physiology and longevity of the Brandt's bat Myotis brandtii.23258410 Comparative analysis of bat genomes provides insight into the evolution of flight and immunity.23236062 Sequencing, annotation, and characterization of the influenza ferret infectome.23149746 Genome sequences of wild and domestic bactrian camels.23127152 Efficient assembly and annotation of the transcriptome of catfish by RNA-Seq analysis of a doubled haploid homozygote.20301414 Early-Onset Familial Alzheimer Disease22751099 The yak genome and adaptation to life at high altitude.22134011 A preliminary sketch of horn cancer transcriptome in Indian zebu cattle.22002653 Genome sequencing and comparison of two nonhuman primate animal models, the cynomolgus and Chinese rhesus macaques.21993625 Genome sequencing reveals insights into physiology and longevity of the naked mole rat.21857902 Transcriptome sequencing of the blind subterranean mole rat, Spalax galili: utility and potential for the discovery of novel evolutionary patterns.21484476 Major chimpanzee-specific structural changes in sperm development-associated genes.21048031 Single nucleotide polymorphisms of matrix metalloproteinase 9 (MMP9) and tumor protein 73 (TP73) interact with Epstein-Barr virus in chronic lymphocytic leukemia: results from the European case-control study EpiLymph.20875843 Cloning, sequencing and expression in the dog of the main amyloid precursor protein isoforms and some of the enzymes related with their processing.20433749 Salmo salar and Esox lucius full-length cDNA sequences reveal changes in evolutionary pressures on a post-tetraploidization genome.20403183 Transcriptome sequencing and development of an expression microarray platform for the domestic ferret.20237496 New genetic associations detected in a host response study to hepatitis B vaccine.19946888 Defining the membrane proteome of NK cells.19820115 BeetleBase in 2010: revisions to provide comprehensive genomic information for Tribolium castaneum.19393038 A whole-genome assembly of the domestic cow, Bos taurus.19199708 Proteomic analysis of human parotid gland exosomes by multidimensional protein identification technology (MudPIT).18362917 The genome of the model beetle and pest Tribolium castaneum.17145712 PEDE (Pig EST Data Explorer) has been expanded into Pig Expression Data Explorer, including 10 147 porcine full-length cDNA sequences.16710414 The DNA sequence and biological annotation of human chromosome 1.16335952 Human plasma N-glycoproteome analysis by immunoaffinity subtraction, hydrazide chemistry, and mass spectrometry.16141072 The transcriptional landscape of the mammalian genome.16136131 Initial sequence of the chimpanzee genome and comparison with the human genome.16109975 The zebrafish gene map defines ancestral vertebrate chromosomes.15642098 Full-length cDNAs from chicken bursal lymphocytes to facilitate gene function analysis.15489334 The status, quality, and expansion of the NIH full-length cDNA project: the Mammalian Gene Collection (MGC).15202933 Insertion of the amyloid precursor protein into lipid monolayers: effects of cholesterol and apolipoprotein E.15169875 Identification and verification of novel rodent postsynaptic density proteins.15164054 The DNA sequence and comparative analysis of human chromosome 10.15164053 DNA sequence and analysis of human chromosome 9.15057824 The DNA sequence and biology of human chromosome 19.14702039 Complete sequencing and characterization of 21,243 full-length human cDNAs.14681463 PEDE (Pig EST Data Explorer): construction of a database for ESTs derived from porcine full-length cDNA libraries.12665801 Exploring proteomes and analyzing protein processing by mass spectrometric identification of sorted N-terminal peptides.12537572 Annotation of the Drosophila melanogaster euchromatic genome: a systematic review.12520002 BayGenomics: a resource of insertional mutations in mouse embryonic stem cells.12477932 Generation and initial analysis of more than 15,000 full-length human and mouse cDNA sequences.12454917 Genetic and genomic tools for Xenopus research: The NIH Xenopus initiative.12040188 A comparison of whole-genome shotgun-derived mouse chromosome 16 and the human genome.11247302 Disabled-2 colocalizes with the LDLR in clathrin-coated pits and interacts with AP-2.11230166 Toward a catalog of human genes and proteins: sequencing and analysis of 500 novel complete protein coding human cDNAs.11181995 The sequence of the human genome.10731132 The genome sequence of Drosophila melanogaster.8858135 Regulation of tumor necrosis factor-and Fas-mediated apoptotic cell death by a novel cDNA TR2L.7542371 Expression in mouse embryos and in adult mouse brain of three members of the amyloid precursor protein family, of the alpha-2-macroglobulin receptor/low density lipoprotein receptor-related protein and of its ligands apolipoprotein E, lipoprotein lipase, alpha-2-macroglobulin and the 40,000 molecular weight receptor-associated protein. 使用（＃3）AND（＃6）代替上面的（＃2）AND（＃4）反映了每个elink命令执行单独的ESearch查询的需要，该查询增加QueryKey，以获得记录计数。 -label参数可用于绕过此工件。标签值以“＃”符号为前缀，并放在最终搜索的括号中。从而： 123456esearch -db structure -query \"insulin [TITL]\" | elink -target pubmed -label struc_cit | esearch -db protein -query \"insulin [PROT]\" | elink -target pubmed -label prot_cit | esearch -query \"(#struc_cit) AND (#prot_cit)\" | efetch -format uid 将返回：123456789101112131415Mac-mini:work adu$ esearch -db structure -query \"insulin [TITL]\" |&gt; elink -target pubmed -label struc_cit |&gt; esearch -db protein -query \"insulin [PROT]\" |&gt; elink -target pubmed -label prot_cit |&gt; esearch -query \"(#struc_cit) AND (#prot_cit)\" |&gt; efetch -format uid25423173152998809235985914113184216931433291177263320254102905485 无需跟踪内部QueryKey值。","tags":[{"name":"生信","slug":"生信","permalink":"http://yoursite.com/tags/生信/"}]},{"title":"privacy policy","date":"2019-01-02T02:50:09.000Z","path":"2019/01/02/privacyPolicy/","text":"隐私权声明——概述Privacy statement 我们尊重并保护所有使用服务用户的个人隐私权。本隐私权政策详细说明了 superApp 旗下的应用，养生粥，带我回家，Home?, 宝宝识物（“宝宝识物”、“我们”或“我们的”）通过我们的应用程序和网站收集的信息，以及我们将如何使用这些信息。 我们遵守“儿童在线隐私保护法案”我们的所有儿童类app及网站遵循有关儿童在线隐私保护条款。我们不会有意收集任何未满13周岁儿童的个人信息，如检测到年龄小于13周岁，我们将会及时删除相关信息，不会予以保留、存储。 不会通过我们的应用程序或网站收集儿童的个人信息。我们深知用户个人信息的重要性，特别是对于未成年人。在我们的app及网站中，不要求用户输入详细个人信息资料。用户使用宝宝识物软件时可能会被宝宝识物读取一些信息（比如基于网络的粗略位置、 GPS位置、网络通信、手机状态、wifi状态等）；iOS与android手机设备多样化，我们需要进行多种兼容性测试以保证宝宝识物用户能正常使用软件；由于移动互联行业的特殊性， 宝宝识物产品需要配合硬件的升级进行产品本身或者产品自身品质的升级，因此可能需要读取wifi来告知用户是否有升级产品出现，如没有启动wifi则不提示。 这样可以避免用户在不知情的情况下更新产品,造成不必要的流量损耗等等诸如此列的原因。宝宝识物承诺所读取到的任何信息，只被使用于宝宝识物软件的开发，而不会透入给第三方（其它个人或公司）， 除非得到您的许可或法律或政府的强制规定。 第三方网站链接我们可能会提供从我们的网站链接和/或连接到第三方网站或服务，对第三方网站的隐私做法或内容，我们不予负责。 隐私政策修改我们可能会对隐私条款进行随时修改，并保留最终解释权。 联系我们如果您有关于本隐私政策的任何问题或疑虑，请发送邮件到：bbsuper[at]qq.com（请将[at]换成@）","tags":[{"name":"App","slug":"app","permalink":"http://yoursite.com/tags/app/"}]},{"title":"工匠精神","date":"2017-02-21T07:19:09.000Z","path":"2017/02/21/工匠精神/","text":"今天早上在上班的路上，听到广播在说日本秋山木工的【工匠精神】。 工匠精神的内涵：精益求精、追求卓越 中国古代圣人孔子就发表过言论 《诗》云：“如切如磋，如琢如磨。” 孔子《论语·学而》 “言治骨角者，既切之而复磋之；治玉石者，既琢之而复磨之，治之已精，而益求其精也。” 朱熹 意思是精雕细琢，精益求精的理念。 从某种意义上说，编程也是一门手艺活，数量的码工编写的代码鲁棒性强，效率高，细节好。一流的人才是技艺和态度的双重修炼。精湛的技艺背后总是有对技术的敬畏、和感情。善于思考和领悟。 程序开发中，码工也应该学习这种精神。追求程序之美，代码之美。从优秀到卓越！","tags":[{"name":"管理","slug":"管理","permalink":"http://yoursite.com/tags/管理/"}]},{"title":"Objective-C id as Swift Any","date":"2017-02-09T06:29:00.000Z","path":"2017/02/09/objective-c-id-as-swift-any/","text":"Swift3 接口和Objective-C 的APIs比之前的版本更强大。例如，Swift 2将Objective-C中的id类型映射到Swift中的AnyObject类型，通常只能保存值类型。 Swift 2还为AnyObject提供了对一些桥接值类型（例如String，Array，Dictionary，Set和一些数字）的隐式转换，以便原生Swift类型可以很容易地使用Cocoa APIs，如NSString，NSArray或Foundation的其他容器类。这些转换与语言的其他部分不一致，使得很难理解什么可以用作AnyObject，结果是bugs。 在Swift 3中，Objective-C中的id类型现在映射到Swift中的Any类型，它描述了任何类型的值，无论是类，枚举，结构还是任何其他Swift类型。这种变化使得Swift中的Objective-C APIs更加灵活，因为Swift定义的值类型可以传递给Objective-C API，并作为Swift类型返回，从而无需手动“box”类型。这些优点也扩展到集合：Objective-C集合类型NSArray，NSDictionary和NSSet，以前只接受AnyObject的元素，现在可以保存Any类型的元素。对于散列容器，例如Dictionary和Set，有一个新类型AnyHashable可以容纳任何类型的值遵循Swift Hashable协议。总之，从Swift 2到Swift 3以下类型映射更改为： Objective-C Swift2 Swift3 id AnyObject Any NSArray * [AnyObject] [Any] NSDictionary * [NSObject: AnyObject] [AnyHashable: Any] NSSet * Set Set 在许多情况下，您的代码不必为响应此更改而显着地更改。 Swift 2中的代码依赖于隐式转换为AnyObject的值类型，它将继续按照Any的原样在Swift 3中工作。但是，有些地方需要更改声明的变量和方法类型，并获得Swift 3的最佳体验。另外，如果你的代码显式使用AnyObject或Cocoa类，如NSString，NSArray或NSDictionary，你将需要引入更多的显式转换使用as NSString或as String，因为在Swift 3中对象和值类型之间的隐式转换不再允许。Xcode中的自动迁移器将进行最小的更改，以保持您的代码从Swift 2到3编译，但结果可能不总是最优雅的。本文将介绍您可能需要做的一些更改，以及在更改代码以充分利用id为Any时需要注意的一些陷阱。 覆盖方法和遵循协议当子类化一个Objective-C类并覆盖它的方法，或者遵循一个Objective-C协议，当父方法在Objective-C中使用id时，需要更新方法的类型。一些常见的例子是NSObject类的isEqual：方法和NSCopying协议的copyWithZone：方法。在Swift 2中，你将写一个遵循NSCopying的NSObject子类，如下所示： 12345// Swift 2class Foo: NSObject, NSCopying &#123; override func isEqual(_ x: AnyObject?) -&gt; Bool &#123; ... &#125; func copyWithZone(_ zone: NSZone?) -&gt; AnyObject &#123; ... &#125;&#125; 在Swift 3中，除了将命名从copyWithZone（_ :)更改为copy（with :)之外，还需要将这些方法的签名更改为Any而不是AnyObject： 12345// Swift 3class Foo: NSObject, NSCopying &#123; override func isEqual(_ x: Any?) -&gt; Bool &#123; ... &#125; func copy(with zone: NSZone?) -&gt; Any &#123; ... &#125;&#125; 非类型集合属性列表，JSON和用户信息字典在Cocoa中很常见，Cocoa本地将这些表示为非类型化集合。在Swift 2中，为此需要构建Array，Dictionary或Set with AnyObject或NSObject元素，依靠隐式桥接转换来处理值类型： 12345678910111213141516171819202122// Swift 2struct State &#123; var name: String var abbreviation: String var population: Int var asPropertyList: [NSObject: AnyObject] &#123; var result: [NSObject: AnyObject] = [:] // Implicit conversions turn String into NSString here… result[\"name\"] = self.name result[\"abbreviation\"] = self.abbreviation // …and Int into NSNumber here. result[\"population\"] = self.population return result &#125;&#125;let california = State(name: \"California\", abbreviation: \"CA\", population: 39_000_000)NSNotification(name: \"foo\", object: nil, userInfo: california.asPropertyList) 或者，您可以使用Cocoa容器类，例如NSDictionary： 12345678910111213141516171819202122// Swift 2struct State &#123; var name: String var abbreviation: String var population: Int var asPropertyList: NSDictionary &#123; var result = NSMutableDictionary() // Implicit conversions turn String into NSString here… result[\"name\"] = self.name result[\"abbreviation\"] = self.abbreviation // …and Int into NSNumber here. result[\"population\"] = self.population return result.copy() &#125;&#125;let california = State(name: \"California\", abbreviation: \"CA\", population: 39_000_000)// NSDictionary then implicitly converts to [NSObject: AnyObject] here.NSNotification(name: \"foo\", object: nil, userInfo: california.asPropertyList) 在Swift 3中，隐式转换已经消失，因此上述两个片段都不会按原样工作。迁移者可能建议用as单独转换每个值，以保持此代码的工作，但有一个更好的解决方案。 Swift现在导入Cocoa API接受Any和/或AnyHashable的集合，所以我们可以更改集合类型为[AnyHashable：Any]替换[NSObject：AnyObject]或NSDictionary，而不更改任何其他代码： 1234567891011121314151617181920212223// Swift 3struct State &#123; var name: String var abbreviation: String var population: Int // Change the dictionary type to [AnyHashable: Any] here... var asPropertyList: [AnyHashable: Any] &#123; var result: [AnyHashable: Any] = [:] // No implicit conversions necessary, since String and Int are subtypes // of Any and AnyHashable result[\"name\"] = self.name result[\"abbreviation\"] = self.abbreviation result[\"population\"] = self.population return result &#125;&#125;let california = State(name: \"California\", abbreviation: \"CA\", population: 39_000_000)// ...and you can still use it with Cocoa API hereNotification(name: \"foo\", object: nil, userInfo: california.asPropertyList) AnyHashable类型Swift的Any类型可以保存任何类型，但是Dictionary和Set需要的键是Hashable，所以Any是太普通。从Swift 3开始，Swift标准库提供了一个新的类型AnyHashable。与Any类似，它充当所有Hashable类型的父类型，因此String，Int和其他hashable类型的值可以隐式地用AnyHashable值，AnyHashable中的类型可以使用is，as!或as?动态检查，动态转换运算符。当从Objective-C导入无类型的NSDictionary或NSSet对象时，使用AnyHashable，但是在纯Swift中也可用于构建异构集合或字典。 未链接上下文的显式转换在某些有限的情况下，Swift不能自动桥接C和Objective-C构造。例如，一些C和Cocoa API使用id * 指针作为“out”或“in-out”参数，并且由于Swift不能静态地确定指针的使用方式，因此它不能对内存中的值自动执行桥接转换。在这种情况下，指针仍将显示为UnsafePointer 。如果您需要使用这些非桥接API，您可以使用显式桥接转换，在代码中使用as Type或as AnyObject显式编写。 1234567// ObjC@interface Foo- (void)updateString:(NSString *)string;- (void)updateObject:(id *)obj;@end 123456789101112// Swiftfunc interactWith(foo: Foo) -&gt; (String, Any) &#123; var string = \"string\" as NSString // explicit conversion foo.updateString(&amp;string) // parameter imports as UnsafeMutablePointer&lt;NSString&gt; let finishedString = string as String var object = \"string\" as AnyObject foo.updateObject(&amp;object) // parameter imports as UnsafeMutablePointer&lt;AnyObject&gt; let finishedObject = object as Any return (finishedString, finishedObject)&#125; 另外，Objective-C协议在Swift中仍然是类约束，所以你不能让Swift结构或枚举直接遵循Objective-C协议或者使用轻量级通用类。您需要使用这些协议和API显式转换String as NSString，Array as NSArray等。 AnyObject成员查找Any没有与AnyObject相同的魔法方法查找行为。这可能会破坏一些Swift 2代码，查找属性或发送消息到一个无类型的Objective-C对象。例如，这个Swift 2的代码： 12345// Swift 2func foo(x: NSArray) &#123; // Invokes -description by magic AnyObject lookup print(x[0].description)&#125; 将抱怨description不是Swift 3中Any的成员。可以将x [0] as AnyObject以获取动态行为： 12345// Swift 3func foo(x: NSArray) &#123; // Result of subscript is now Any, needs to be coerced to get method lookup print((x[0] as AnyObject).description)&#125; 或者，将值强制转换为您期望的具体对象类型： 1234func foo(x: NSArray) &#123; // Cast to the concrete object type you expect print((x[0] as! NSObject).description)&#125; Swift中的值类型Any可以hold住任何结构，枚举，元组或你可以在语言中定义的其他Swift类型。 Swift 3中的Objective-C桥接器可以提供任何Swift值作为Objective-C的id兼容对象。这使得更容易在Cocoa容器，userInfo字典和其他对象中存储自定义Swift值类型。例如，在Swift 2中，您需要将数据类型更改为类，或者手动box它们，以将它们的值附加到NSNotification： 1234567891011121314151617// Swift 2struct CreditCard &#123; number: UInt64, expiration: NSDate &#125;let PaymentMade = \"PaymentMade\"// We can't attach CreditCard directly to the notification, since it// isn't a class, and doesn't bridge.// Wrap it in a Box class.class Box&lt;T&gt; &#123; let value: T init(value: T) &#123; self.value = value &#125;&#125;let paymentNotification = NSNotification(name: PaymentMade, object: Box(value: CreditCard(number: 1234_0000_0000_0000, expiration: NSDate()))) 使用Swift 3，我们可以取消box，并将对象直接附加到Notification： 12345678// Swift 3let PaymentMade = Notification.Name(\"PaymentMade\")// We can associate the CreditCard value directly with the Notificationlet paymentNotification = Notification(name: PaymentMade, object: CreditCard(number: 1234_0000_0000_0000, expiration: Date())) 在Objective-C中，CreditCard值将作为一个id兼容的，继承NSObject对象实现isEqual：，hash和description，如果它们存在原生的Swift类型的话，使用Swift的Equatable，Hashable和CustomStringConvertible。从Swift中，可以通过将其动态地转换回其原始类型来检索该值： 123// Swift 3let paymentCard = paymentNotification.object as! CreditCardprint(paymentCard.number) // 1234000000000000 请注意，在Swift 3.0中，一些常见的Swift和Objective-C结构类型将桥接为不透明对象，而不是惯用的Cocoa对象。例如，Int，UInt，Double和Bool桥接到NSNumber，其他大小的数字类型，例如Int8，UInt16等只桥接为不透明对象。可变结构如CGRect，CGPoint和CGSize也作为不透明对象桥接，即使大多数Cocoa API期望它们一起作为对象在NSValue实例中被box。如果你看到unrecognized selector sent to _SwiftValue错误，这表明Objective-C代码试图调用一个不透明的Swift值类型的方法，你可能需要手动box该类的实例中Objective-C代码期望的值。 要注意的一个特殊问题是Optionals。 Swift Any可以代表任何东西，包括一个Optional，所以可以在不首先检查它情况下将一个包装的Optional传递给Objective-C API，即使API被声明为一个nonnull id类型。这通常表现为包括_SwiftValue的运行时错误，而不是编译时错误。 Xcode 8.1 beta中包含的Swift 3.0.1通过实现这些建议来透明地处理数字类型，Objective-C结构和可选类型，以解决NSNumber，NSValue和Optional桥接中的上述限制： SE–0139: Bridge Numeric Types to NSNumber and Cocoa Structs to NSValue SE–0140: Warn when Optional converts to Any, and bridge Optional As Its Payload Or NSNull 为了避免向前兼容性问题，你不应该依赖_SwiftValue类的不透明对象的实现细节，因为未来版本的Swift可能允许更多的Swift类型桥接到惯用的Objective-C类。 Linux可移植性在Linux上使用Swift Core 运行的Swift程序库使用了原生Swift中编写的一个Foundation版本，没有Objective-C运行时桥接。 id-as-Any允许Core Libraries直接使用原生Swift Any和标准库值类型，同时使用Objective-C Foundation实现保持与Apple平台上的代码兼容。由于Swift在Linux上不与Objective-C交互操作，因此不支持桥接转换，例如string as NSString或value as AnyObject。希望在Cocoa和Swift Core Libraries之间移植的Swift代码应该只使用值类型。 学习更多id-as-Any是Swift语言改进的一个很好的例子，受到用户对早期版本的Swift的反馈的启发，并通过来自开放的Swift Evolution过程的回顾完善。如果你想更多地了解id-as-Any背后的动机和设计决策，原始的Swift Evolution提议可以在GitHub的swift-evolution仓库中找到： SE-0072：完全消除来自Swift的隐式桥接转换 SE-0116：将Objective-C **id**导入为Swift**Any**类型 SE-0131：将AnyHashable添加到标准库 最终结果是，Swift是一种更加一致的语言，当使用Swift时，Cocoa API变得更强大。","tags":[]},{"title":"共享单车","date":"2016-12-25T09:52:09.000Z","path":"2016/12/25/共享单车/","text":"进来厦门的大街小巷出现了小黄车，小白车等各种共享单车。这让人想起了上个世纪的黄包车，城市中大街小巷中穿梭。。。 时代变迁，黄车重现江湖，共享经济炙手可热。移动互联网激烈角逐各领域的最后一公里。 横尸片野的小黄车也让人忧心，维修起来也是个大难题。但听说投资机构都排队上门，不担心资金问题","tags":[{"name":"新鲜事","slug":"新鲜事","permalink":"http://yoursite.com/tags/新鲜事/"}]},{"title":"Unit Testing","date":"2016-12-21T09:58:16.000Z","path":"2016/12/21/unit-testing/","text":"12341.Testing Framework Review2.High-level Overview3.Time to Testing4.What’s new?(Asynchronous Testing, Performance Testing) 12345Xcode’s testing frameworks Xcode5: OCUnit -&gt; XCTestXcode5.1: OCUnit Xcode6: new XCTest API 12test class name end with Tests.(e:ViewModelTests)test case methods must start with the word test so that the test runner can find them.(e:testInitialization) 12345XCTestCaseThe default XCTestCase class contains a setup() and a tearDown() method.For every test function, the test runner calls setup() and tearDown()Override these methods to perform any necessary configuration of your object before the test runs, and any cleanup after. 1234567891011121314151617181920AssertionsXCTFail(format…) 生成一个失败的测试； XCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过； XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；XCTAssert(expression, format...)当expression求值为TRUE时通过； XCTAssertTrue(expression, format...)当expression求值为TRUE时通过； XCTAssertFalse(expression, format...)当expression求值为False时通过； XCTAssertEqualObjects(a1, a2, format...)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；XCTAssertNotEqualObjects(a1, a2, format...)判断不等，[a1 isEqual:a2]值为False时通过；XCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）； XCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试； XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试； XCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过； XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过 123456Asynchronous TestingPerformance TestingmeasureBlock: which takes a block of code and measures the execution time of the entire block.measureMetrics: is a more intimate version of measureBlock that offers fine grained control of what to measure,and when to measure it. 12345678910How Xcode decides to mark a performance test as success or failure, here’s the logicFor convenience AVE means average,STDDEV means standard deviation:1. If the test has no baseline, the result is neither a success nor a failure.2. If the current run’s STDDEV minus the baseline STDDEV took less than 0.1 second, ignore it.3. If the current run&apos;s STDDEV minus the baseline STDDEV took more than 0.1 second and the difference is more than 10%, it’s a failure.4. If the current run’s AVE minus the baseline AVE took less than 0.1 second, ignore it.5. If the current run’s AVE minus the baseline AVE took more than 0.1 second and the difference is more than 10%, it’s a failure.6. Everything else is considered a success.","tags":[]},{"title":"产品 产品","date":"2016-12-20T09:52:09.000Z","path":"2016/12/20/产品-产品/","text":"产品的迭代需要有计划，有策略的进行。就像下象棋一样，承前启后，打出组合拳。才能达到目标。","tags":[{"name":"迭代","slug":"迭代","permalink":"http://yoursite.com/tags/迭代/"}]},{"title":"Swift-Objective-C到底哪家强","date":"2016-08-22T07:44:42.000Z","path":"2016/08/22/Swift-Objective-C到底哪家强/","text":"swift出世后，人们茶余饭后就会讨论Swift和OC到底哪家强？Swift好用吗？下面主要从用法和性能方面来讨论。 语法 毫无疑问，从第一眼看到Swift。就看到了它的简洁，语法更清楚，更容易被理解。这要归结于Swift的设计，它借鉴了很多语言（C、JavaScript、Python、Java）的优点，特别是动态语言。让你写起来更简单有趣。同时，Swift也提供了面向对象编程。 性能 测试平台：MacMini 2.6 GHz Intel Core i5， Xcode8.2，Swift3.0 循环循环一百万次，里面什么事也不做 swift 12345678910111213let oneMillion = 1000000let startTimes = NSDate().timeIntervalSince1970 * 1000func loop() &#123; for _ in 1...oneMillion &#123; &#125;&#125;loop()let endTimes = NSDate().timeIntervalSince1970 * 1000let usedTimes = endTimes - startTimesprint(\"loop a million times used \\(usedTimes) ms\") OC 12345678910int oneMillion = 1000000;NSTimeInterval startTimes = [[NSDate date] timeIntervalSince1970] * 1000;for (NSUInteger i = 0; i &lt; oneMillion; i++)&#123;&#125;NSTimeInterval endTimes = [[NSDate date] timeIntervalSince1970] * 1000;NSTimeInterval usedTimes = endTimes - startTimes;printf(\"used times %f ms\", usedTimes); 用时（运行十次取平均值）Swift： 3.62075195ms（3.333984375, 3.486083984375, 5.197998046875, 3.31982421875, 3.321044921875,3.31982421875, 3.338134765625, 4.220947265625, 3.32177734375, 3.347900390625,）Objective-C：2.4488037ms (2.345947, 2.363037, 2.292725, 2.596924, 2.352051,2.587158, 2.348145, 2.649902, 2.412109, 2.540039,) 快速排序 快速排序就取10k个数，分为三种情况（正常，倒序，均值） 正常swift 123456789101112131415161718192021222324252627let count = 10000let arr = Array(1...count)let startTimes = NSDate().timeIntervalSince1970 * 1000// *** Simple but inefficient version of quicksort ***func quicksort&lt;T: Comparable&gt;(_ a: [T]) -&gt; [T] &#123; guard a.count &gt; 1 else &#123; return a &#125; let pivot = a[a.count/2] let less = a.filter &#123; $0 &lt; pivot &#125; let equal = a.filter &#123; $0 == pivot &#125; let greater = a.filter &#123; $0 &gt; pivot &#125; // Uncomment this following line to see in detail what the // pivot is in each step and how the subarrays are partitioned. //print(pivot, less, equal, greater) return quicksort(less) + equal + quicksort(greater) return quicksort(less) + equal + quicksort(greater)&#125;quicksort(arr)let endTimes = NSDate().timeIntervalSince1970 * 1000let usedTimes = endTimes - startTimesprint(\"times used \\(usedTimes) ms\") OC 12345678910111213141516NSUInteger cap = 10000;NSMutableArray *arr = [NSMutableArray arrayWithCapacity:cap];for (NSUInteger i = 0; i &lt; cap; i++) &#123; NSNumber *num = [NSNumber numberWithInteger:i]; arr[i] =num;&#125;NSTimeInterval startTimes = [[NSDate date] timeIntervalSince1970] * 1000;[self QuickSorkOC:arr Count:[arr count]];NSTimeInterval endTimes = [[NSDate date] timeIntervalSince1970] * 1000;NSTimeInterval usedTimes = endTimes - startTimes;printf(\"used times %f ms\", usedTimes); 用时（运行十次取平均值）Swift： 201.352221ms（226.079833984375, 180.364990234375, 182.054931640625, 195.965087890625, 197.198974609375,193.84375, 268.726806640625, 191.621826171875, 188.782958984375, 188.883056640625,）Objective-C：1551.05075ms (1497.709961, 1507.664062, 1505.760254, 1498.334961, 1578.202148,1499.712158, 1531.479736, 1492.811035, 1684.247070, 1714.586182) 倒序考虑最坏的情况，数据是从大到小的。只需要把数组倒序过来 swift 12var arr = Array(1...count)arr.sort(by: &gt;) OC 1arr = (NSMutableArray *)[[arr reverseObjectEnumerator] allObjects]; 用时（运行十次取平均值）Swift： 193.266601ms（184.419189453125, 255.409912109375, 189.22509765625, 198.416259765625, 190.2978515625,181.308837890625, 187.583984375, 184.344970703125, 183.385009765625, 178.27490234375,）Objective-C：1644.0257ms(1911.626709, 1546.142090, 1542.587158, 1929.552979, 1553.895020,1576.763672, 1586.454102, 1558.053955, 1548.708252, 1686.473145,) 均值swift 12let count = 10000var arr = Array(repeating: 0, count: count) OC 1234for (NSUInteger i = 0; i &lt; cap; i++) &#123; NSNumber *num = [NSNumber numberWithInteger:0]; arr[i] = num;&#125; 用时（运行十次取平均值）Swift： 16.3355224ms（13.64892578125, 21.63916015625, 15.175048828125, 21.05322265625, 17.60595703125,13.64111328125, 17.98193359375, 13.454833984375, 14.905029296875, 14.25, ）Objective-C： 10.8430176ms (18.000977, 10.387207, 10.093994, 10.768066, 9.725098,10.739014, 10.843018, 12.367188, 16.007812, 10.340820, ) 内存管理 Swift也是采用了自动引用计数（ARC）来管理内存，这样可以是程序员专注于核心的应用逻辑以及新的功能特性上。把内存管理交给编译器去做。但值得注意的是，要避免循环引用造成的内存泄漏。 安全 用OC的时候，比较经常遇到的崩溃是空指针（nil、null）和数组越界。在OC中你对nil发送消息，是被允许的，它什么事情都不会发生。而这就是得看起来并不会崩溃，但其实它隐藏着一个巨大的bug。这种bug是随机的，并且很能复现。这就造成在修复的时候必须发大力气来寻找问题所在。 在Swift中提供了可选类型使得一个nil可选值的可能性变得非常的明确，这样你就很明白了。如果你不小心写了不明确的代码时编译器会报错。问题就在编写的时候就修复好了，这就大大节省了修复OC指针逻辑的bug时间。 维护 历史遗留下来的问题，使得OC不得不用两个文件。如果C没有改进的话，OC也就没办法跟着改变。在OC中，优化构建的时间以及创建App的效率就比不上Swift了。OC的两份文件系统就多了额外的工作，特别是在维护的时候，不得不来回的切换，幸好有快捷键，但也会觉得繁琐。 BTW：良好的编程规范是很重要的 好不好用？用了才知道，语言它只是个表现手法，编程思想才是最重要的。适合团队的开发工具，能够高效的工作才是首选！","tags":[{"name":"swift,","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"python17 django","date":"2016-03-28T11:34:19.000Z","path":"2016/03/28/python17 django/","text":"mac自带的python版本是2.7的，现在最新的是3.6的。因为系统自带的2.7版本的Xcode会用到，不建议替换掉。从新下载最新的安装，启动2.7的就直接python，启动3.6的就python3。如此一来就方便了。 mac自带了pip，但由于版本太低需要升级在安装 1pip3 install --upgrade pip 安装django 1pip3 install django 安装完成以后，启动python3，引入django包。打印django版本。至此安装django成功。 1234567Mac-mini:Django adu$ python3Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; import django&gt;&gt;&gt; print(django.get_version())2.0 创建第一个django项目使用 django-admin.py 来创建 HelloDjango 项目： 1django-admin.py startproject HelloDjango 目录说明：HelloDjango: 项目的容器。manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。HelloDjango/init.py: 一个空文件，告诉 Python 该目录是一个 Python 包。HelloDjango/settings.py: 该 Django 项目的设置/配置。HelloDjango/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站”目录”。HelloDjango/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。接下来我们进入 HelloDjango 目录输入以下命令，启动服务器： 1python3 manage.py runserver 启动成功输出 1234567891011121314Performing system checks...System check identified no issues (0 silenced).You have 14 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.Run 'python manage.py migrate' to apply them.June 06, 2017 - 08:11:05Django version 2.0, using settings 'Django.settings'Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C.[06/Jun/2017 08:11:22] \"GET / HTTP/1.1\" 200 1699Not Found: /favicon.ico[06/Jun/2017 08:11:22] \"GET /favicon.ico HTTP/1.1\" 404 1961 在浏览器输入你服务器的ip及端口号，如果正常启动，输出结果如下： 视图和 URL 配置在先前创建的 HelloDjango 目录下的 HelloDjango 目录新建一个 view.py 文件，并输入代码：HelloDjango/HelloDjango/view.py 文件代码：1234from django.http import HttpResponse def hello(request): return HttpResponse(\"Hello django ! \") 接着，绑定 URL 与视图函数。打开 urls.py 文件，删除原来代码，将以下代码复制粘贴到 urls.py 文件中：HelloDjango/HelloDjango/urls.py 文件代码：1234567from django.conf.urls import url from . import view urlpatterns = [ url(r'^$', view.hello),] 完成后，启动 Django 开发服务器，并在浏览器访问打开浏览器并访问： 我们也可以修改以下规则： HelloDjango/HelloDjango/urls.py 文件代码： from django.conf.urls import url from . import view urlpatterns = [ url(r’^helloview$’, view.hello),] 通过浏览器打开 http://127.0.0.1:8000/helloview，输出结果如下： 注意：项目中如果代码有改动，服务器会自动监测代码的改动并自动重新载入，所以如果你已经启动了服务器则不需手动重启。 url() 函数Django url() 可以接收四个参数，分别是两个必选参数：regex、view 和两个可选参数：kwargs、name，接下来详细介绍这四个参数。 regex: 正则表达式，与之匹配的 URL 会执行对应的第二个参数 view。 view: 用于执行与正则表达式匹配的 URL 请求。 kwargs: 视图使用的字典类型的参数。 name: 用来反向获取 URL。","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python16 Classes","date":"2016-03-26T11:31:16.000Z","path":"2016/03/26/python16 Classes/","text":"Python类教程解释Python中的类和面向对象编程。 我不会骗你的。如果你从未有过面向对象编程（OOP）的经验，接下来的几篇教程将相当复杂。由于一些原因，类是真棒。首先，它们帮助您重用代码，而不是在程序的其他地方复制代码。当你意识到你想要改变一个函数时，类将挽救你的生命。你只需要它在一个点，而不是10个不同的点改变略有不同的代码。类的另一个重要部分是，它们允许您创建更灵活的函数。首先，我们需要弄得手脏兮兮的，然后想出如何做一个类。 在Python中创建类例子 123456789101112131415161718192021#ClassOne.py class Calculator(object): #define class to simulate a simple calculator def __init__ (self): #start with zero self.current = 0 def add(self, amount): #add number to current self.current += amount def getCurrent(self): return self.current 现在，我不会像其他人一样，开始用术语轰炸你。坦率地说，面向对象编程对于初学者来说是相当困难的，把这些抽象概念扔给你只会让你学得更慢，更讨厌OOP。所以，类有点像函数。我们只是建立它使用class关键字，并跟在后面的是我们想要命名的类。在我们的例子中，我们正在做一个计算器，所以就用它来命名。很直白吧！接下来，我们抛出object的论点。这仅仅是这个类上面的一个类。不要太担心它。它涉及一些严肃的术语来解释。所以，只要输入它，我们稍后再谈。 接下来，我们进入了这个小家伙，def init（self):。抽象概念时间！对象由类构成。所以，如果我们有一个班级叫蛋糕。我们可以做蛋糕对象。然而，每当你做蛋糕的时候，它和你以前做的蛋糕不一样。当然，它看起来像它和味道一样，但它不是相同的蛋糕。所以，在我们班，我们有实例，我们知道他们是两个不同的蛋糕。你问我们为什么需要这个？好吧，我们从同一个班级做两个蛋糕。现在，我咬了一口蛋糕。现在，你肯定想知道哪个蛋糕是哪个？这就是为什么实例如此重要！所以，def init（self）:只是说让我们创建这个类的一个实例。但是，我们为什么要通过一个自我参数，你可能会问。嗯，这与我们刚才讨论的很有关系。类使对象和类中的函数成为对象的方法。但是，我们确实需要知道哪个类函数属于类的哪个实例，所以我们只是隐式地传递self的属性（在后面的例子中进一步讨论）。最后，我们进入到初始化函数的心脏。在我们使用self.current创建一个实例变量等于零。哇塞!我们完成了最艰难的部分。 下一站是add功能。我们只是在self和另一个参数称为amount。接下来，self就是实例，我们知道哪些实例。数字通过amount传入。使用我们以前的知识，我们明白，我们只是添加任何amount是当前变量。 最后，但并非最不重要的是，我们将这个想法从类中“获取”变量。为了获取self.current变量的值，最佳实践是把它放在一个函数，然后调用函数得到值，我们不应把它和实例混在一起。在实例中设置函数并传递，并告诉Python返回值。 使用Python类例子 1234567from ClassOne import * #get classes from ClassOne filemyBuddy = Calculator() # make myBuddy into a Calculator objectmyBuddy.add(2) #use myBuddy's new add method derived from the Calculator classprint(myBuddy.getCurrent()) #print myBuddy's current instance variable 在另一个文件中，我们输入了这个代码。一旦我们运行它，我们看到它打印2到我们的屏幕。所有的工作只是为了得到2的结果！无论如何，让我们打破这个家伙下来。首先，我假定你的两个类都在Python目录中。接下来，我们使用from ClassOne，让Python引用我们正在讨论的文件。然后，我们用import **声明。它只是意味着我们需要文件中的所有类。在我们的例子中，我们只有一个类，计算器类。下一步，我们创建了一个计算器的对象称为myBuddy并标示8myBuddy = Calculator()。现在，这给myBuddy拥有计算机类所有的变量和函数。（注：一旦myBuddy获取这些变量和函数，我们称之为属性和方法）。因为我们已经初始化了myBuddy，它具有current属性，在计算机类中叫做self.current.并被初始化为0.current。所以，现在我们调用myBuddy.add(2)，这是我们在计算器中的添加功能。简单地说，这只是0 + 2。最后，我们输出我们的实例的类变量self.current利用myBuddy.getcurrent()返回我们的变量。 做得好!这有点长。放轻松。这是编程的最困难的概念之一，封装。信不信由你，当你使用字符串，列表，字典等，他们都是从类出来的。从这里开始，你应该花些时间研究面向对象编程，并尝试将其应用到Python中。","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python15 Writing to Files","date":"2016-03-25T11:25:25.000Z","path":"2016/03/25/python15 Writing to Files/","text":"Python写入文件教程解释了如何使用Python编写文件。 阅读文件很酷，所有写入文件是一个很多的乐趣。它也应该给你带来一种危险感，因为你可以在一瞬间覆盖内容，失去一切。尽管有危险的威胁，我们也坚持下去。 Python使文件写入非常简单。有了类似的阅读方法，写作主要有两种写作方法。让我们来吧！ 警告！邪恶的“w”在打开的方法例 123f = open(\"test.txt\",\"w\") #opens file with name of \"test.txt\"f.close() …哎呀！正如所料，我们在这里是危险的环境朋友。一旦你把“w”作为第二个参数，你基本上就是告诉Python来调整当前的文件。现在我们已经清空了文件，我们来尝试重建它。 例 12345678910f = open(\"test.txt\",\"w\") #opens file with name of \"test.txt\"f.write(\"I am a test file.\")f.write(\"Maybe someday, he will promote me to a real file.\")f.write(\"Man, I long to be a real file\")f.write(\"and hang out with all my new real file friends.\")f.close() 如果您从上一个教程继续，我们只是重写了我们删除的内容到文件。但是，你可能会尖叫起来，“但是不一样！”你是100％正确，我的朋友。点击控制键几次，冷静，我会在一分钟内向您显示修复。最终，write（）方法真的很简单。你只需要传递一个字符串（或一个字符串变量），它会将它写入文件，然后按照它的单向处理方式。我们也注意到，它不会使用任何换行符来保持写作。让我们用另一种方法来解决这个问题。 将文字写入文件我们有一个相当简单的解决方案，只需在每个字符串的末尾放置一个新的行字符“\\ n”，如下所示： 例 1f.write(\"Maybe someday, he will promote me to a real file.\\n\") 这只是一个简单的文本格式化字符。是的，甚至文本文件都有一个特殊的格式，类似于HTML文档具有自己的特殊格式。文本文件比HTML更受限制。 附加到文件例 12345f = open(\"test.txt\",\"a\") #opens file with name of \"test.txt\"f.write(\"and can I get some pickles on that\")f.close() 哇！虽然我们的文本文件对于人是绝对没有意义的，但我们都知道我们只是取得了巨大的胜利。这里唯一的重大变化是在open（）方法中。我们现在有一个“a”（附加）而不是“w”。追加真的只是那么简单。现在跳出这，在全世界写我的朋友。","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python14 Reading Files","date":"2016-03-24T11:27:29.000Z","path":"2016/03/24/python14 Reading Files/","text":"Python阅读文件教程介绍了如何使用Python读取文件。 很多时候，程序员发现需要从文件中读取内容。可能是我们想从文本文件中读取，例如日志文件或XML文件以进行有效的数据检索。有时，确定如何完成这项工作是一项艰巨的任务。不用担心，Python总是有办法的，使阅读文件成为小事一件。 Python主要有2种方式阅读。为了保持简单，我们只是从文本文件中读取，随时可以自己探索XML。 XML是一个非常酷的标记，但随着你的深入，这是一个头痛的问题。示例如下： 在Python中打开文件test.txt I am a test file. Maybe someday, he will promote me to a real file. Man, I long to be a real file and hang out with all my new real file friends. 例 1f = open(\"test.txt\", \"r\") #opens file with name of \"test.txt\" 这很简单的解释。我们有一个令人敬畏的小的test.txt文件填充一些随机文本。现在，在这个例子中，我们有了我们的代码。就像你点击一个文件打开它，Python需要知道要打开什么文件。所以，我们使用open方法来告诉Python我们想要打开什么，并打开（连接）它。 “r”只是告诉我们想要阅读的Python（当我们想写入一个文件时，它是“w”）。当然，我们将这个新连接设置为一个变量，以便稍后再使用。但是，我们只打开一个文件，这不是令人兴奋的。我们来试试看读取文件。 Python文件读取方法file.read（n） - 该方法从文件读取n个字符，或者如果n为空，则读取整个文件。file.readline（n） - 此方法从文本文件读取整行。 例 12345f = open(\"test.txt\",\"r\") #opens file with name of \"test.txt\"print(f.read(1))print(f.read()) 结果 I am a test file. Maybe someday, he will promote me to a real file. Man, I long to be a real file and hang out with all my new real file friends. 哇哇！所以这可能有点混乱。首先，我们按预期打开文件。接下来，我们使用read（1），并注意到我们提供了1的参数，这意味着我们想要读取下一个字符。所以，Python为我们打印出“I”，因为这是test.txt文件中的第一个字符。接下来会发生什么事情呢？我们告诉Python用read（）读取整个文件，因为我们没有提供任何参数。但是，它不包括我们刚读的“I”！这是因为Python只是把它放弃了。所以，如果Python已经读了“I”，它将从下一个字符开始读取。原因是这样，您可以循环浏览文件，而无需每次想要读取新字符时跳过这么多字符。我知道这很复杂，但认为读取就像一个单向过程。 Python是懒惰的，它不想返回并重读内容。让我们进一步读取一下。 例 12345f = open(\"test.txt\",\"r\") #opens file with name of \"test.txt\"print(f.readline())print(f.readline()) 结果 I am a test file. Maybe someday, he will promote me to a real file. 哈！这一次我们为Python的诡计做好了准备。由于我们只是使用readline（）方法两次，我们知道由于Python的阅读过程，我们会得到前2行。当然，我们也知道readline（）只读一行，因为它的语法很简单。对Python的阅读能力来说，最后一个重要的，复杂的和令人敬畏的读取功能是好的。 例 123456789f = open(\"test.txt\",\"r\") #opens file with name of \"test.txt\"myList = []for line in f: myList.append(line)print(myList) 结果 [‘I am a test file.\\n’, ‘Maybe someday, he will promote me to a real file.\\n’, ‘Man, I long to be a real file\\n’, ‘and hang out with all my new real file friends.’] 什么！？ Python只是吹我们的头脑！首先，不要为 \\n惹恼。它只是一个换行符，因为这些行在不同的文件上，Python希望保留这种格式（您可以随时将其删除）。我们正常打开文件，我们创建一个列表，现在我们已经掌握了。然后，我们使用in关键字将文件分成我们for循环中的行。 Python足够聪明才能理解它应该将文件分解成行。接下来，当我们循环遍历文件的每一行时，我们使用myList.append（行）将每行添加到myList列表。最后，当我们打印出来时，Python向我们展示了它的荣耀。它将文件的每一行分解成一个字符串，我们可以操作它来做任何我们想要的。 等待！不要忘了关闭文件！例 1234567f = open(\"test.txt\",\"r\") #opens file with name of \"test.txt\"print(f.read(1))print(f.read())f.close() 保存到最后的重要事情是您应该始终使用close（）方法关闭文件。 Python在打开文件并阅读它们时消耗过大，因此暂停并关闭文件以结束连接。 关闭文件总是很好的习惯，你的内存会感谢你。 接下来，我们通过写入文件来做一些建设。","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python13 Exceptions","date":"2016-03-23T11:17:49.000Z","path":"2016/03/23/python13 Exceptions/","text":"Python异常教程解释了如何处理可能发生异常或错误的逻辑。在任何包含Python的编程中，当处理相当大量的变量时，异常和错误处理常常成为必要。当我说变量我不意味着变量作为一个占位符，但变量如你所使用的是使用文件系统进程（如读取文件），处理外部输入等。有时候，你只是不知道你的代码会抛出什么。提前计划，并在适当的时候使用异常和错误处理。通常，目标是按照预期执行代码，但是如果发生异常，我们更希望Python不会吐出自己的异常。相反，我们想通知用户使用我们的措辞以及可能如何在障碍物周围进行错误的操作。 异常与错误我知道我有关于异常和错误的说明，但是他们是什么，他们可能会有什么不同。那么，例外情况通常会处理你可能想要处理的小小问题。例如，也许你不完全知道变量的类型，但是你一定要用它来做某事。与数字和字符串做事情的差异是非常不同的。所以，你可能设置如下： 例 1234567891011var1 = '1' try: var1 = var1 + 1 # since var1 is a string, it cannot be added to the number 1 except: print(var1, \" is not a number\") #so we execute thisprint(var1) 真棒！我们完全捕获了python给了我们的异常。我们只需将try代码放在try块下执行。但是，如果发生异常（向整数添加一个字符串是一个异常），我们告诉Python在except块中执行所有操作。 那么什么是错误？坏消息，就是这些。你通常不想处理错误，除非你在做一些危险的事情。当产生错误时，通常意味着Python正在炸毁船舶，显然，如果船只被炸毁，我们应该跳船并退出程序。 此外，您可能已经注意到在此示例中print（）有两个参数。那么它可以打印你想要的参数。 print（）将继续打印所有参数，它们之间有一个空格。 优雅的错误处理让我们来看看我们的尝试/除了上述之外，并不会对程序的可用性做很多事情。基本上，如果它搞砸了，只是告诉我们的用户有什么问题。有什么要点？我们应该尝试以帮助程序继续前进的方式处理我们的异常。一个更好的选择将是这样的： 例 1234567891011var1 = '1'try: var2 = var1 + 1 # since var1 is a string, it cannot be added to the number 1 except: var2 = int(var1) + 1 print(var2) 啊，好多了在这个例子中，我们使用except捕获一个异常。但是，如果你运行这个例子，你会看到一些更令人敬畏的事情。我们实际上捕获了异常，并告诉python，“在添加之前，尝试将其转换为一个整数”，Python忠实地遵守这些异常。作为最终结果，Python打印出数字2，休息一下，打个小的嗝。","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python12 Formatting","date":"2016-03-22T11:15:45.000Z","path":"2016/03/22/python12 Formatting/","text":"我们花点时间来谈论格式化，因为它可能会变得有点激烈，你可以做多少，以及如何轻松地使用Python中的变量来做事情。首先，Python中的格式化有点奇怪。但是，一旦你习惯了，你会很高兴你做到了。 将数字格式化为字符串例 123print('The order total comes to %f' % 123.44)print('The order total comes to %.2f' % 123.444) 结果 The order total comes to 123.440000The order total comes to 123.44 雅，我告诉过你有点奇怪。在第一个％之后的f是float的缩写，因为我们有浮点数，Python有一种具体处理格式化小数的方法。左边的％告诉Python你想放置格式化的字符串。正确的％后面的值是我们要格式化的值。所以，Python读取字符串，直到它到达第一个％，然后Python停止并跳转到下一个％。 Python接受第二个％的值，并根据第一个％进行格式化。最后，Python将第二个值放在第一个％的位置。我们可以使用单个值，如字符串或数字。我们也可以使用一个元组或一个字典。好的，这很棒，但格式化字符串怎么样？ 格式化字符串字符串就像我们如何格式化上面的数字，除了我们将使用s代替字符串，而不是像以前一样。通常，您只需要格式化一个字符串来限制字符数。让我们看看它在行动： 例 123a =\"abcdefghijklmnopqrstuvwxyz\"print('%.20s' % a) 结果 abcdefghijklmnopqrst","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python11 Dictionaries","date":"2016-03-21T11:10:43.000Z","path":"2016/03/21/python11 Dictionaries/","text":"Python的字典在其他编程语言中并不常见。至少起初，他们似乎不正常。一些超级变量，如列表，数组等，隐含地将索引与其中的每个元素绑定。 Python的字典有这样的键，就像这些索引一样，但是有一些不同（我稍后再强调一下）。与这些键合并的是字典的实际值或元素。足够我的可怕的解释，让我们举个例子。 例 12myExample = &#123;'someItem': 2, 'otherItem': 20&#125;print(myExample['otherItem']) 结果 20 看，这有点奇怪吗？如果你试图成为一个超能力者，你可能已经尝试过像print（myExample [1]）。 Python会咬你的。词典不完全基于索引。当我向您展示如何编辑字典时，您将开始看到字典中没有特定的顺序。您可以添加一个键：值，它将显示在随机的地方。 这里要注意的是，您无法使用相同的键创建不同的值。 Python只会覆盖重复键的值。除了所有的警告之外，我们再向我们的myExample字典添加一些更多的关键字：值。 例 123456myExample = &#123;'someItem': 2, 'otherItem': 20&#125;myExample['newItem'] = 400for a in myExample: print (a) 结果 newItemotherItemsomeItem 字典如何无序？现在，您可能不认为它们是无序的，因为我的示例返回字母顺序。好吧，尝试用键名来看看它是否符合你的字母顺序。不会。无论如何，添加一个键：值真的很容易。将键放在括号中，并将其设置为等于该值。字典最后一件重要的事情。 例 12345myExample = &#123;'someItem': 2, 'otherItem': 20,'newItem':400&#125;for a in myExample: print (a, myExample[a]) 结果 （’newItem’，400） （’otherItem’，20） （’someItem’，2） 我们在这里所做的一切都是吐出我们整个字典。在列表中，当我们告诉Python打印我们的变量（在我们的例子中，它是a），它将打印出该值。然而，使用字典，它只会打印出关键。要获得该值，您必须使用字典名称后面的方括号中的键。词典有点混乱，但是值得你们耐心。他们是闪电般快速，非常有用。","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python10 Tupies","date":"2016-03-20T11:20:33.000Z","path":"2016/03/20/python10 Tupies/","text":"在Python中，元组与列表几乎相同。那么我们为什么要用它们呢？元组和列表之间的主要区别是元组不能更改。也就是说，您无法从元组添加，更改或删除元素。元组起初可能看起来很奇怪，但是它们背后有很大的理由是不可改变的。作为程序员，我们偶尔搞砸了。我们改变了我们不想改变的变量，有时候，我们只是希望事情是不变的，所以我们以后不会意外地改变它们。但是，如果我们改变主意，我们还可以将元组转换为列表或列表为元组。事实上，我们需要有意识地说Python，我想把这个元组改成一个列表，所以我可以修改它。我们来看看一个元组在行动！ 列表与元组 例 12345678910myList = [1,2,3]myList.append(4)print (myList)myTuple = (1,2,3)print (myTuple)myTuple2 = (1,2,3)myTuple2.append(4)print (myTuple2) 结果 [1, 2, 3, 4](1, 2, 3)Traceback (most recent call last): File “/Users/adu/Documents/My Drawings/test.py”, line 17, in myTuple2.append(4)AttributeError: ‘tuple’ object has no attribute ‘append’[Finished in 0.8s with exit code 1] 所以我们看到这个清单明显地按照预期工作。我们只是附加一个4到最后，Python不会错过一个节拍。接下来，我们测试我们的元组声明，它也是有效的。但是当我们尝试附加到元组时，Python给我们一个讨厌的小错误。就像我说的，你不能改变一个元组！如果您尝试使用诸如附加在元组上的东西，Python会咬你。但是，让我们说“嘿，我真的要给这个元组添加一个”。我们开始做吧： 例 1234myTuple = (1,2,3)myList = list(myTuple)myList.append(4)print (myList) 结果 [1，2，3，4] oyeah！我们已经成功地撤销了Python试图教我们不做的事情。我们只是将元组转换成列表，然后一旦列表，我们使用它的追加方法来添加4.应该重申的是，元组的目的是不可变的。如果您打算更改变量，只需使用列表。","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python9 Lists","date":"2016-03-19T11:25:13.000Z","path":"2016/03/19/python9 Lists/","text":"Python没有数组但是有列表。列表是超级动态的，因为它们允许您在其中存储多个“变量”。列表具有允许您操纵其中的值的方法。这里真的有一点要告诉你，让我们来看看吧。 例 12sampleList = [1,2,3,4,5,6,7,8]print(sampleList[1]) 结果 2 括号只是索引号的指示。像大多数编程语言一样，Python的索引从0开始。所以在这个例子中，1是列表中的第二个数字。当然，这是一个数字列表，但你也可以做一个字符串列表，甚至混合匹配，如果你真的想（不是最好的想法）。好的，现在看看我们是否可以打印整个列表。 例 12345sampleList = [1,2,3,4,5,6,7,8]print(sampleList[1])for x in sampleList: print(x) 结果 12345678 基本上，变量x是列表中的实际元素。我们递增隐式索引。 通用列表方法有很多方法用于列表，但是我们至少将介绍如何添加和删除项目。所有的列表方法都可以在Python的文档网站上找到。方法遵循列表名称。在语句listName.append（2）中，append（）是方法。 .append（value） - 将元素追加到列表的末尾.count（’x’） - 计算列表中“x”的出现次数.index（’x’） - 返回列表中“x”的索引.insert（’y’，’x’） - 在’y’的位置插入’x’.pop（） - 返回最后一个元素，然后将其从列表中删除.remove（’x’） - 从列表中查找并删除第一个“x”.reverse（） - 反转列表中的元素.sort（） - 按升序按字母顺序排列列表，或按升序排序 尝试玩几个方法来获得列表的感觉。它们是相当简单的，但它们对于了解如何利用Python的力量非常重要。","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python8 Strings","date":"2016-03-18T11:26:18.000Z","path":"2016/03/18/python8 Strings/","text":"与任何编程语言一样，字符串是关于Python的最重要的一部分。此外，正如我们迄今为止在其他语言中所经历的，字符串包含字符。如果使用得当，它们几乎可以包含任何东西。你们放置的字符数量也不会有问题。快速示例！ 例 123myString = \"\"print (type(myString)) 结果 type（）很棒。它返回括号内的任何变量类型，这是非常有用的，如果你有一些错误，你不能弄清楚，或者你没有看到一大段代码一段时间，不知道什么类型变量是。回到字符串中的字符数量，我们可以看到一个空的“”返回的字符串。字符串是强大的，很容易声明。我们来看一些常见的字符串方法，以便您快速上手。 Python中的常见字符串方法stringVar.count（’x’） - 计算stringVar中出现的“x”的数量stringVar.find（’x’） - 返回字符’x’的位置stringVar.lower（） - 以小写形式返回stringVar（这是临时的）stringVar.upper（） - 返回大写字符串（这是临时的）stringVar.replace（’a’，’b’） - 替换字符串中与b的所有出现stringVar.strip（） - 从字符串中删除前导/尾随的空格 字符串索引关于Python的一个非常酷的事情是，几乎所有的东西都可以通过索引和字符串来分解。使用字符串，索引实际上是字符。你可以抓住一个字符，或者你可以指定一个字符范围。 例 12345a = \"string\"print (a[1:3])print (a[:-1]) 结果 TR strin 我们来讨论一下print（a [1：3]），因为这是最简单的解释。请记住，Python从0开始所有索引，这将是我们的变量a中的’s’。所以，我们打印出“tr”，因为我们打印的所有内容都是3，但不包括3。对于第二个例子，欢迎来到Python的一个很好的部分。实际上，在a之后指定一个负数：在索引中意味着您希望python从最后开始计算索引并向前移动。所以，我们告诉python我们希望从第一个字符到倒数第二个字符。喘着气，你赚了","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python7 Loops","date":"2016-03-17T11:16:10.000Z","path":"2016/03/17/python7 Loops/","text":"for loops是时候介绍Python的一个很棒的部分。与其他语言相比，Python的for循环是非常惊人的，因为它们是多才多艺的。一个for循环的想法是相当简单的，你只需循环一些代码一定次数。举个例子： 例 12for a in xrange(1,3): print(a) 结果 12 首先，print是缩进的一个原因。记住Python对于间距是很挑剔的。了解这个例子中是有点复杂的。在这种情况下，a是一个变量，每次我们遍历循环时都会自动递增。接下来，我们使用range关键字在完成之后立即设置起点和点。这正是为什么第3号没有打印。 Python非常喜欢这个想法，直到一个数字，但不包括它。 另外，请注意in关键字。这实际上是for循环的一部分，在处理列表和字典之后，您将会更了解它。所以基本上面的for循环说：“对于变量a，每个循环结束时都会增加，在1到3的范围内。” White loopsWhite 循环在Python中的循环可以非常类似于for循环，如果你真的想要它们。基本上，他们都循环了一段时间，但一段时间的循环可能更模糊（稍后我会讨论一下）。通常，在while循环中，您将有一个条件，后跟一些语句，然后在该条件中增加变量。让我们看一眼，真的很快： 例 12345a = 1while a &lt; 10: print (a) a+=1 结果 123456789 这里很简单，我们的条件是一个&lt;10，一个先前被声明并设置为等于1.所以，我们的第一个打印出来的项目是1，这是有道理的。接下来，我们增加一个并再次运行循环。当然，一旦a等于10，我们就不会再循环了。 while循环的令人敬畏的部分是事实，您可以将其设置为始终满足像1 == 1的条件，这意味着代码将永远运行！为什么那么酷？这是真棒，因为你创建规则。需要注意的是，你正在创建一个无限循环，这将使任何正常的程序员非常紧张。 do-while循环在哪里 简单的回答，它不是在Python中。在编写循环之前，您需要考虑这一点。不是一直以来常常使用do-while循环，但是Python目前没有任何支持。","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python6 If Statement","date":"2016-03-16T11:19:11.000Z","path":"2016/03/16/python6 If Statement/","text":"在编程逻辑的核心，我们在Python中有if语句。 if语句是一个条件，当它满足时，执行一部分代码。通常与if语句合作if和else。并且语句后面用:结尾，Python的elseif被缩短为elif。if语句通常与变量相结合以产生更多的动态内容。让我们举个栗子。 12345678a = 20if a &gt;= 22: print(\"if\")elif a &gt;= 21: print(\"elif\")else: print(\"else\") 结果else 所以，我们有变量a等于二十。现在，我们通过if语句来运行它来检查一个是否大于或等于22.不是。所以我们跳过了内部的print语句，继续执行elif语句。此条件检查a是否大于或等于21.它不是，这使我们进入了扩展if语句的最后一行。else符合条件，这意味着如果以前的条件不满足，我们将在其中运行代码。所以，我们运行print（“else”），我们在结果中看到字符串else。 if语法 在上面的例子中你可能会错过的最重要的是Python的语法比其他语言更清晰。然而，这也意味着它非常挑剔，倾向于咬住初学者错误。每一个条件我们都有一个冒号。接下来，您必须继续使用4个空格的新行来告诉Python，只有当前面的条件满足时，您才希望运行4个空格的代码。好的，它不一定是4个空格，但你必须与你用于缩进的空格保持一致。你可以每次使用3次，如果你想要的，但4是一种标准。此外，如果您希望在条件满足后运行多个语句，则必须在下一个语句之前具有相同数量的空格的新行。","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python5 Functions","date":"2016-03-15T11:19:56.000Z","path":"2016/03/15/python5 Functions/","text":"Python中的函数在分离代码方面是非常有用的，但它们并不会停止。你认为任何其他地方都会使用的代码，你应该放在一个函数中。您还可以为函数添加参数以具有更多灵活的功能，但是我们将在此稍加讨论。您可以在函数名称之前使用关键字def来定义函数。我们使用我们的第一个Python函数。 例 123def sayHi(): print(\"Hi Janes\")sayHi() 结果Hi Janes 在调用它们之前需要定义函数。即使我们必须在读取时跳过该函数来查看第一个语句sayHi()。这会把我们备份到def sayHi（）:,再次跟随一个冒号。然后在我们确认该函数被调用后，我们为简单的print语句创建一个新行，其中有四个空格。 具有参数的函数 上面简单的功能很棒，可以很常用。然而，通常会出现一个时间，我们希望将该功能作用于用户输入的数据。我们可以用（）中的参数来做这个，跟随函数名。 例 123def sayHi(name): print(\"Hi \" + name)sayHi(\"Janes\") 结果 Hi Janes使用语句sayHi(“Janes”)我们传递”Janes”，这成为我们的函数。然后，我们只需要一些打印语句，添加它们并打印出来。 函数作用域 Python不支持全局变量，而不必明确表示它们是全局变量。显示而不是解释要容易得多： 例 123456def someFunction(): z = 10someFunction()print (z) 打印这将导致错误，因为我们的变量z位于someFunction的本地范围。所以，当我们尝试打印一个，Python会报错，说一个变量没有定义。从技术上讲，它是定义的，但并不在全局范围内。现在，我们来看一个有用的例子。 例 1234567s = 10 def someFunction(): print (s)someFunction() 在这个例子中，我们在全局范围内定义了一个。这意味着我们可以调用它或从任何地方编辑它，包括内部函数。但是，您无法在函数范围内声明一个变量，这个变量在全局范围内被外部使用。","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python4 Operators","date":"2016-03-13T11:10:22.000Z","path":"2016/03/13/python4 Operators/","text":"python 的操作符和其他语言一样，编程语言中的运算符用于模糊地描述5个不用的领域：算术，复制，递增/递减，比较，逻辑。 算术运算符1234567print(1 + 2)print(1 - 2)print(1 * 2)print(1 / 2)print(1 % 2)print(1 ** 2) # 1 to the twice powerprint(1 // 2) # floor division 结果3-120110 正如所料，他们按预期工作。不要忘记你可以使用+号来连接字符串。最后，（//）相除并取整 简写运算符和之前的语言一样，python 也是支持简写，举个栗子 123a = 1a+=2print(a) 结果2 当然，你可以使用任何之前的算术运算符作为赋值运算符，之后是=我们只是告诉Python将值添加为2，而不必像a = a + 2那样说。我们是程序员，我们很自豪被称为懒惰！","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python3 Strings","date":"2016-03-12T11:08:12.000Z","path":"2016/03/12/python3 Strings/","text":"python 的文本类型可以用’‘或””或“”““””标示文本。 123a = \"0\"b = \"2\"print(a + b) 字符串的操作替换字符串 123x = \"Hello World\"x = x.replace(\"World\", \"Python\")print(x) 打印一个字符 12x = \"Hello World\"print(x[0]) 打印多个字符 12x = \"Hello World\"print(x[0:4]) 字符串大小写 12x = \"Hello World\"print(x.upper()) 12x = \"Hello World\"print(x.lower()) 字符串比较123456x = \"Hello World\"if x == \"Hello World\": print(\"ok\")else: print(\"False\") 字符串查找 1234x = \"All work and non play make jack all dull boy\"if \"work\" in x: print(\"Found!\") 字符串换行输出 12x = \"All work \\nand non play make jack all dull boy\"print(x) 转义\\ 12x = \"All work \\\\nand non play make jack all dull boy\"print(x)","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python2Variables","date":"2016-03-11T11:28:10.000Z","path":"2016/03/11/python2Variables/","text":"Booleans,integers and floats不用事先声明数据类型，指向什么就是什么类型。 12switch = Falseprint(switch) integers 123x = 123y = 1.35462print(x, y) print输出多个值，用逗号隔开 Python提供了强大的math库 123import mathx = math.sqrt(3)print(x) impotr 引进类库","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python1Introduction&Install","date":"2016-03-10T11:18:12.000Z","path":"2016/03/10/python1Introduction&Installa/","text":"Python 简介Python 是一个有条理的和强大的面向对象的程序设计语言，类似于Perl, Ruby, Scheme, 或 Java. Python的一些显著特点： 使用优美的语法，使你编写的程序更加易读。一种易用的程序语言，使用她可以容易地编写出你的程序。这使得Python目标为原型开发和其他特别编程任务，同时不损害其可维护性。一个大型的标准库支持许多常见编程任务,诸如连接到Web服务器、 正则表达式全文检索、阅读及修改文件。Python的互交模式使她容易测试小片断的代码。也有一个叫做IDLE的捆绑式开发环境。易于将新的模块扩展到如C或者C++的汇编语言中。能过嵌入到一个应用程序，为应用程序提供可编程接口。可以运行许多不同的计算机和操作系统：Windows, MacOS, 各种Unix发行版, OS/2, …在以下两层意义中是免费的软件。不需要花费任何费用就可以下载、使用或者开发程序。虽然这个语言受著作权保护，但是遵循开发式源代码协议，因此Python也可以被自由修改和重新发布。Python的编程语言特点： 可以使用多种基本数据类型： 数字(浮动小数点，复数和无限长度的长整数)，字符串(ASCII和Unicode)，列表和字典。Python支持类的面向对象的编程技术和多重继承性代码可以被加载到模块和包中。支持错误捕捉（原文The language supports raising and catching exceptions, resulting in cleaner error handling.）数据类型strongly and dynamically typed。 混合的不相容的类型(e。g. 试图增加串和数字)将造成一个异常，如此错误被捕捉。Python包含先进的编程特点如生成程序和列表。Python的自动内存管理，把你从必须手工分配和释放内存的代码中解救出来。 Python 安装Python提供了多个平台的版本，Windows, Linux/UNIX, Mac OS X, Other 你可以在 Python Downloads中找到 愉快的玩耍吧安装完后，打开控制台键入python你可以看到Python的版本信息等。和Python 命令提示符&gt;&gt;&gt;一般学习新的一门语言都是从“Hello World！”开始的。直接键入print(&#39;hello python!&#39;）回车，你可以看到屏幕输出：hello python！你可以在上面随便输入1+23x = 2y = 3x + y5 Python IDE什么？场地不够大不能愉快的玩耍。恩，你需要一个集成开发环境,在下面地址中挑选一款喜欢的IDE Python文件是以 .py 结尾的，新建文件如hello.py print(&#39;hello python!&#39;) 然后bulid，控制台输出 hello python! 注释单行注释用 #多行注释用 ‘’’注释内容’’’ 12345#print(\"comments\")'''print(\"comments\")print(\"other comments\")''' 脚本可以把python当做一个可执行的脚本， 12#!/usr/bin/env python3print('hello python!') 指定python3来解释执行,也可以用默认的python来执行。 需要修改上面程序的权限为可执行： 1chmod 755 hello.py 然后再命令行中，输入 1./hello.py","tags":[{"name":"Python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"给糖or给棒","date":"2015-10-15T11:18:12.000Z","path":"2015/10/15/给糖or给棒/","text":"在团队中，团队的成员大部分都是由自诩程序猿（并以此为豪）组成的。个别的测试人员不懂程序，但他们也经常和程序猿混在一起。（一起吃饭，一起打野，一起撸串…）“按照他们喜欢的被管理的方式去管理”这样的黄金法则对他们是很适用的。 程序猿向往自由，不喜欢太多（一点也不）的约束。有时候和公司的制度很难走到一起。他们不喜欢条条框框的东西，也不擅长这些东西。相反，他们更愿意把时间花在研究技术上面。他们工作起来还是很专注的，兢兢业业的！在最近还是学到了不少好的管理方法，值得记录下来。 在开周会上，A君汇报了这周的工作，得到了肯定，获得了表杨。B君和A君是相同的职务，这周表现平平。到了下周，A君自信满满，以为还能获得表扬。这时，即使A君工作的再好也不当在表扬了。在表扬会使A君过度膨胀，B君更加消沉，并非好事。此时应该多鼓励B君，适当忽略A君，并对A提更高的要求。 之前看过一个故事，大体的意思是这样的。一个工厂里有甲乙两个生产队，管理者因为生产效率上不去而犯愁。于是有人出点子，当甲生产队工作时，在里面立牌子赞扬乙生产队效率高。结果甲的生产效率上去了。相反，当乙生产队工作时，在里面立牌子赞扬甲生产队效率高。结果乙的生产效率也提高了。这个故事恰恰反映了国人的心理，输人不输阵！ 管理好他们能带来很好的效果。合适的“给糖”，能提高效率。","tags":[{"name":"项目管理，软技能","slug":"项目管理，软技能","permalink":"http://yoursite.com/tags/项目管理，软技能/"}]},{"title":"行之有效的站会","date":"2015-09-10T11:19:11.000Z","path":"2015/09/10/行之有效的站会/","text":"最近项目很赶，需要有效的让每个人点后知晓最新项目状态、遇到的困难和发现潜在的障碍。于是我就提出来，每天早上九点半(吃好早餐，做充分的准备)开始站会，时间控制在15分钟左右。每个人依次阐述三个预定的问题： 昨天我完成了什么？ 今天要去做什么？ 团队遇到了什么阻力？ 这样可以快速的了解昨天的进度，今天的计划是否按原定计划走，团队遇到的困难需要及时协助解决的。以防在上面花费了过多的时间。当项目赶时，时间就决定了项目能否按时交付。 在实施过程中，偶尔出现了昨天的任务有个别落下的，今天优先处理落下的任务，再提高效率把今天的完成。今天要去做什么，主要是明确今天的任务，以防有落掉的。在忙起来的时候，工程师还真会把任务落掉！团队遇到了什么阻力？主要还是出现了衔接的问题。流水线工作，上游的工作进度直接影响了下游的工作进度。这就需要在统筹优先级。还有就是一些第三方的要提前申请，以免外界不可控的因素影响了整个项目的进度。","tags":[{"name":"项目管理，软技能","slug":"项目管理，软技能","permalink":"http://yoursite.com/tags/项目管理，软技能/"}]},{"title":"App-store转让App","date":"2015-08-22T07:44:42.000Z","path":"2015/08/22/App-store转让App/","text":"有时候需要转让App到别的账号下，需要注意的是只有符合条件的App才能转让。由于App store里面应用名字的唯一性，当你新建了应用还没来得急上传，想把它过度到另外账号下只能等第一个版本审核通过后才能操作。 符合条件的才行 填写账号 Team ID在这 同意就行 登录另一个账号 填写信息，接收就可以了。应用马上就过来了，但App store上的信息还要等apple 服务器同步才行。","tags":[{"name":"iTunesconnect,","slug":"itunesconnect","permalink":"http://yoursite.com/tags/itunesconnect/"}]},{"title":"Best Practices for IT Project Managers","date":"2015-06-02T11:43:12.000Z","path":"2015/06/02/Best Practices for IT Project Managers/","text":"–Posted by: Jenna Puckett Depending on which “shocking project management statistics” article you read, you’ll find failure rates for large IT projects range anywhere from 31 and 96 percent. Like a game of telephone, you never know what abysmal results consultants will reveal when surveying technology project budgets, schedules and objectives. Regardless of the exact percentage though, the message is clear: Too many IT projects fail. Project management vs project management for IT teamsIT project management is a nuanced and complex branch of project management. Traditional project management endeavors often result in tangible results—a space station is built, damage from a natural disaster is recovered, the Olympic Games are played. But IT project managers must bring an organization’s information technology goals to fruition through detailed tasks such as: Upgrading networksMerging multiple databasesRemoving outdated serversInstalling new hardwareDeploying virtualizationCreating new desktop imagesDeveloping custom websites or softwareImplementing business analytics or cloud computing servicesSuccessfully merging multiple databases in order to improve customer service is not nearly as grandiose to the non-technical as a new product launch. But that doesn’t mean it’s any less important. Although IT projects require the five process groups universal to all projects—initiation, planning, execution, monitoring and controlling—they are further complicated by unique business and industry challenges. Why IT projects failWhen 36 – 91 percent of IT projects fail, such a wide percentage gap begs the question: Do a large number of IT projects fail, or do we only hear about the bad news? Unfortunately, even if it’s exaggerated, IT project failure is far from occasional. This is because in addition to usual project challenges, IT project managers are further plagued by shifting business needs and constantly evolving technology. They must address: Technology advances during the project’s executionInfrastructure changes that impact security and data managementInteroperability issues, vendor configuration changes, and unknown dependencies between hardware, software, networks or dataThe first-time, first-use penalty which is the learning curve you must overcome when you do something new for the first time. There is almost always a first-time first-use scenario somewhere in an IT project, yet it’s often dismissed as a non-issue.IT project managers should follow the best practices outlined below to overcome the complexity and variability of IT systems and reduce the risk of costly rework. Develop a standard processEstablishing a repeatable method may seem like Project Management 101, and that’s because it is. Yet failure to follow a streamlined process is a common mistake that increases the risk associated with IT projects. If you have no baseline standards or defined phases to move the project forward, then you lack the ability to measure—and even define—project success. A standard project methodology eliminates many issues that can snowball out of control later, such as failure to define project scope, necessary roles and associated responsibilities. Clearly defined project objectives and requirements lay the foundation for a realistic plan with effective handoffs between teams and work phases—which leads to a successful project. If your problem isn’t defined, then you can’t create a project that project solves it. Reinforce your processOnce you have a streamlined workflow, invest in technology and IT software that bolsters it. Project management tools help centralize all project-related information, which increases visibility across the project, and provides valuable historical data. These systems help IT project managers and team leaders see what everyone is working on, so they know if a project is moving forward, or if additional tasks can be assigned. This visibility also increases communication and keeps everyone focused on a common goal. Analytics and simple data visualizations help show important project information as it happens, so teams can immediately take corrective action if a project veers off course. When project details are spread across multiple spreadsheets, apps, and inboxes, it leads to conflicting data, inaccurate information, and status reports that are outdated as soon as they’re pulled. Project management software provides a single source for information, which not only helps monitor current initiatives, but can be used to accurately document progress and lessons learned, which improves resource planning for future projects. Hire the right peopleYou need a team capable of executing your project plan; no amount of planning or technology will overcome a shortage of necessary skills. Again, the right project management platform can help provide visibility into the skills and workloads of your team, and also help evaluate performance and assess skills for future work. If you don’t have the necessary skills available, considering outsourcing or hiring a consultant to contribute to the project. Another option is to reallocate resources to a different initiative, while you search for IT staff to add to your in-house team. Communicate openlyCompanies often rely on technology to gain a competitive edge. But pressure to cut costs or meet strict deadlines can lead to unrealistic project expectations, and ultimately failure. A rushed software implementation can result in lack of user adoption, loss of business if rolled out during a busy season, and inadequate system testing. It’s an IT project manager’s job to push back on unreasonable deadlines or scope and clearly communicate the associated risks to project stakeholders. Maintain core competenciesAbove all else, it’s critical that IT project managers stay up to date on the essential project management knowledge areas: scope, schedule, costs, quality, HR, communications, risk, procurement, stakeholder, and integration management. Aside from procurement, these are present in all IT projects, so managers should be prepared to shift to the competency that is analogous to the project’s current needs. Don’t contribute to the latest shocking project failure rates. Follow these best practices to successfully handle the complexity and variety of IT initiatives. Here’s another important skill to master when you’re managing technical projects: being able to make accurate project estimates. It’s an art, a science; it takes practice and trial-and-error. If you can get it right, you’ll be the star of your organization. To learn more, download our eBook, “5 Best Practices for Accurate Project Estimates.”","tags":[{"name":"项目管理，软技能","slug":"项目管理，软技能","permalink":"http://yoursite.com/tags/项目管理，软技能/"}]},{"title":"5 Best Practices for Managing Large IT Projects","date":"2015-04-15T11:18:12.000Z","path":"2015/04/15/5 Best Practices for Managing Large IT Projects/","text":"–Posted by: Susanne Madsen If you’re embarking on a large technology project, there’s a lot at stake. IT projects are technically challenging and can easily go on for more than 10 or 12 months. Team members are highly specialized and are often spread between different locations and across time zones. According to a McKinsey &amp; Company article, “Delivering large-scale IT projects on time, on budget, and on value” by Michael Bloch, Sven Blumberg, and Jürgen Laartz, the average large IT projects run 45 percent over budget and 7 percent over time, while delivering 56 percent less value than predicted. Some of these mismanaged projects can put the whole organization in jeopardy. You don’t want to be part of that losing statistic. In order to get a head start and be successful in managing a large-scale IT venture, here are five important considerations to put into action when leading a technical project that has a lot at stake for a lot of people. Have a strong technical leadLarge technology projects are complex and often require that multiple technologies and components are designed and integrated into a tailored solution. Such projects contain a lot of uncertainty and rarely go according to plan as new information emerges throughout the project’s lifecycle. In order for the project to be successful, you must have access to a strong technical lead who you can rely on to manage this complexity. Without a strong technical, lead the project’s foundation will be weak; and you, as the project manager will be forced to make decisions and plan the project based on poor information. Consider the following questions when choosing a strong technical lead: How strong is the technical lead on your current project?Does the person have a track record of successfully managing challenging technical solutions?If not, what can you do to mitigate this risk?To what extent are you able to influence who gets selected as technical lead?Have a solid project management process in placeBecause large IT projects are risky, complex and carry a significant budget, they require a more structured project management process than smaller projects. I coach many project managers who improvise when it comes to project management processes. As a result, they end up firefighting and dealing with the fallout of poor planning. On a large project you’ll lose control very quickly if you’re not sufficiently structured. To succeed at managing your IT project, have an agreed method for defining requirements, estimating and planning work, identifying and managing risks, escalating issues, managing changes and reporting progress. Better yet, have project management software that works for your organization and the needs of your clients. You can’t rely on chance or goodwill to get through a complex project. Questions to consider: Are your project management processes sufficiently defined?Does your project management platform or process help your team manage all the complexities of a large IT project?Have you validated the project management processes with your colleagues?Have you learned from similar projects in the past?Be iterativeAgile has been a buzzword for several years and has even spread to industries outside of technology circles where Agile was first invented. Many managers are keen to jump onto the Agile bandwagon and to switch from a Waterfall to an Agile delivery method. But the question isn’t whether your project should be Agile or not. That’s like asking if you should live in a skyscraper in the city or a farmhouse in the countryside without considering all the options in between! Whereas some IT projects will benefit from making use of Agile practices, many are simply too large to be fully Agile. It’s more useful to ask how flexible your approach should be. The traditional Waterfall methodology can be risky, as the customer only gets to see and interact with the product at the end of the project. With Agile’s iterative development, you split the project into discrete phases that each conclude with a tangible deliverable. It’s a great way to manage complexity for large IT projects that aren’t suited to a fully Agile structure. Questions to consider: In which ways are you moving away from a Waterfall methodology and allowing for a flexible approach?How many phases will your project consist of and in which ways will you deliver your product incrementally?Which method works best for your organization and your customers’/clients’ needs?To help you decide between Agile and Waterfall read this article or check out this infographic. Be impeccable with system integration testingMultiple components need to be designed and integrated on large technology projects, which means testing is always imperative. Some teams rely on their developers for testing the solution, but in reality no one is great at QA’ing their own work. The best option will always be a dedicated test team. Allocate time in the schedule for this essential activity. On some projects testing is left for the users to carry out, but the result can be detrimental as the users reject the product based on too many errors. User testing should be a high-level validation of the product rather than a system test. Questions to consider: Have you allocated enough time in the schedule for integration and system testing of the product before it’s passed over to the users for validation?Does your test team consist of experienced testers rather than developers or users?How will you know when the QA is complete and can move on?Have an approved decision-making structureOn large IT projects, the landscape can quickly change as unexpected technical problems occur. Decisions need to be made in a timely and effective manner; there’s really no room for hold-ups and for teams to wait for direction. You need effective decision-making at every level, especially since large IT projects means you’re probably working with multiple teams in multiple locations. You can keep the decision-making process active by organizing weekly working group meeting(s) for team leads, in addition to monthly steering committee meetings for executives. The purpose of the working group meetings is for team leads and business leads to make decisions about detailed requirements and imminent issues. The purpose of the more infrequent steering committee meetings is to inform the committee about progress and for the executive sponsor to make decisions escalated by the working group. Many projects fail due to lack of buy-in and access to decision-makers. A locked down decision-making structure is one of the best ways to mitigate that. Questions to consider: What is the decision-making structure on your project?Is it effective?Are the representatives empowered to make decisions at their level on behalf of their respective teams and business areas?Large IT projects are too big, risky and complex to simply rely on the team to roll up their sleeves and get on with the work. These types of projects have to be particularly well staffed, planned, executed and quality controlled in order to be successful. Make sure you know all the considerations you need to think through before launching your project and during the life of it. Managing resources effectively is another important skill when it comes to successfully leading large IT projects. To learn more, download our eBook, “5 Best Practices to Manage Project Resources Effectively.”","tags":[{"name":"项目管理，软技能","slug":"项目管理，软技能","permalink":"http://yoursite.com/tags/项目管理，软技能/"}]},{"title":"10 Steps to Manage Your Budget When the Scope Changes","date":"2015-01-16T11:18:12.000Z","path":"2015/01/16/10 Steps to Manage Your Budget When the Scope Changes/","text":"–Posted by: Tim Clark If your budget is the roadmap to completing the project, what happens when the destination changes? You assess where you are, and how you got there, then redo the budget to complete the journey. Managing resources is filled with surprises. Change orders in projects are the norm, not the exception, so the seasoned project manager won’t be stumped by recasting the budget to account for altered objectives. How well you can adjust your budget to a scope change depends on how well you budgeted the project in the first place. Here are 10 steps to updating your project budget when the project scope changes. Start with the work completed.See how the project plan looks when you add the new objectives. How many more resources do you need? Then see what can be tweaked to keep you on or close to budget with the new objectives, e.g., removing nice-to-have features from a software project. If some completed work can’t be used, don’t jettison it too quickly. Put that work on hold—you never know when objectives may change again, and your management may be able to collect for work completed from the customer. Compare your budget to actual spending.Identify how much of the original budget has been spent, and how much remains. If you’re using a good project management tool you should be able to figure this out pretty quickly. This information gives you a reality check of where you stand versus budget. And don’t forget: Focus on the big variances from budget; don’t sweat the small stuff. Scrutinize scope.Assess whether the change order affects your deliverables, and if it consequently affects the resources to produce those deliverables. Determine how the change order will affect costs.Project change orders often come with an updated budget—so you could be facing more money allocated, or less. Either way, the project manager’s approach doesn’t differ greatly here (except maybe in the stress department). Bottom line: Determine how much funding is needed to achieve the new objectives. Negotiate with your client.Once you know how much your project will cost to complete with the change order, it’s time to let the client know. This probably means some negotiation is going to take place. Whoever is asking for the changes might start from a weakened position, especially when the unsaid part of the conversation is, Why didn’t you ask for this in the first place? At this point you can negotiate on the budget or the scope—or both. If you’ve done your homework, bring up any specific elements of the deliverables that would be difficult or costly. Give the client the full picture and try to make the conversation show that you’re in this together, and not working against each other. Renegotiate with outside contractors if needed.If the change increases project scope, you might need to hire outside resources. If the budget is slashed, you face the delicate task of reducing the amount of work for your contractors, and even laying some off, while keeping the team motivated and focused on meeting the new deliverables. Be transparent.Keep your team informed of all change orders and budget updates. Team members want to know how the changes will affect them. Let them know so they can focus on their work, rather than worrying about what’s going to become of the project (and their contribution to it). Furthermore, when you’re open about scope changes, team members can contribute ideas and solutions. Design a new work plan.Keep your team focused on the new deliverables. Use a project planning software to outline the plan so individuals can recalibrate what they must do and when they need to finish their work by. Continue to manage project scope.The change order gives the project a new scope, but that doesn’t mean you’re immune from any future scope creep that can wreak havoc on your budget. Try to put yourself in a proactive position, rather than a reactive one. Manage client expectations.A change order process can make your client more anxious than usual to see how you deliver. Keep your client updated and communicate clearly about how the project is progressing—and how any possible glitches might affect the timeline. The first few status meetings or reports after a change order take on greater importance for the project manager, team, client and your organization. The more you stay in touch with your client, the fewer unpleasant surprises you have to deliver. Which is good for everyone.","tags":[{"name":"项目管理，软技能","slug":"项目管理，软技能","permalink":"http://yoursite.com/tags/项目管理，软技能/"}]},{"title":"Cornerstone ignore UserInterfaceState.xcuserstate","date":"2014-11-21T09:18:44.000Z","path":"2014/11/21/Cornerstone-ignore-UserInterfaceState.xcuserstate/","text":"在控制台 cd 到项目目录下svn -v status 查看文件的状态(M): M 33769 33757 xxx XXX.xcworkspace/xcuserdata/XXX.xcuserdatad/UserInterfaceState.xcuserstate svn delete --keep-local --force xcuserdata/user.xcuserdatad/UserInterfaceState.xcuserstate 此时，Cornerstone会显示它的状态为”？”,右键Ignore。解决了，世界清静了:] PS:added .xcuserstate to the Global Ignores (Cornerstone -&gt; Preferences -&gt; Subversion -&gt; turn off Use default global ignores -&gt; add “\\.xcuserstate”)","tags":[{"name":"xcode","slug":"xcode","permalink":"http://yoursite.com/tags/xcode/"},{"name":"svn","slug":"svn","permalink":"http://yoursite.com/tags/svn/"},{"name":"tutorial","slug":"tutorial","permalink":"http://yoursite.com/tags/tutorial/"}]},{"title":"REST","date":"2014-09-10T11:28:13.000Z","path":"2014/09/10/REST/","text":"REST（英文：Representational State Transfer，又称具象状态传输）是Roy Thomas Fielding博士于2000年在他的博士论文[1] 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务执行图书查询；雅虎提供的Web服务也是REST风格的。 要点及标准需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。 资源是由URI来指定。 对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。 通过操作资源的表现形式来操作资源。 资源的表现形式则是XML或者HTML，取决于读者是机器还是人，是消费web服务的客户软件还是web浏览器。当然也可以是任何其他的格式。 REST的要求 客户端和服务器结构 连接协议具有无状态性 能够利用Cache机制增进性能 一致性的操作界面 层次化的系统 所需代码 - Javascript（可选） 具体说明REST架构风格最重要的架构约束有6个[2]： 客户-服务器（Client-Server） 通信只能由客户端单方面发起，表现为请求-响应的形式。 无状态（Stateless） 通信的会话状态（Session State）应该全部由客户端负责维护。 缓存（Cache） 响应内容可以在通信链的某处被缓存，以改善网络效率。 统一接口（Uniform Interface） 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性。 分层系统（Layered System） 通过限制组件的行为（即每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。 按需代码（Code-On-Demand，可选） 支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。 关于状态应该注意区别应用的状态和连接协议的状态。HTTP连接是无状态的（也就是不记录每个连接的信息），而REST传输会包含应用的所有状态信息，因此可以大幅降低对HTTP连接的重复请求资源消耗。 应用于Web服务符合REST设计风格的Web API称为RESTful API。它从以下三个方面资源进行定义： 直观简短的资源地址：URI，比如：http://example.com/resources/。 传输的资源：Web服务接受与返回的互联网媒体类型，比如：JSON，XML，YAML等。 对资源的操作：Web服务在该资源上所支持的一系列请求方法（比如：POST，GET，PUT或DELETE）。 下表列出了在实现RESTful API时HTTP请求方法的典型用途。 HTTP请求方法在RESTful API中的典型应用资源 | GET | PUT | POST | DELETE 一组资源的URI，比如http://example.com/resources/|列出URI，以及该资源组中每个资源的详细信息（后者可选）。|使用给定的一组资源替换当前整组资源。| 在本组资源中创建/追加一个新的资源。该操作往往返回新资源的URL。|删除整组资源。单个资源的URI，比如http://example.com/resources/142|获取指定的资源的详细信息，格式可以自选一个合适的网络媒体类型（比如：XML、JSON等）|替换/创建指定的资源。并将其追加到相应的资源组中。| 把指定的资源当做一个资源组，并在其下创建/追加一个新的元素，使其隶属于当前资源。| 删除指定的元素。 PUT和DELETE方法是幂等方法。GET方法是安全方法（不会对服务器端有修改，因此当然也是幂等的）。不像基于SOAP的Web服务，RESTful Web服务并没有“正式”的标准[4]。这是因为REST是一种架构，而SOAP只是一个协议。虽然REST不是一个标准，但大部分RESTful Web服务实现会使用HTTP、URI、JSON和XML等各种标准。 实现举例例如，一个简单的网络商店应用，列举所有商品，GET http://www.store.com/products呈现某一件商品，GET http://www.store.com/product/12345下单购买，POST http://www.store.com/order … REST的优点 可更高效利用缓存来提高响应速度 通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性 浏览器即可作为客户端，简化软件需求 相对于其他叠加在HTTP协议之上的机制，REST的软件依赖性更小 不需要额外的资源发现机制 在软件技术演进中的长期的兼容性更好 实现Ruby on Rails1.2以后的版本支持REST model。JBoss RESTEasyJBoss的REST实现Node.js RESTful APINode.js实现RESTful API","tags":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/架构/"}]},{"title":"Swift笔记","date":"2014-08-22T07:44:42.000Z","path":"2014/08/22/swift笔记/","text":"swift出世时，断断续续看了一些。在PlayGround耍了耍还是挺好玩的:]有OC作为基础，上手swift还是挺快的。但是有一些语法还是要留意下。这个就作为学习笔记吧，记录学习过程中的注意点。swift官网The Swift Programming Language if nil在OC中我们在判断一个值是不是nil时，一般就是123NSString *values = @\"\";if(values) &#123;&#125; 但在swift中，是会报错的12345var apple = \"apple\"if apple &#123; print(apple)&#125;//'String' is not convertible to 'Bool' Apple 在GuidedTour中写道：In an if statement, the conditional must be a Boolean expression—this means that code such as if score { … } is an error, not an implicit comparison to zero. You can use if and let together to work with values that might be missing. These values are represented as optionals. An optional value either contains a value or contains nil to indicate that a value is missing. Write a question mark (?) after the type of a value to mark the value as optional. 正确的写法12345678var optionalString: String? = nilprint(optionalString == nil)if let str = optionalString &#123; print(str)&#125; else &#123; print(\"optionalString is nil\")&#125; 这样写也可以123456789var optionalString: String? = \"janes\"print(optionalString == nil)let isBool = (optionalString == nil)if isBool &#123; print(\"optionalString is nil \\(isBool)\")&#125; else &#123; print(\"optionalString is not nil\")&#125; In-Out Parameters函数中的输入输出参数，可以改变函数参数。 12345678910func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125;var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\") 好奇的看下内存地址有没有改变123456789func address(o: UnsafeRawPointer) -&gt; String &#123; return String.init(format: \"%018p\", unsafeBitCast(o, to: Int.self))&#125;var someInt = 3var anotherInt = 107print(\"before swap:\\(address(o: &amp;someInt)), value:\\(someInt))\")swapTwoInts(&amp;someInt, &amp;anotherInt)print(\"after swap:\\(address(o: &amp;someInt)), value:\\(someInt)\") before swap:0x00007fff595d6ac0, value:3) after swap:0x00007fff595d6ac0, value:107 结果内存中的地址是没有变的 ###12let sortedNumbers = numbers.sort &#123; $0 &gt; $1 &#125;print(sortedNumbers) 12","tags":[{"name":"swift,","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"iOS Crash Log处理","date":"2014-06-24T06:02:36.000Z","path":"2014/06/24/ios-crash-log处理/","text":"iOS crash log 处理 什么是崩溃日志，从哪里能得它? iOS设备上的应用闪退时，操作系统会生成一个崩溃报告，也叫崩溃日志，保存在设备上。 1234Device LogsCrashReporter ~/Library/Logs/CrashReporter/MobileDevice/iTunes Connect -&gt; Crash Reports用户 什么情况下会产生崩溃日志? 两种主要情况会产生崩溃日志: 1. 应用违反操作系统规则。 2. 应用中有Bug。 Array.map12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Incident Identifier: CE5E9C4A-A13D-4734-8483-97D55825AB57CrashReporter Key: d3adfba37a68e78e6885adfe06034f2798cf0762Hardware Model: iPhone6,1Process: XiaoYu [447]Path: /var/mobile/Applications/20FA34C5-0EC1-4692-A89E-1DC7C818C013/XiaoYu.app/XiaoYuIdentifier: com.rt.FISH4iPhoneVersion: 3.0.0 (3.0.0)Code Type: ARM (Native)Parent Process: launchd [1]Date/Time: 2014-06-20 18:32:00.417 +0800OS Version: iOS 7.1.1 (11D201)Report Version: 104Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Triggered by Thread: 0Last Exception Backtrace:(0x2fa3ef0b 0x3a1d1ce7 0x2fa3ee4d 0x54af09 0x3a7e971b 0x3a7ee7b7 0x3a736ff9 0x3a7add25 0x3a1d83a9 0x322a6857 0x3a1e0b6b 0x2f96f185 0x31ee933d 0x31eee7c7 0x3a1e0b6b 0x2f96f185 0x31ef0e11 0x3a6bad3f 0x3a6bd6c3 0x2fa09681 0x2fa07f4d 0x2f972769 0x2f97254b 0x348cf6d3 0x322d1891 0x233c79 0x3a6cfab7)Thread 0 Crashed:Last Exception Backtrace:(0x2fa3ef0b 0x3a1d1ce7 0x2fa3ee4d 0x54af09 0x3a7e971b 0x3a7ee7b7 0x3a736ff9 0x3a7add25 0x3a1d83a9 0x322a6857 0x3a1e0b6b 0x2f96f185 0x31ee933d 0x31eee7c7 0x3a1e0b6b 0x2f96f185 0x31ef0e11 0x3a6bad3f 0x3a6bd6c3 0x2fa09681 0x2fa07f4d 0x2f972769 0x2f97254b 0x348cf6d3 0x322d1891 0x233c79 0x3a6cfab7)Thread 0 Crashed:0 libsystem_kernel.dylib 0x3a7861f0 0x3a773000 + 783201 libsystem_pthread.dylib 0x3a7ee7b3 0x3a7eb000 + 142592 libsystem_c.dylib 0x3a736ff5 0x3a6ed000 + 3030933 libc++abi.dylib 0x39b8598b 0x39b85000 + 24434 libc++abi.dylib 0x39b9c1f5 0x39b85000 + 947095 libc++abi.dylib 0x39b9ba05 0x39b85000 + 926776 libobjc.A.dylib 0x3a1d1db7 0x3a1ce000 + 157997 CoreFoundation 0x2fa3ee49 0x2f96a000 + 8720098 XiaoYu 0x0054af05 0x10000 + 54842939 libsystem_platform.dylib 0x3a7e9719 0x3a7e6000 + 1410510 libsystem_pthread.dylib 0x3a7ee7b3 0x3a7eb000 + 1425911 libsystem_c.dylib 0x3a736ff5 0x3a6ed000 + 30309312 libsystem_malloc.dylib 0x3a7add21 0x3a7ab000 + 1155313 libobjc.A.dylib 0x3a1d83a5 0x3a1ce000 + 4189314 UIKit 0x322a6853 0x32263000 + 27656315 libobjc.A.dylib 0x3a1e0b67 0x3a1ce000 + 7664716 CoreFoundation 0x2f96f181 0x2f96a000 + 2086517 QuartzCore 0x31ee9339 0x31ede000 + 4588118 QuartzCore 0x31eee7c3 0x31ede000 + 6752319 libobjc.A.dylib 0x3a1e0b67 0x3a1ce000 + 7664720 CoreFoundation 0x2f96f181 0x2f96a000 + 2086521 QuartzCore 0x31ef0e0d 0x31ede000 + 7732522 libdispatch.dylib 0x3a6bad3d 0x3a6ba000 + 338923 libdispatch.dylib 0x3a6bd6bf 0x3a6ba000 + 1401524 CoreFoundation 0x2fa0967d 0x2f96a000 + 65292525 CoreFoundation 0x2fa07f49 0x2f96a000 + 64698526 CoreFoundation 0x2f972765 0x2f96a000 + 3466127 CoreFoundation 0x2f972547 0x2f96a000 + 3411928 GraphicsServices 0x348cf6cf 0x348c6000 + 3860729 UIKit 0x322d188d 0x32263000 + 45274930 XiaoYu 0x00233c75 0x10000 + 224370131 libdyld.dylib 0x3a6cfab5 0x3a6ce000 + 6837Thread 1:Thread 0 crashed with ARM Thread State (32-bit): r0: 0x00000000 r1: 0x00000000 r2: 0x00000000 r3: 0x00002060 r4: 0x00000006 r5: 0x3c42818c r6: 0x186e33b0 r7: 0x27df21b0 r8: 0x186e33b0 r9: 0x00000001 r10: 0x00000006 r11: 0x00000005 ip: 0x00000148 sp: 0x27df21a4 lr: 0x3a7ee7b7 pc: 0x3a7861f0 cpsr: 0x00000010Binary Images:","tags":[{"name":"iOS","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"iOS-MDM流程记录","date":"2014-01-08T01:56:00.000Z","path":"2014/01/08/iOS-MDM流程记录/","text":"MDM开发流程1.申请企业开发者账号，这一步比较麻烦的是申请邓白氏码，因为要通过华夏邓白氏那边的审核。拖了比较久。2.有开发者账号就可以做MDM证书了， 主要参考:mbaikesofthinker 这里要注意的是12//Change to your alias 是你证书的名字！String alias = \"MbaikeMDMCSR\"; mdm证书制作1.用apple钥匙串访问工具生成CertificateSigningRequest.certSigningRequest2.利用生成的公私钥中的私钥导出为vendor.p122.登陆299企业帐号创建并下载mdm.cer4.下载AppleWWDRCA 证书5.下载AppleIncRootCertificate 苹果根证书6.利用以下命令将cer证书转成证pem书123openssl x509 -inform der -in mdm.cer -out mdm.pemopenssl x509 -inform der -in AppleWWDRCA.cer -out intermediate.pemopenssl x509 -inform der -in AppleIncRootCertificate.cer -out root.pem 7.生成客户端证书123openssl genrsa -des3 -out customerPrivateKey.pem 2048openssl req -new -key customerPrivateKey.pem -out customer.csropenssl req -inform pem -outform der -in customer.csr -out customer.der 8.利用MDMIOSGenerateEncodedPlist.java生成plist.xml和plist_encoded9.打开 https://identity.apple.com/pushcert/ 登陆任意appleid帐号，上传plist_encoded文件，申请通过后，下载apns-mdm.pem证书10.将apns-mdm.pem与customerPrivateKey.pem合并为apns-mdm.p121openssl pkcs12 -export -inkeycustomerPrivateKey.pem -in apns-mdm.pem -out apns-mdm.p12 此apns-mdm.p12就是mdm服务器和苹果anps服务器通讯用的p12也是mobileconf中绑定的p12(mobileconf最终安装在移动设备上) MDMplist 3.申请服务器所需证书 4.部署https(SSL)服务器环境 最好做下域名映射！ 5.配置描述文件mobileconfig的生成 下载iPhone配置实用工具，配置通用和移动设备管理注意：a：Topic must be com.apple.mgmt. b：通用的安全性为总是 c：移动设备管理中的使用开发APNS服务器不能勾选 主要参考：(http://www.mbaike.net/ios/1560.html) 导出（选“无”）后签名 1openssl smime -sign -in unsigned.mobileconfig -out signed.mobileconfig -signer mbaike.crt -inkey mbaike.key -certfile ca-bundle.pem -outform der -nodetach","tags":[{"name":"iOS MDM","slug":"ios-mdm","permalink":"http://yoursite.com/tags/ios-mdm/"}]},{"title":"IT project management","date":"2013-10-09T11:31:21.000Z","path":"2013/10/09/IT project management/","text":"–Posted by: Margaret Rouse WhatIs.com IT project management is the process of planning, organizing and delineating responsibility for the completion of an organizations’ specific information technology (IT) goals. IT project management includes overseeing projects for software development, hardware installations, network upgrades, cloud computing and virtualization rollouts, business analytics and data management projects and implementing IT services. In addition to the normal problems that can cause a project to fail, factors that can negatively affect the success of an IT project include advances in technology during the project’s execution, infrastructure changes that impact security and data management and unknown dependent relationships among hardware, software, network infrastructure and data. IT projects may also succumb to the first-time, first-use penalty which represents the total risk an organization assumes when implementing a new technology for the first time. Because the technology hasn’t been implemented or used before in the organization, there are likely to be complications that will affect the project’s likelihood of success. Managing the Project These five process groups comprise the project management life cycle and are universal to all projects. The specific phases within a project, however, are unique to each project and represent the project life cycle. Initiation – the project goal, need or problem is identified. The project manager is assigned to the project and the project charter is created.Planning – the project manager and the project team work together to plan all of the needed steps to reach a successful project conclusion. The project planning processes are iterative in nature and it’s expected that planning will happen often throughout the project.Execution – once the project plan has been created, the project team goes about executing the project plan to create the deliverables of the project. The project can shift to project planning as needed throughout project execution.Monitoring and controlling – as the project is being executed by the project team, the project manager monitors and controls the work for time, cost, scope, quality, risk, and other factors of the project. Monitoring and controlling is also an ongoing process to ensure that the project addresses its targets for each project objective.Closing – at the end of each phase and at the end of the entire project, project closure happens to ensure that all of the work has been completed, is approved, and ultimately transferred ownership from the project team to operations.Managing the Project Knowledge AreasThere are ten project management knowledge areas. These ten knowledge areas segment different actions completed by the project manager throughout the project. The ten project management knowledge areas are: Project scope management: the project scope is defined, documented, and approved. The project scope is protected from unauthorized changes, edited with approved changes, and validated by the project stakeholders for project acceptance.Project schedule management: the project schedule is defined first by the working hours of the project, any project milestones, and ultimately a project deadline. The project team’s availability throughout the project is documented and planned accordingly. The project manager will work with the project team to identify the project tasks and task duration estimates in order to create a project timeline.Project costs management: the costs of the project are estimated so that a budget for the project can be assigned. Project costs include materials, services, facilities, software licenses, and other expenses attributed directly to the project.Project quality management: what constitutes quality in the project is defined in specific metrics and agreed upon among the stakeholders as early in the project as possible. Quality assurance programs and policies direct the project work, while quality control inspects the project work to confirm that quality has been ascertained in the work.Project human resources management: the project manager works with the project team to verify that each team member is completing their assignments, working well with others, and that their participation and performance is reported to their respective managers.Project communications management: stakeholders will need information from the project manager will need to provide information to the project manager throughout the project life cycle. This knowledge area create a communications management plan that address who will need what information, when the information is needed, and the best modality for the communications.Project risk management: risks are situations, events, conditions that can threaten, and sometimes benefit, the objectives of the IT project. Risks must be identified, analyzed, and a response created for the risk event. The probability and impact of each risk event is evaluated to create a risk score to justify the costs needed to manage the risk event.Project procurement management: should the project need to purchase goods or services, a formal process for procurement will need to be created. The plan should address the project’s selection of contract type, administration of the contract, purchasing audits, and contract closeout. Many project managers do not manage procurement, but defer to the organization’s centralized procurement or purchasing department and processes.Project stakeholder management: stakeholders are anyone that has a vested interest in the project. Stakeholder management is the identification, inclusion, and communication with the groups of project stakeholders. It manages the anxieties and concerns the stakeholders may have about the project work.Project integration management: this special knowledge area is the coordination of the events in all of the other knowledge areas. How well the project manager performs in one knowledge directly affects the performance of the other knowledge areas. Project integration management examines the interactions and contingencies among the knowledge areas to ensure that the project is adequately planned, executed, controlled and closed.These ten knowledge areas are to be managed iteratively throughout the project. With the exception of procurement, a project manager will likely encounter all ten of these knowledge areas in every project. There is no set order in which the areas should be managed, but rather the project manager shifts to the appropriate knowledge and processes based on what’s occurring within the project. IT Project Life CycleThere are several different approaches to managing an IT project that affect the project life cycle. Organizations can select one of these popular approaches to help reduce the risk of expensive rework, risks from quickly changing technology, or expansive planning at the launch of the project. The project life cycle of a typical IT project moves through iterations of planning, executing, and controlling until the project is ultimately closed and transferred into operations. However, there are three distinct IT project management life cycles: Predictive life cycle: this is the most common and traditional project life cycle for IT projects. In this approach the project manager and the project team first define the project scope, project schedule, and expected project costs before the project execution begins. As part of the project planning it’s typical for the phases of the project to be defined (each phase does a specific type of project work). In order for the project to move from its initiation to its closure each phase must be started and completed in the specific order as planned. This type of approach is sometimes called a waterfall approach as the project “waterfalls” down the phases of the project. Iterative life cycle: this approach to IT project management requires that the project management be defined early in the project, but the cost estimates and activity duration estimating are planned at a higher level early in the project. As the project execution occurs costs and duration estimates are created for the most imminent work through iterations of planning. The iterative life cycle also plans for iterations of benefits released to the organization. For example, an iterative life cycle may create a new software with more features with each new release as part of the project. Adaptive life cycle: this project life cycle also uses an iteration of planning and executing, but the planning that typically last for two weeks. This approach uses a rolling wave of planning and executing through short bursts of both planning and executing. Change is expected in this approach to the IT project and it’s ideal for software development project. Agile project management and Scrum are examples of the adaptive life cycle. All of these life cycles use the concept of phases to move the project work forward. A phase describes the type of work that will take place in that portion of the project. The project manager, the organizational requirements, and even customer requirements can influence what type of project life cycle the project manager will adapt in the project.","tags":[{"name":"项目管理，软技能","slug":"项目管理，软技能","permalink":"http://yoursite.com/tags/项目管理，软技能/"}]},{"title":"项目管理，让自己更从容","date":"2013-10-08T11:22:10.000Z","path":"2013/10/08/项目管理，让自己更从容/","text":"这门课程来自于在工作中有七年项目管理经验的Cindy。课程原名《项目管理，让自己更从容》。 这门课程在腾讯公司内部的课后学员评分，是几乎满分的。 1、什么是项目管理？通过周密的计划，管理好项目中的人、事、物达成项目目标。 什么是项目管理 2、项目管理中，最费时的是第二部分：计划。很多项目之所以进行的一塌糊涂，都是由于初期计划不完善造成的。做好计划项目管理已经赢了一半了。 做好计划 3、很多人会忽略“W”和“H”的问题。虽然很多课程都有这种提炼，但这点往往还是容易被忽略，没搞清楚就开始项目，往往会很悲剧。 启动阶段我们要做什么4、先搞清楚“为什么”非常关键，后续会不会迷茫，就看这个问题弄的清楚不了。 为什么要立项 5、谈恋爱的人一定很明白这个道理：want ≠ need 。 识别真实的需求 6、最终项目质量受成本、范围、时间三个因素影响。 what三要素 7、项目目标是指工作所指向的事物，可具体表现为要大奥的战略地位、或者要达到的目的、要取得的成功、要生产的产品，或者准备提供的服务。用说人话表达就是：完成KPI。 项目目标是什么 8、第一点就是UI和研发经常挑战产品经理的：需求要明确，不明确怎么做？做了你又不满意？。第二点市场的同学可能会比较头疼。第三点是立项的时候应该注意的。第四点是要考察团队的能力。第五点，项目管理都是有周期的。 项目目标的标准 9、在开始项目之前，一定要规划好项目目标，这几点要用文字的形式记录下来。 如何写项目目标 10、关于干系人，常用的方法论是找出“PACE”。 P是Participant（参与者），A是Approver（审批者），C是Consultant（顾问），E是Executor（执行者）。（谢谢Cicy） 干系人 识别干系人 干系人分析 干系人分析 11、怎么立项？一般需要开一个项目启动大会，详细过一遍《立项申请书》确保各个干系人都确认没有问题。 怎么立项 12、工作分解是项目能否成功的关键点，一点要做的非常细致！ 工作分解 以一场婚礼为例聊工作分解 以旅游为例说工作分解 工作分解后，任务要有详细文字计划 必须完全分解任务 任务排序的两种方法 条状图 13、很多时候，项目最大的风险来源于需求的频繁变更。 需求变更 风险管理 执行与控制 执行与控制 变更管理 变更管理 14、一定要多做总结，只有经常总结才能有所提升。 总结 15、内容回顾。这张图适合打印出来放在工位。 项目回顾 16、tips tips 做好项目管理能让自己省很多功夫。项目管理本身不生产价值，但是促使价值产生。","tags":[{"name":"项目管理，软技能","slug":"项目管理，软技能","permalink":"http://yoursite.com/tags/项目管理，软技能/"}]},{"title":"打电话英语","date":"2013-09-28T11:38:11.000Z","path":"2013/09/28/打电话英语/","text":"Starting1.May I speak to Mr.Yang? 可以请杨先生听电话吗？2.Is Mark there? 马克在吗？（和该部门的人都很熟）3.(May I have) Extension 208, please. 请帮我接分机208.4.Is this the Marketing department? 这里是营销部门吗？（不确定是否找对部门）5.Hi, Mr.Yang. This is Jerry Chan, calling from ABC Company China. 嗨，杨先生。我是陈杰瑞，从中国的ABC公司打来的。6.Am I calling a good time? 现在打来合适啊？7.Is it good time? 现在讲话方便吗？8.Are you busy now? 你现在忙吗？9.Do you have time to talk to me now? 你现在有时间和我说话吗？10.Good morning. I’d like to make an appointment with Kevin Yang. 早上好，我想和杨凯文约个时间碰面。11.When is the best time to phone you? 什么时间打电话给你最好？12.Where shall we meet? 我们要在哪里见面呢？13.When is it convenient for you? 你什么时候方便见面？14.When would be a good time? 何时见面比较好？15.Are you free/available next Monday? 你下星期一有空吗？16.How about Thursday? 星期二如何？17.Would Monday suit you? 星期一你可以吗？18.Shall we say 2:30 then? 我们可以约两点半吗？19.Are you free on Wednesday? Say ten o’clock? 你星期三有空吗？十点钟可以吗？20.When would be convenient? 什么时候方便？21.I’m coming to China next week. Could you fix a time to meet? 我下周会到中国。你可以找个时间见面吗？22.Could we reschedule it? 我们可以改时间吗？23.When would be a good time we can call you for this? 何时打电话给你讨论这个较适当。 Requesting others24.Could you tell me when I could reach him? 可以告诉我什么时候可以找到他吗？25.Could you give me his cell phone number? 可以告诉我他的手机号码吗？26.Could I speak to someone else?(Is there someone I can speak to?) 我可以和其他人说话吗？27.Is Kevin’s secretary available? 凯文的秘书在吗？28.Could I speak to Kevin’s secretary? 我可以和凯文的秘书说话吗？29.It’s rather urgent. 我有紧急的事。Wrong number30.Sorry, I must have the wrong number. 抱歉，我一定是打错电话了。31.Oh, sorry for bothering/troubling you. 噢，很抱歉打扰您。32.What would be the right number to call please? 那么我应该打什么号？（同家公司，只是打错部门） Leaving message33.May I leave a message? 我可以留个话吗？34.My name is Kevin.K-E-V-I-N. And my number is 02112345678. 我是凯文，我的电话号码是35.Could you ask him to call me? 可以请他打电话给我吗？36.Can you ask him to call me as soon as possible? 可以请他尽快回电给我吗？37.He already has my telephone number. 他已经有我的电话号码。38.Will you tell him that I called? 能不能告诉他我打过电话？39.Let’s me give you my mobile number。 It’s . 给你我的手机号码，*40.No, thanks. It’s all right. I’ll call back later. 不用，谢谢。没关系。我会再打来。Ending41.See you then. 到时候见。42.Thank you. Goodbye. 谢谢，再见。43.Great. I’ll look forward to it. 太好了，我会很期待。 常用接电话英语Starting1.Hello. 喂。（O__O”…）2.Yes, speaking. 我是，请讲。3.Who’s calling please? 请问你是哪一位？4.This is Kevin Yang. Speaking. 我是杨凯文，请说。5.How can I help you? 有什么可以为你效劳？6.This is Kevin Yang. How may I help you? 我是杨凯文，有什么可以为你服务？ Warming responses7.Hi, Jim, How are you? 嘿，吉姆，你好吗？8.What can I do for you, Allen? 有什么我可以帮你的，艾伦？9.I’m fine, thanks, and you? 我很好，谢谢，你呢？ Wrong number10.Sorry, wrong number. 抱歉，拨错电话了。11.I’m sorry you have the wrong number. 抱歉，你可能拨错电话了。12.I’m afraid you have the wrong number. 你恐怖拨错电话了。 Hearing not well13.Can you hear me? 听得到吗？14.I can’t hear you. Could you speak up/louder? 我听不到，你可以再大声一点吗？15.Can you speak slowly? 可以请你说慢一点？16.Could you speak lower? 你可以说小声一点吗？（不常用，太大声就把话筒拿远一点好了。）17.Sorry, what was that again? 抱歉，你刚刚说什么？18.Could you repeat that, please? 请你可以再说一次吗？19.Pardon/Excuse me, could you repeat that again more slowly? 对不起，你可以再说一次且慢一点吗？20.Not very well. 听不太到。21.It’s a very bad connection. 线路不好。22.Something is wrong with this time. 电话线路有点问题。23.Something is wrong with the phone. 电话有点问题。Not available24.Do you mind if I call you back? 你介意我给你打过去吗？25.Call you in a minute/in a half hour, ok? 一会儿/半小时后回电给你，好吗？26.Sorry, I am in the meeting. Catch you later. 抱歉，我现在正在开会，待会再打电话给你。27.Talk to you later. 待会再聊。28.May I put you on hold? 你可以稍等一下吗？29.Yes, I’ll get back to you as soon as I can. 是的，我会尽快回电话给你。 Further contact30.I’m not quite sure about that. Can I call you back in few minutes? 我不是很确定，我可以几分钟后再打给你吗？31.I’ll give you a call. 我会打电话给你。32.I must go now. 我得挂电话了。33.Let me check that out. Then I will call you back. 让我确认一下。然后我再回电话给你。 Confirmation34.Let e check my schedule. 让我确认一下我的时间表。35.That day is fine with me. 那天我可以。36.Let’s shoot for on Monday morning. 那么我们就暂定星期一早上。37.See you on Thursday at three-thirty then. 星期二下午3点半见。38.Cood. So that’s Wednesday at ten then. 好，那么就星期三10点钟见。 Ending Thanks for calling. Bye. 谢谢你打电话来。再见。40.Nice talking to you. Bye. 很高兴和你谈话，再见。41.Have a nice day! 祝你有个愉快的一天！常用代接电话英语Starting1.Hold on,please.(one moment,please) (Just a moment,please) 请稍候。2.I’ll put you though. 我帮你接过去。3.Can I help you? 有什么可以效劳的？4.May I have your name? 请问你叫什么名字？ Not available5.He is not in right now./ He is not here right now. 他不在。6.He has visitors right now. 他有客人。7.He is away from his desk now. 他不在座位上。8.Mr.Yang is on line one. 杨先生正在接另一个电话。9.Her line is busy now. 她现在正在打电话。10.He is in a meeting right now. 他现在正在开会。11.He is off today./He is day off. 他今天休假。12.He is out to lunch. 他出去吃午餐了。13.He’s not in office today. 他今天不在办公室。14.Is there anything I can help you with? 有设么我可以帮你吗？15.It’s always engaged.(it’s busy all the time.) 有什么我可以帮你吗？16.The line’s engaged. Will you hold? 电话占线。你要等吗？17.I’m afraid the line’s still busy. Do you still want to wait? 很抱歉电话还是占线，你想等吗？18.I’m sorry to have kept you waiting. 很抱歉让你久等。19.Mark is on a business trip abroad and will return to China in one week. 马克到国外出差，大约一星期才会回中国。 Transferring20.Would you like me to put you through to Kevin’s secretary? 你要我把电话转给凯文的秘书吗？21.I’m transferring your call to the Sales department. 我把电话转给销售部门。22.Would you like to speak to his colleague? 你想和他的同事说话吗？23.Would you like me to put you through to someone else? 你想请别人来接听吗？ Further contact24.Could you call back later? 你可以待会再打来吗？25.Can I have a message? 我可以留个口信吗？26.Would you like to leave a message? 你想要留个口信吗？27.Your number, please.你告诉我你的电话号码。28.Is that correct? 那样正确吗？29.Could you spell that please? 你可以拼给我听吗？30.How do you spell your name? 请问你的名字怎么样？31.Could you repeat your name and number? 你可以再说一次你的姓名及电话吗？32.Please leave your contact information. Then I will pass it on for you. 请你留下联络信息，我会为你转达。33.Does he have your phone number? 他有你的电话号码吗？34.Would you ask him to call you? 你要他回电话吗？","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"英文面试","date":"2013-09-27T11:18:29.000Z","path":"2013/09/27/英文面试/","text":"面试时描述个人特质的正面说法1.I am a self-motivated hard worker. 我是一个自我激励、工作认真的人。2.I work well under pressure. 我在压力之下，仍然可以很好地工作。3.I am knowledgeable and levelheaded. 我知识广泛且很冷静。4.I work well with all types of people. 我可以和各式各样的人相处得很好。5.I am good with people. 我的人际关系很好。6.I’m very easygoing. 我很随和。7.I’m a dependable hard worker. 我是个可靠又认真的员工。8.I am intelligent and driven. 我既聪明又上进。9.I am a quick/fast learner. 我的学习能力很强。10.I’m very honest and I have strong sense of responsibility. 我很坦诚且富有责任感。11.I get very serious and cautious when I work. 我在工作时很认真且小心谨慎。12.I’m a curious person and like to learn new things. 我是充满好奇心且喜欢学习新事物的人。13.I’m interested in learning new things very much. 我对于学习新的事物感到很有兴。14.I am a man with self-confidence and optimistic,我是个自信又乐观的人。15.I am outgoing and easy to get along with. 我的个性外向且容易相处。16.I suppose I’m very patient. 我想我很有耐性。17.I’d rather cooperate with other people, and get the job done as a team. 我乐于与其他人合作，加入团队工作。18.I like to be with people and to do things with them. 我喜欢跟人打交道，和其他人一起做事。8.","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"最常用的英语祝福语","date":"2013-09-26T11:03:39.000Z","path":"2013/09/26/最常用的英语祝福语/","text":"英文信的结尾比较单纯，意思就是中文的”敬上“，常用的结尾词如下：对人的敬意、尊敬：Regards, Kind regards, Best regards, Warm Regards祝福对方幸福、健康、成功：Wishes, Best wishesSincerely, Sincerely yours 比较常用在书信里，现在也可用在email中Cheers一般是用在敬酒，但较熟的朋友也可以用此作为email的结尾 祝贺用语 Happy New Year! 新年快乐！Happy Chinese/ Lunar New Year! 春节快乐！Gong Xi Fa Cai！恭喜发财（囧…)Happy Lantern Festival! 元宵节快乐！Happy Valentine‘s Day! 情人节快乐！Happy Easter! 复活节快乐！Happy Dragon Boat Festival! 端午节快乐！Happy Mid-Autumn/Moon Festival! 中秋节快乐！Happy Halloween! 万圣节快乐！Happy Thanksgiving! 感恩节快乐！Merry Christmas! 圣诞节快乐！May the coming year bring you prosperity and happiness! 祝你新的一年成功与幸福！Wish you all the best that comes with the Rat! 祝您鼠年事事如意！","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"英文通知","date":"2013-09-24T11:07:05.000Z","path":"2013/09/24/英文通知/","text":"开会通知Dear all,The next monthly management meeting will be held at10:00 a.m. on Monday, April 5, at meeting room A. Please kindly arrange your work.(这句我加的。。。） Following is the agenda for the meeting: 1.Monthly sales goal review.2.Department cost review.3.Action plans for next month. If there are any other items you would like to have placed on the agenda, let me know by email by the end of this week. Thank you. Regards,Kevin Yang 休假通知Dear all,I will be out of the office starting from 06/08/2008 and I will not return until 06/18/2008.During my absence, Andy Huang will be acting for me. Please contact him for Investment services business at 86-021-12345678. Regards,Kevin. 离职通知Dear all,As today is my last working day with SCB, I would like to take this oppurtunity to thank everyone for being so supportive and helpful during my stay here, not to mention your true friendship. I fee fortunate to have the opportunity to work at SCB plus the friendship I’ve made over the years. This experience will always be treasured forever. Let’s keep in touch. CarolCarol@yahoo.com.cn sample2Dear all,On my last working day in Wealth Management, I would like to thank you all for your assistance and caring. I truly enjoyed the time working at Standard Chartered Bank. It has been an honor to work with great people like you, and thanks again! For any matters, you are welcome to contact me via email or mobile as attached below. Best wishes to you in the future! Regards, Calvin Chen13001234567calvinchen@hotmail.com. sample4Dear All,Today’s my last working day at ABC. Thank you for your assistance and support during my 2 years stay. It’s my great honor to have worked with you all and I’ll cherish our memories during good and tough times. Now I’ve made the decision to fulfill my other dreams, and I’ll certainly do my very best to achieve the goals.It’s not the end of our relationship but instead it’s the beginning of a great one, so let’s keep in touch. I wish everyone the very best in your career, family, and health… Thank you all again！ Jerry Yang13001234567jerryyang@yahoo.com 离职祝福Jenny,Nice working with you and will sure get in touch with you when I’m in Beijing again.Here is my personal contact:省略Let me know where you are when everything is settled.Wish you all the best!Sam Good luck to you wherever you go and whatever you do on your next stop! Take care! Thanks for your great support to us and wish you the best !! Take care! 开会常用英语1.Is this seat taken? 这个位子有人坐吗？2.He is coming.(he is on the way/he will be here shortly/soon) 他快到了。（主持问某人在哪里？）3.How are today? 你今天好吗？4.Where would you like to sit? 你想坐哪里？5.What time are we starting? 我们几点开始？6.Has everyone got a copy of the agenda? 每个人都拿到会议议程的复本了吗？7.What’s on the agenda? 今天的议程是什么？ Shall we start/begin? 我们可以开始了吗？9.Let‘s get started. 我们开始吧！10.Hello, everyone. Thanks for joining the meeting. 各位好。谢谢大家来参加这个会议。11.Good morning everyone. Welcome. 早上好，欢迎各位。12.Let’s brief you on the agenda today. 让我先简单介绍一下今天开会的议程。13.Let’s review our agenda for today. 让我们先看一下今天开会的议程。14.Let me review/go over the agenda. Firstly…Secondly…Thirdly…Finally…让我介绍一下今天会议议程，首先。。第二。。第三。。最后。。15.Now, then, the first thing we need to talk about… 现在，第一件事我们要谈的是。。。16.All right. Now, the first item on the agenda is to… 好的，现在，在议程上第一个项目是…17.Our objective for this meeting is to… 我们今天会议的主题是…18.On the agenda, you’ll see three items. 在议程上，你将看到三个项目。19.Let’s take a break. 休息一下吧！20.it’s almost lunchtime. 差不多该吃午餐了。21.We have an hour lunch break. 差不多该吃午餐了。 May I have your attention, please? 可以请大家注意吗？ Get to the point. 请讲重点。24.Be clear and specific. 请明确且具体一点。25.Could you be more specific? 你可以再具体一点吗？26.Could you repeat those figures again more slowly, please? 请你慢慢地再说一次那些数字？27.Could you write that down for me, please? 你可以帮我记一下吗？28.Sorry, Mark, could you please let Nadia finish? 抱歉，马克，你可不可以让纳迪亚先讲完？29.Can we talk about this later? 我们可以等一下再谈这个吗？30.Okay, go on. (Yes, go ahead.) 好的，继续。31.Don’t you think we should take a short break and have some coffee? 你不认为我们该休息一下，喝点咖啡吗？32.Mary, any thoughts? 玛丽，有没有任何想法？33.What’s your view? 你的看法是什么？34.Does anyone have any questions before we move on? 在我们继续之前，有没有人有任何问题？35.Could you answer that for us? 你可以为我们回答那个问题吗？36.Shall we move on to the next point? 我们可以进行下一个议题吗？37.Could I ask everyone to please focus on the relevant issues here? 我可以请大家集中在相关的问题上吗？38.Tell us about your ideas for this. 告诉大家你对于这个的看法。39.The next issue I would like to focus on is… 下个议题，我想把重点放在…40.Can you give us more detail in what has happened? 你能让我知道发生的事情的更过细节吗？41.Can we please stick to the main topic/subject here? 我们可不可以跟进主要的议题？42.What’re you trying to say? 你想说什么？43.Let me give you an example. 让我举一个例子。44.Can you explain that to another discussion? 我们可以把那个留到以后讨论吗？45.Can we leave this until another date? 我们可以改天讨论这个吗？46.Can you explain that in more detail? 你可以解释得再详细一点吗？47.Is that clear now? 现在清楚了吗？48.I think we need more time to consider this. 我想我们需要更多的时间来考虑这个。49.What do you think? 你认为如何？50.Do you agree? 你同意吗？51.Sorry. I’m (a little) late.(Sorry to be late.) 抱歉我迟到了。52.Sorry/Excuse me for interrupting. (Sorry to interrupt you.) 抱歉打断你们。53.May I interrupt you? 我可以打断你的话吗？54.I’m sorry. What did you say? 很抱歉，你刚才说什么？55.What do you mean by that? 你是什么意思？56.I don’t follow that. 我没听懂。57.Excuse me, you mentioned something about…? 对不起，你刚说的关于…?58.Sorry, could you clarify what you meant by…? 抱歉，你可以再澄清一下，你的意思…59.I didn’t mean that. 我不是这个意思。60.That wasn’t what I’m saying. 那不是我说的。61.Excuse me, Matt, just a moment. 对不起，马特，停一下。62.Sorry, let me finish…抱歉，让我说完…..63.One moment, let’s just clarify… 等一下，让我们先弄清楚….64.Let me explain that first. 让我先解释一下。65.Hold on. I didn’t get that/hear. (What did you say? ) 等一下，我没听到。（你说什么？）66.Oh, sorry. Let me repeat it. 噢，抱歉，让我再说一次。67.Could I make a suggestion? 我可以做个建议吗？68.Could I ask a question? 我可以问个问题吗？69.Excuse me, may I ask for clarification on this? 对不起，我可以澄清一下这点吗？70.Sorry, could I interrupt for a moment? 抱歉，我可以打断一下吗？71.Like what? Give me an example. 像什么？举个例子?72.I just want to make sure we are on the same page. 我想确定我们的理解是相同的。73.When is this due? 什么时候是期限？74.How long do we have for lunch? 午餐的时间有多长？75.Well, we’re nearly out of time. Can we come to a conclusion? 哎呀，我们快没有时间，我们可以做个决定吗？","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"最常用的50个英文短语","date":"2013-09-23T11:18:00.000Z","path":"2013/09/23/最常用的50个英文短语/","text":"First of all 首先First of all, a warm welcome to our company.首先，诚挚的欢迎你加入我们公司。 In the meantime(Meanwhile) 同时In the meantime, can you give me some thoughts and come up with any recommendations?同时你能给我一些想法及提出任何建议吗？ From one’s point of view 从…的观点I would like to agree with Marketing’s suggestion as this will be great enhancement for our proposed scheme from a sales point of view.我同意营销部门的建议，因为从销售的断电，这对于我们提出的方案有很大的改善。 Generally (Speaking) 一般而言Generally speaking, I think you’re right.一般而言，我认为你是对的。 In conclusion (All in all) 总之In conclusion,I’d like to thank you for all your efforts.总之，我要感谢你们所有的努力。 In accordance with( According to) 根据In accordance with the announcement made by CEO today…根据首席执行官今天所宣布… In terms of 就什么而论；在某方面The ABC company is number one in the terms of net sales in China在净销售量方面，ABC公司在中国市场是第一名。 Apart from that (Besides/In addition) 除…之外Besides, I want you to promise me one thing.此外，我要你答应我一件事。 Rather than(Instead of) 而不是You should be responsible for this issue instead of me.你该为这件事负责而不是我。 Due to (Because of) 由于Her absence was due to sickness.由于生病她没来上班。 In case 假使、倘若We also provide the contact window for you in case you have further questions regarding this product.我们也提供联络窗口给你，倘若你对这项产品有进一步的问题。 As far as I know 据我所知As far as I know. they will invest quite a big amount in marketing this product next year.据我所知，他们明年将花大量的钱来营销这个产品。 In view of 鉴于；考虑到In view of the above, we consider it may be better if dialog can be arranged between A and B.鉴于以上论述，我们可以考虑安排A和B对话，这样可能会比较好。 Even though 虽然Even though I tried very hard, I didn’t manage to finish the work.虽然我努力地尝试，我还是无法完成这项工作。 15.prior to 在…之前Prior to that, we need to communicate with the salespersons on the process.在那之前，我们需要与业务同仁沟通流程。 As long as 只要We are prepared to pay your asking price, as long as you can deliver on time.只要你能准时交货，我们已预备支付你们要求的价格。 As a reminder 在此提醒As a reminder, all sales are counted if they are booked by end of this month.在此提醒，如果是在月底前预订的则所有业绩都会被计算。 From one’s perspective 从…观点This is very sensitive from both regulatory and customer reputation perspectives.从主管机关及顾客信誉的观点，这都是非常敏感的。 In that case 既然那样In that case, let’s start earlier.既然那样，我们就早点开始。 On one’s behalf 代表某人On my boss’ s behalf, I agree on the special price.代表我老板，我同意这个特别的优惠价格。 For reasons outlined above 根据上述的理由For reasons outlined above, we decided not to launch this product.根据上述的理由，我们决定不发布这个产品。 Be subject to 决定于The new product launch schedule is subjected to approval by Headquarter.新产品的发布决定于总部的同意。 In light of 按照We reviewed our strategies in light of recent market changes.按照市场变化我们复审公司的策略。 As well 同样地、也It was decided by the company’s top management that the event would be expanded to other functions as well.公司的管理阶层会决定将这个活动也推广至其他部门。 In my opinion 在我看来In my opinion, we should delay our decision until the end of the week.在我看来，我们应该推迟到这个周末再做决定。 Compared with (In comparison with) 跟什么比His performance is not bad in comparison with his co-workers in the same department.同部门的同事相比，他的表现不差。 By the way 顺便提起By the way, thanks for helping us arrange the meeting.顺便提起，谢谢你帮我安排这个会议。 To my knowledge (Based upon my understanding) 据我理解To my knowledge. there are still some problems with the new system.据我理解，这个新系统还有一些问题。 Actually(As a matter of fact/In fact) 事实上As a matter of fact, I’ve never been there before.事实上，我从未到过那儿。 To tell you the truth (Frankly speaking) 坦白说To tell you the truth, I have no idea about it.坦白说，我不知道。 In spite of 尽管In spite of spending all night, I wasn’t able to finish the work.尽管花了整夜的时间，我还是无法完成工作。 32.In order to 为了We propose to launch a sales competition campaign in order to achieve the sales target.我们提议举办业务销售竞赛以达成销售目标。 As usual 像往常一样Annual bonuses will be paid as usual to employees who have performed well this year.像往常一样，今年表现优异的员工可以获得年终奖金。 34.In principle 原则上In principle, we are happy to agree on the new proposal.原则上，我们乐意赞同这个新提案。 On the whole 整体而言On the whole, last year was successful, with profits up by eight percent, in spite of difficulties in the market.整体而言，虽然去年市场不景气，但是获利上升了8%，算是相当成功。 As for 至于As for product A, we include it in our product because the company can make a highest profit.至于A商品，我们把它包含进产品，因为公司可以赚更多利润。 As you know 如你所知As you know, we include it in our product because the company can make the most of this opportunity.如你所知，这个月我们只有一种产品可销售，我们需要好好把握这个机会。 With regards to 关于Overall, the responses are positive with regards to the activities, which were undertaken in 1Q.整体而言，关于第一季所办的活动，反应都还算较好。 As yet (So far) 迄今As yet, we have not had time to consider your proposal.到目前为止，我们还没有时间考虑你的提案。 For the time being 暂时We’re ahead of our competitors of the time being.我们暂时领先对手。 In any case 无论如何In any case, we will support you.无论如何，我们都会支持你。 What’s more(Moreover/Furthermore) 再者，而且She learns quickly, and what’s more, she remembers what she has learnt.她学的很快，而且，她学过的全都记得。 Account for 解释Oil price rises can be accounted for by increased demand or decreased availability of supply.需求的扩大或供给的不足可以解释油价的上扬。 Be in line with 与…一致Although your proposals were sound, they were not in line with company policy.虽然你的提案很合理，但与公司的政策并不一致。 On the basis of 基于On the basis of recent market research, there seems to be a clear need for this kind of product.基于最近的市场调查，这种产品似乎有相当明确的需求。 On the thought of 因为；基于以下理由He was dismissed on the ground of his inefficiency and poor results.他被辞退的理由是缺乏效率及表现不佳。 In advance 事前But if you do so, please let me know in advance.如果你这么做，请事前让我知道。 At first sight 初看之下At first sight the contract seemed normal.初看之下这份合约很正常。 In this regard 就这方面而言Vicky please liaises with Kenny in this regard tomorrow.薇姬明天请与肯尼联系这方面事情。 Run into 遇到If anyone runs into barriers, please fee free to call or email me.如果任何人遇到困难，请不用客气打电话或发电子邮件给我。","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"英文时间数字如何表达","date":"2013-09-22T11:08:09.000Z","path":"2013/09/22/英文时间数字如何表达/","text":"Five days later ( After five days) 五天后 Five days earlier 五天前 Early May 五月初 Middle of May(Mid-May) 五月中 Late May (End of May) 五月底 Over the next few weeks 未来几周 In the coming months 未来几个月8.Earlier this year 年初 Middle of this year 年中 End of this year 年底 A couple of years 好几年 on Friday morning 星期五早上 This Friday（On Friday of this week） 本周五 In the near future 近期内 On Friday 每逢周五 First half of Aug. 八月的上半月 Second half of 2008 2008年的下半年 In the next day or so 这一、两天之内 March 2,2005（3/2/2005) 美式2005年3月2日2nd March, 2005 (2/3/2005) 英式2005年3月2日 B.C. (before Christ) 公元前 A.D. (after his dead) 公元 At 4:00 p.m. on Monday, April 1. 4月1日星期一下午4点 On Tuesday, December 24, from 6:00 to 9:00 p.m. 12月24日星期二下午6点到9点 Starting on April 1 this year… 从今年的4月1日开始 12:00 pm/12:00 noon 中午12点 12:00 am/12:00 midnight 午夜12点 老外习惯的数字用法千 1,000 One thousand万 10,000 Ten thousand十万 100,000 One hundred thousand百万 1,000,000 One million千万 10,000,000 Ten million亿 100,000,000 One hundred million十亿 1,000,000,000 One billion百亿 10,000,000,000 Ten billion千亿 100,000,000,000 One hundred billion万亿 1,000,000,000,000 One trillion 数字的英文表达方式二分之一 one half五分之一 one-fifth七分之三 three-sevenths加 plus减 minus乘 time除 divide10mx15m ten meters by fifteen大于 greater than等于 equal to小于 less than1.5 one point five2008 two thousand and eight1947 nineteen forty-seven932811 night three two eight double one-8℃ minus eight degree centigrade","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"进了外企再学英语","date":"2013-04-12T12:10:03.000Z","path":"2013/04/12/进了外企再学英语/","text":"email 部分第一部分：开场（opening）提及你写这封信的缘由及目的，并定出全文的主题，举例如下：Thank you for your email on 10 August, requesting…Thank you for calling me yesterday to discuss…I would like to suggest that you…I am delighted to give you the detail about…第二部分：主旨（reason for writing）具体陈述这封信的主旨，以一个段落表达一个主题为原则，看需要几个段落来陈述主旨，举例如下：Attached please find the latest information on…In order to achieve our sales target, we need to….第三部分：行动（request for action）主旨说明完后，对方应该了解你写这封信的目的及背景，接下来就是要求对方有所行动，例如回信、回电话、表达意见、缴交文件等，举例如下：Could you please call me later today?Please confirm that these arrangements are find with you.第四部分：结尾（ending）最后再以客气的口语做总结，让对方了解你的期待，举例如下：I look forward to hearing from you.I hope this information is helpful.Please call me if you have any question. 最常用的100种句型 Starting I am writing to confirm/ enquire/ inform you…我写信时要确认/询问/通知你… I am writing to follow up on our earlier decision on the marketing campaign in Q2.我写信来追踪我们先前对于第二季度营销活动的决定。 Starting a reference With reference to our telephone conversation today…关于我们今天在电话中的谈话…. In my previous email on October 5… 先前在10月5日所写的信… As I mentioned earlier about…如我先前所提及关于…. As indicated in my previous email…如我在先前的信中所指出…. As we discussed on the telephone…如我们上次在电话中的讨论… From our decision at the previous meeting…如我们在上次会议的决定… As you requested/ Per your requirement…按照你的要求… In reply to your email dated April 1, we decided…回答你在4月1日写的信，我们决定… This is in response to your email today.这是针对你今天早上来信的回复。 As mentioned before,we deem this product has strong unique selling points in China. 如先前所述，我们认为这个产品在中国有强有力且独一无二的销售点。 As a follow-up to our phone conversation yesterday, I wanted to get back to you about the pending issues of our agreement. 追踪我们昨天在电话中所谈，我想答复你关于我们合约的一些待解决的议题。 I received your voice message regarding the subject. I’m wondering if you can elaborate i.e. provide more details. 我收到你关于这个主题的留言。我想你是否可以再详尽说明，也就是再提供多一点细节。 Giving information Please be advised/ informed that…请被告知… Please note that…请注意… We would like to inform you that…我们想要通知你… I am convinced that…我确信…. We agree with you on…我们同意你在…. With effect from 4 Oct.,2008…从2008年10月4日开始生效…. We will have a meeting scheduled as noted below. 我们将举行一个会议，时间表如下。 Be assured that individual statistics are not disclosed and this is for internal use only.请确保个人信息不会外泄且只供内部使用。 I am delighted to tell you that…我很高兴地告诉你…. We are pleased to learn that…我们很高兴得知…. We wish to notify you that…我们希望通知你… Congratulations on your…恭喜您关于… I am fine with the proposal.我对这份提案没有意见。 I am pleased to inform you that you have been accepted to join the workshop scheduled for 22-24 Nov,2008. Giving bad news We are sorry to inform you that…我们很抱歉地通知你… I’m afraid I have some bad news.我恐怕要带来一些坏消息。 There are a number of issues with our new system. 我们的新系统有些问题。 Due to circumstances beyond our control…由于情况超于我们所能控制…. I don’t fee too optimistic about…我觉得不太乐观关于…. It would be difficult for us to accept…我们很难接受…. Unfortunately I have to say that, since receiving your inquiries on the subject, our view has not changed. 很不幸地，我必须这么说，自从收到你关于这个主题的询问，我们的看法都没有改变。 Making a request We would be grateful if you could…我们会很感激如何你可以.. I would appreciate it if you could…我会很感激如果你可以…. Would you please send us…? 可否请你寄给我们…? We need your help. 我们需要你的帮助。 We seek your assistance to cascade/relay this message to all your staff.我们请求你的帮助，将此信息传达给你们的员工。 We look forward to your clarification. 我们期待你的澄清。 Your prompt attention to this matter will be appreciated. 您能立即注意此事，我们将非常感激 I would really appreciate meeting up if you can spare the time.Please let me know what suits you best.如果您能抽出时间，我希望能与你见面，请让我知道您最合适的时间。 Please give us your preliminary thoughts about this. 请让我知道您对于这件事情初步的想法。 Would you please reply to this email if you plan to attend? 请您回信如果您计划参加？ Please advise if you agree with this approach. 请告知是否你同意这个方法。 Could you please let me know the status of this project?请让我知道这个计划的进度？ If possible, I hope to receive a copy of your proposal when it is finished. 如果可能，当你完成提案，我希望能收到一份复本。 I would appreciate it very much if you would send me your reply by next Monday. 如果能在下周一前收到您的答复，我将非常感激。50.Hope this is OK with you. If not, let me know by email ASAP. 希望您对此没有问题，如果不行，请利用电子邮件尽快让我知道。 Could you please send me your replies to the above questions by the end of June? 请您在6月底前答复我上述问题好吗？ May I have your reply by April 1, if possible? 如果可能，我能否在4月1号前收到您的答复？ Offering help If you wish , we would be happy to…如果你希望，我们很乐意… Please let me know if there’s anything I can do to help.请让我知道任何我可以帮得上忙的地方。 If there’s anything else I can do for you on/regarding this matter,please feel free to contact me at any time. 对于这件事，如果还有任何我能帮得上忙的地方，请不要客气，随时与我联络。 If you want additional recommendations on this, please let us know and we can try to see if this is possible. 如果关于此事你需要额外的建议，请让我知道，我们会尝试看看是否可能。 Reminder I’m just writing to remind you of… 我只是写信来提醒您… May we remind you that…? 我们想要提醒您… Enclosing documents I am enclosing…我附上… Please find enclosed…请查阅附件…. Attached here to…附件是关于…. Attached please find the most up-to-date information on/regarding/concerning…附上关于某某的最新资料… Attached please find the draft product plan for your review and comment.附上产品计划书的草稿，请复审及评价。 Closing Remarks If you have any further questions, please feel free to contact me. 如果你有任何问题，请不要客气与我联系。 I hope my clarification has been helpful. 希望我的说明是由帮助的。 Please feel free to call me at any time, I will continually provide full support. 请随时与我联络，我会继续提供全力的支持。 Please let me know if this is suitable. 请让我知道这是否恰当。 Referring to future contact Looking forward to seeing you soon. 期待很快能见到你。 We look forward to hearing from you soon. 我们期待很快得到您的答复。 Hope this is clear and we are happy to discuss this further if necessary. 希望上述说很清楚，如有必要，我们很乐意再进一步讨论。 I look forward to receiving your reply soon. 我期待很快收到您的答复。 Looking forward to receiving your comments in due course. 期待在预期的时间收到你的反馈。 I’ll keep you posted. 我会与你保持联络。 Please keep me informed on the matter. 请随时让我知道这件事的发展。 For any comment/ suggestions, please contact Nadia at 10086（我诌的）. 任何评价或建议，请打电话10086联络Nadia。 Apologizing I would like to apologize for… 我想就….道歉…. I apologize for the delay in…对于…的耽搁，我深感抱歉。 We are sorry for any inconvenience caused. 对于产生任何不便，我们感到抱歉。 I am sorry for any inconvenience this has caused you. 对于造成你的任何不便，我感到抱歉。 I’m sorry about last time. 关于上次的事我很抱歉。 We apologize for not replying you earlier. 对于未能早一点回信给你，我们感到抱歉。 I’m really sorry about this. 关于这件事，我真的很抱歉。 Sorry,I’m late in replying to your email dated Monday, April 1.抱歉，我太迟回您在4月1号（星期一）发给我的邮件。 We apologize for the delay, and hope that it doesn’t inconvenience you too much. 我们为耽搁道歉，希望不会给您带来太多的不便。 Hoping that this will not cause you too much trouble. 希望不会为您带来太多的麻烦。 Sorry if my voice message is not clear enough. 如果我的电话留言不够清楚，我深感抱歉。 Thank you Thank you for your help/assistance/effort/cooperation. 谢谢你的帮助/协助/努力/合作。 I appreciate very much that…我非常感激你…. I truly appreciate it. 我真的很感激。 Thank you for your participation. 谢谢你的参加。 Thank you so much for inviting me. 非常感谢你邀请我。 Congratulations to all of you and thanks for your efforts. 恭喜各位并谢谢各位的努力。 Your understanding and cooperation is greatly/highly appreciated. 很感激你的理解及合作。 Your prompt response will be most appreciated.很感激你快速的答复。 Once again, thank you all for your commitment and support. 再一次感谢你的承诺及支持。 Thanks for your input/clarification/message. 谢谢你的投入/澄清/信息。 Any comments will be much appreciated. 对于您的任何建议，我将非常感激。 Thank you very much for everything you’ve done for me. 感谢你为我做的一切。 I would appreciate your kindest understanding with/ regarding this matter. 我和感激你对这件事情的理解。 Please convey my thanks to all the staff involved, they certainly did an excellent job. 请表达我的谢意给那些有关的同仁，他们真的干得很好。","tags":[{"name":"英语，软技能","slug":"英语，软技能","permalink":"http://yoursite.com/tags/英语，软技能/"}]},{"title":"应用程序权限设计","date":"2013-03-15T11:25:11.000Z","path":"2013/03/15/应用程序权限设计/","text":"转自：http://www.cnblogs.com/yukaizhao/archive/2007/04/15/user_role_action_permission.html我们在开发系统的时候，经常会遇到系统需要权限控制，而权限的控制程度不同有不同的设计方案。 基于角色的权限设计这种方案是最常见也是比较简单的方案，不过通常有这种设计已经够了，所以微软就设计出这种方案的通用做法，这种方案对于每一个操作不做控制，只是在程序中根据角色对是否具有操作的权限进行控制；这里我们就不做详述 基于操作的权限设计这种模式下每一个操作都在数据库中有记录，用户是否拥有该操作的权限也在数据库中有记录，结构如下： 但是如果直接使用上面的设计，会导致数据库中的UserAction这张表数据量非常大，所以我们需要进一步设计提高效率，请看方案3 基于角色和操作的权限设计 如上图所示，我们在添加了Role，和RoleAction表，这样子就可以减少UserAction中的记录，并且使设计更灵活一点。但是这种方案在用户需求的考验之下也可能显得不够灵活够用，例如当用户要求临时给某位普通员工某操作权限时，我们就需要新增加一种新的用户角色，但是这种用户角色是不必要的，因为它只是一种临时的角色，如果添加一种角色还需要在收回此普通员工权限时删除此角色，我们需要设计一种更合适的结构来满足用户对权限设置的要求。 2,3组合的权限设计，其结构如下： 我们可以看到在上图中添加了UserAction表，使用此表来添加特殊用户的权限，改表中有一个字段HasPermission可以决定用户是否有某种操作的权限，改表中记录的权限的优先级要高于UserRole中记录的用户权限。这样在应用程序中我们就需要通过UserRole和UserAction两张表中的记录判断权限。到这儿呢并不算完，有可能用户还会给出这样的需求：对于某一种action所操作的对象某一些记录会有权限，而对于其他的记录没有权限，比如说一个内容管理系统，对于某一些频道某个用户有修改的权限，而对于另外一些频道没有修改的权限，这时候我们需要设计更复杂的权限机制。 对于同一种实体（资源）用户可以对一部分记录有权限，而对于另外一些记录没有权限的权限设计： 对于这样的需求我们就需要对每一种不同的资源创建一张权限表，在上图中对Content和Channel两种资源分别创建了UserActionContent和UserActionChannel表用来定义用户对某条记录是否有权限；这种设计是可以满足用户需求的但是不是很经济，UserActionChannel和UserActionContent中的记录会很多，而在实际的应用中并非需要记录所有的记录的权限信息，有时候可能只是一种规则，比如说对于根Channel什么级别的人有权限；这时候呢我们就可以定义些规则来判断用户权限，下面就是这种设计。 涉及资源，权限和规则的权限设计 在这种设计下角色的概念已经没有了，只需要Rule在程序中的类中定义用户是否有操作某种对象的权限。以上只是分析思路，如果有不对的地方，请大家指正。","tags":[{"name":"权限设计","slug":"权限设计","permalink":"http://yoursite.com/tags/权限设计/"}]},{"title":"SQL性能优化点","date":"2013-02-25T11:19:11.000Z","path":"2013/02/25/SQL性能优化点/","text":"避免在SELECT语句中使用“*” 注意同时修改同一记录问题 临时表能不用就不用 WHERE中避免复杂的操作，避免重复计算 范围先小后大 使用事务 避免使用OR关键字 当心死锁 多用参数查询 利用分析查询 小心超时问题 in 和 not in 也要慎用，否则会导致全表扫描 慎用游标 注意使用like（尽量不采用 “%2%” 之类的方式处理，多采用 “2% ”、“%2”） 大的数据集不要打开 欢迎补充~","tags":[{"name":"SQL, 性能优化","slug":"sql-性能优化","permalink":"http://yoursite.com/tags/sql-性能优化/"}]},{"title":"Python入门教程","date":"2013-01-22T12:10:03.000Z","path":"2013/01/22/Python入门教程/","text":"Python官网 Python 入门教程 简明 Python 教程","tags":[{"name":"教程, Python，引道","slug":"教程-python，引道","permalink":"http://yoursite.com/tags/教程-python，引道/"}]},{"title":"Markdown语法说明","date":"2011-12-20T09:52:09.000Z","path":"2011/12/20/Markdown语法说明/","text":"Markdown 语法说明 标题： #h1级标题 ##h2级标题 ###h3级标题 ####h4级标题 #####h5级标题 ######h6级标题 分割线：三个以上的短线 即可作出分割线 超链接：连接名称我是链接名 点我刷新 另一种超链接写法：[链接名][链接代号]here然后在别的地方定义 3 这个详细链接信息， 直接展示链接的写法：http://www.izhangbo.cn 键盘键Ctrl+[ and Ctrl+] code格式：反引号 ` Use theprintf()` function. There is a literal backtick (`) here.针对在代码区段内插入反引号的情况 强调：斜体强调粗体强调 图片 使用 icon 图标文字 段落：以一个空行开始，以一个空行结束，中间的就是一个段落。 表格： Item Value Computer $1600 Phone $12 Pipe $1 无序列表：使用 - 加一个空格（） 无需列表1 无序列表2 无序列表3 有序列表：使用 数字 加一个英文句点 有序列表 有序列表 有序列表 有序列表 有序列表 换行缩进形成代码区块 这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。 块引用 给引用的文本开始位置都加一个 ‘&gt;’，便可组成一个块引用。在块引用中，可以结合其他markdown元素一块使用，比如列表。强调也可以只在第一行加大于号，其他位置不加。 块引用里使用列表，需要和上面的内容隔开一个空行 记得加空格哦。","tags":[]},{"title":"学习Objective-C语言","date":"2011-09-22T11:19:09.000Z","path":"2011/09/22/学习Objective-C语言/","text":"Objective-C领域的经典著作：Objective-C 2.0程序设计 learn_objectivec Apple 官方的「The Objective-C Programming Language」Programming with Objective-C 重要的内存管理Memory Management Programming Guide for Core Foundation","tags":[{"name":"教程, Objective-C，引道","slug":"教程-objective-c，引道","permalink":"http://yoursite.com/tags/教程-objective-c，引道/"}]},{"title":"Lua内存管理","date":"2011-07-04T07:55:00.000Z","path":"2011/07/04/Lua内存管理/","text":"本文主要介绍某项目脚本(lua)部分内存泄漏的查证与处理过程，希望对大家有点帮助。需要说明的是，lua本身并不存在真正的内存泄漏，只是因为使用上面的原因导致无法gc，从而导致逻辑上的泄漏:)。 参考GCObject的声明可以发现，lua中的复杂数据类型变量的传递都是基于引用的。当lua从根开始gc扫描的时候，只要还有一个地方有对此变量的引用，那么这个变量就不会被collect。这种情况造成的危害取决于多大程度上依赖于引用，如果有适当的间接层/弱引用来隔离这个问题，可能问题会有所缓解。 以下是一些常见的错误引用情景: 1.本应该local 的变量进入global空间或者module空间了(忘记写local)，如果这是一个table/function/udata等类型的变量的话，非常不幸的，这个变量将不会被正确gc了 —-除非你再显式的释放。这是非常容易犯的错误，一直在想为什么lua变量不是默认local呢？ 当然这个话题会引发另外一场争论。 1234local function test_user(id) userobj = get_user_by_id(id) --这里总是会有一个玩家对象泄漏 print(\"only test\", userobj:get_name())end 2.c/c++部分调用的lua_ref是否有正常lua_unref释放？ 通过debug.getregistry()可以查到这些ref. 3.其他各种各样的实际bug造成的泄漏。 当怀疑系统有泄漏以后，我们可以怎么查到这些泄漏呢？我强烈建议大家建立一个weak table, 把你所有创建过的能够称之为资源的，包含但不限于“战斗对象，玩家，npc，物品，场景，邮件”等等对象全部扔到这个table里面。当你知道玩家已经下线、战斗已经销毁了，但通过连续的强制full gc以后weak table里面还有这个变量，这就证明了这个变量的引用没有被完全释放，于是问题就被发现了，我们又有事情干了@_@。 知道有泄漏是比较容易的，能够完全揪出来就不是很容易了。是的，它究竟在哪儿呢? 一开始在此项目里面也是先发现比如某npc泄漏了，然后就去查代码，看看究竟哪个地方写得不对。这种方式效率极低，基本上查不到什么问题。在迟一点的时候才使用现在的方案：从_G深度遍历所有的table、metatable、funciton’supvalue、function’s env、registentry(lua_ref)。 目前所知的所有引用必定存在于这几个空间， 遍历完成以后一定可以找到那个“迷失了的引用”。 这种方式在脚本层就可以完成所有事情，甚至你可以在运营环境中在线查证，其遍历的速度是非常快的，但内存开销非常大(:，可以考虑一边遍历一边gc，当然还要记得避免重复搜索。 在应用此方案以后，此项目解决了脚本中所有的泄漏问题。 一点总结：1.如果系统性能还能够承受的话，建议不要直接引用对象，可以多做一层间接层。2.lua里面的弱引用是非常有用的。3.比较大的物理内存是必要的，这可以为大家查证问题争取足够多的时间:) 4.可以把查找泄漏的部分写入到关机逻辑里面，每次关机的时候自动查找泄漏，然后出具报告。","tags":[{"name":"Lua","slug":"lua","permalink":"http://yoursite.com/tags/lua/"}]},{"title":"Java教程","date":"2010-02-22T07:19:09.000Z","path":"2010/02/22/Java教程/","text":"Code Conventions for the Java TM Programming Language Java教程","tags":[{"name":"教程, Java,引道","slug":"教程-java-引道","permalink":"http://yoursite.com/tags/教程-java-引道/"}]},{"title":"ASP.NET MVC","date":"2009-03-10T11:18:12.000Z","path":"2009/03/10/ASP.NET MVC/","text":"ASP.NET 是一个使用 HTML、CSS、JavaScript 和服务器脚本创建网页和网站的开发框架。ASP.NET 支持三种不同的开发模式：Web Pages（Web 页面）、MVC（Model View Controller 模型-视图-控制器）、Web Forms（Web 窗体）。 MVC 编程模式 MVC 是三种 ASP.NET 编程模式中的一种。MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式： Model（模型）表示应用程序核心（比如数据库记录列表）。 View（视图）显示数据（数据库记录）。 Controller（控制器）处理输入（写入数据库记录）。 MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。MVCMVC 模式定义 Web 应用程序带有三个逻辑层：业务层（模型逻辑）显示层（视图逻辑）输入控制（控制器逻辑） Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。 View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。 Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 MVC 分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面。例如，您可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。MVC 分层同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻辑。 Web Forms 对比 MVC MVC 编程模式是对传统 ASP.NET（Web Forms）的一种轻量级的替代方案。它是轻量级的、可测试性高的框架，同时整合了所有已有的 ASP.NET 特性，比如母版页、安全性和认证。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]}]